// @ts-nocheck
/* tslint:disable */
/* eslint-disable */
/**
 * Adatree ADR Platform Data API
 * Adatree\'s Accredited Data Recipient (ADR) Platform Data API definition. Includes Banking and Energy.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: engineering@adatree.com.au
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import {
  DUMMY_BASE_URL,
  assertParamExists,
  setApiKeyToObject,
  setBasicAuthToObject,
  setBearerAuthToObject,
  setOAuthToObject,
  setSearchParams,
  serializeDataIfNeeded,
  toPathString,
  createRequestFunction,
} from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Extra data and metadata provided by Adatree
 * @export
 * @interface Adatree
 */
export interface Adatree {
  /**
   * Consent Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  consentId: string;
  /**
   * Consumer Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  consumerId: string;
  /**
   * CDR Arrangement for related resource
   * @type {string}
   * @memberof Adatree
   */
  cdrArrangementId: string;
  /**
   * Data Holder Brand Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  dataHolderBrandId: string;
  /**
   * Use Case Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  useCaseId: string;
}
/**
 *
 * @export
 * @interface BankingAccount
 */
export interface BankingAccount {
  /**
   * A unique ID of the account adhering to the standards for ID permanence
   * @type {string}
   * @memberof BankingAccount
   */
  accountId: string;
  /**
   * Date that the account was created (if known)
   * @type {string}
   * @memberof BankingAccount
   */
  creationDate?: string;
  /**
   * The display name of the account as defined by the bank. This should not incorporate account numbers or PANs. If it does the values should be masked according to the rules of the MaskedAccountString common type.
   * @type {string}
   * @memberof BankingAccount
   */
  displayName: string;
  /**
   * A customer supplied nickname for the account
   * @type {string}
   * @memberof BankingAccount
   */
  nickname?: string;
  /**
   * Open or closed status for the account. If not present then OPEN is assumed
   * @type {string}
   * @memberof BankingAccount
   */
  openStatus?: BankingAccountOpenStatusEnum;
  /**
   * Flag indicating that the customer associated with the authorisation is an owner of the account. Does not indicate sole ownership, however. If not present then \'true\' is assumed
   * @type {boolean}
   * @memberof BankingAccount
   */
  isOwned?: boolean;
  /**
   * Value indicating the number of customers that have ownership of the account, according to the data holder\'s definition of account ownership. Does not indicate that all account owners are eligible consumers
   * @type {string}
   * @memberof BankingAccount
   */
  accountOwnership?: BankingAccountAccountOwnershipEnum;
  /**
   * A masked version of the account. Whether BSB/Account Number, Credit Card PAN or another number
   * @type {string}
   * @memberof BankingAccount
   */
  maskedNumber: string;
  /**
   *
   * @type {BankingProductCategory}
   * @memberof BankingAccount
   */
  productCategory: BankingProductCategory;
  /**
   * The unique identifier of the account as defined by the data holder (akin to model number for the account)
   * @type {string}
   * @memberof BankingAccount
   */
  productName: string;
}

export const BankingAccountOpenStatusEnum = {
  Open: 'OPEN',
  Closed: 'CLOSED',
} as const;

export type BankingAccountOpenStatusEnum =
  typeof BankingAccountOpenStatusEnum[keyof typeof BankingAccountOpenStatusEnum];
export const BankingAccountAccountOwnershipEnum = {
  Unknown: 'UNKNOWN',
  OneParty: 'ONE_PARTY',
  TwoParty: 'TWO_PARTY',
  ManyParty: 'MANY_PARTY',
  Other: 'OTHER',
} as const;

export type BankingAccountAccountOwnershipEnum =
  typeof BankingAccountAccountOwnershipEnum[keyof typeof BankingAccountAccountOwnershipEnum];

/**
 *
 * @export
 * @interface BankingAccountDetail
 */
export interface BankingAccountDetail {
  /**
   * A unique ID of the account adhering to the standards for ID permanence
   * @type {string}
   * @memberof BankingAccountDetail
   */
  accountId: string;
  /**
   * Date that the account was created (if known)
   * @type {string}
   * @memberof BankingAccountDetail
   */
  creationDate?: string;
  /**
   * The display name of the account as defined by the bank. This should not incorporate account numbers or PANs. If it does the values should be masked according to the rules of the MaskedAccountString common type.
   * @type {string}
   * @memberof BankingAccountDetail
   */
  displayName: string;
  /**
   * A customer supplied nickname for the account
   * @type {string}
   * @memberof BankingAccountDetail
   */
  nickname?: string;
  /**
   * Open or closed status for the account. If not present then OPEN is assumed
   * @type {string}
   * @memberof BankingAccountDetail
   */
  openStatus?: BankingAccountDetailOpenStatusEnum;
  /**
   * Flag indicating that the customer associated with the authorisation is an owner of the account. Does not indicate sole ownership, however. If not present then \'true\' is assumed
   * @type {boolean}
   * @memberof BankingAccountDetail
   */
  isOwned?: boolean;
  /**
   * Value indicating the number of customers that have ownership of the account, according to the data holder\'s definition of account ownership. Does not indicate that all account owners are eligible consumers
   * @type {string}
   * @memberof BankingAccountDetail
   */
  accountOwnership?: BankingAccountDetailAccountOwnershipEnum;
  /**
   * A masked version of the account. Whether BSB/Account Number, Credit Card PAN or another number
   * @type {string}
   * @memberof BankingAccountDetail
   */
  maskedNumber: string;
  /**
   *
   * @type {BankingProductCategory}
   * @memberof BankingAccountDetail
   */
  productCategory: BankingProductCategory;
  /**
   * The unique identifier of the account as defined by the data holder (akin to model number for the account)
   * @type {string}
   * @memberof BankingAccountDetail
   */
  productName: string;
  /**
   * The unmasked BSB for the account. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetail
   */
  bsb?: string;
  /**
   * The unmasked account number for the account. Should not be supplied if the account number is a PAN requiring PCI compliance. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetail
   */
  accountNumber?: string;
  /**
   *
   * @type {BankingBalance}
   * @memberof BankingAccountDetail
   */
  balance?: BankingBalance;
  /**
   * Optional field to indicate if this account is part of a bundle that is providing additional benefit for to the customer
   * @type {string}
   * @memberof BankingAccountDetail
   */
  bundleName?: string;
  /**
   * The type of structure to present account specific fields.
   * @type {string}
   * @memberof BankingAccountDetail
   */
  specificAccountUType?: BankingAccountDetailSpecificAccountUTypeEnum;
  /**
   *
   * @type {Array<BankingTermDepositAccount>}
   * @memberof BankingAccountDetail
   */
  termDeposit?: Array<BankingTermDepositAccount>;
  /**
   *
   * @type {BankingCreditCardAccount}
   * @memberof BankingAccountDetail
   */
  creditCard?: BankingCreditCardAccount;
  /**
   *
   * @type {BankingLoanAccount}
   * @memberof BankingAccountDetail
   */
  loan?: BankingLoanAccount;
  /**
   * current rate to calculate interest earned being applied to deposit balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetail
   */
  depositRate?: string;
  /**
   * The current rate to calculate interest payable being applied to lending balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetail
   */
  lendingRate?: string;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductDepositRate>}
   * @memberof BankingAccountDetail
   */
  depositRates?: Array<BankingProductDepositRate>;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductLendingRateV2>}
   * @memberof BankingAccountDetail
   */
  lendingRates?: Array<BankingProductLendingRateV2>;
  /**
   * Array of features of the account based on the equivalent structure in Product Reference with the following additional field
   * @type {Array<BankingAccountProductFeature>}
   * @memberof BankingAccountDetail
   */
  features?: Array<BankingAccountProductFeature>;
  /**
   * Fees and charges applicable to the account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductFee>}
   * @memberof BankingAccountDetail
   */
  fees?: Array<BankingProductFee>;
  /**
   * The addresses for the account to be used for correspondence
   * @type {Array<CommonPhysicalAddress>}
   * @memberof BankingAccountDetail
   */
  addresses?: Array<CommonPhysicalAddress>;
  /**
   *
   * @type {BankingAccountDetailAdatree}
   * @memberof BankingAccountDetail
   */
  adatree?: BankingAccountDetailAdatree;
}

export const BankingAccountDetailOpenStatusEnum = {
  Open: 'OPEN',
  Closed: 'CLOSED',
} as const;

export type BankingAccountDetailOpenStatusEnum =
  typeof BankingAccountDetailOpenStatusEnum[keyof typeof BankingAccountDetailOpenStatusEnum];
export const BankingAccountDetailAccountOwnershipEnum = {
  Unknown: 'UNKNOWN',
  OneParty: 'ONE_PARTY',
  TwoParty: 'TWO_PARTY',
  ManyParty: 'MANY_PARTY',
  Other: 'OTHER',
} as const;

export type BankingAccountDetailAccountOwnershipEnum =
  typeof BankingAccountDetailAccountOwnershipEnum[keyof typeof BankingAccountDetailAccountOwnershipEnum];
export const BankingAccountDetailSpecificAccountUTypeEnum = {
  TermDeposit: 'termDeposit',
  CreditCard: 'creditCard',
  Loan: 'loan',
} as const;

export type BankingAccountDetailSpecificAccountUTypeEnum =
  typeof BankingAccountDetailSpecificAccountUTypeEnum[keyof typeof BankingAccountDetailSpecificAccountUTypeEnum];

/**
 * Extra data and metadata provided by Adatree for accounts
 * @export
 * @interface BankingAccountDetailAdatree
 */
export interface BankingAccountDetailAdatree {
  /**
   * Consent Id for related resource
   * @type {string}
   * @memberof BankingAccountDetailAdatree
   */
  consentId: string;
  /**
   * Consumer Id for related resource
   * @type {string}
   * @memberof BankingAccountDetailAdatree
   */
  consumerId: string;
  /**
   * CDR Arrangement for related resource
   * @type {string}
   * @memberof BankingAccountDetailAdatree
   */
  cdrArrangementId: string;
  /**
   * Data Holder Brand Id for related resource
   * @type {string}
   * @memberof BankingAccountDetailAdatree
   */
  dataHolderBrandId: string;
  /**
   * Use Case Id for related resource
   * @type {string}
   * @memberof BankingAccountDetailAdatree
   */
  useCaseId: string;
  /**
   *
   * @type {Array<SecuredCdsDataApiError>}
   * @memberof BankingAccountDetailAdatree
   */
  errors: Array<SecuredCdsDataApiError>;
}
/**
 *
 * @export
 * @interface BankingAccountDetailAdatreeAllOf
 */
export interface BankingAccountDetailAdatreeAllOf {
  /**
   *
   * @type {Array<SecuredCdsDataApiError>}
   * @memberof BankingAccountDetailAdatreeAllOf
   */
  errors?: Array<SecuredCdsDataApiError>;
}
/**
 *
 * @export
 * @interface BankingAccountDetailAllOf
 */
export interface BankingAccountDetailAllOf {
  /**
   * The unmasked BSB for the account. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  bsb?: string;
  /**
   * The unmasked account number for the account. Should not be supplied if the account number is a PAN requiring PCI compliance. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  accountNumber?: string;
  /**
   *
   * @type {BankingBalance}
   * @memberof BankingAccountDetailAllOf
   */
  balance?: BankingBalance;
  /**
   * Optional field to indicate if this account is part of a bundle that is providing additional benefit for to the customer
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  bundleName?: string;
  /**
   * The type of structure to present account specific fields.
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  specificAccountUType?: BankingAccountDetailAllOfSpecificAccountUTypeEnum;
  /**
   *
   * @type {Array<BankingTermDepositAccount>}
   * @memberof BankingAccountDetailAllOf
   */
  termDeposit?: Array<BankingTermDepositAccount>;
  /**
   *
   * @type {BankingCreditCardAccount}
   * @memberof BankingAccountDetailAllOf
   */
  creditCard?: BankingCreditCardAccount;
  /**
   *
   * @type {BankingLoanAccount}
   * @memberof BankingAccountDetailAllOf
   */
  loan?: BankingLoanAccount;
  /**
   * current rate to calculate interest earned being applied to deposit balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  depositRate?: string;
  /**
   * The current rate to calculate interest payable being applied to lending balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  lendingRate?: string;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductDepositRate>}
   * @memberof BankingAccountDetailAllOf
   */
  depositRates?: Array<BankingProductDepositRate>;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductLendingRateV2>}
   * @memberof BankingAccountDetailAllOf
   */
  lendingRates?: Array<BankingProductLendingRateV2>;
  /**
   * Array of features of the account based on the equivalent structure in Product Reference with the following additional field
   * @type {Array<BankingAccountProductFeature>}
   * @memberof BankingAccountDetailAllOf
   */
  features?: Array<BankingAccountProductFeature>;
  /**
   * Fees and charges applicable to the account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductFee>}
   * @memberof BankingAccountDetailAllOf
   */
  fees?: Array<BankingProductFee>;
  /**
   * The addresses for the account to be used for correspondence
   * @type {Array<CommonPhysicalAddress>}
   * @memberof BankingAccountDetailAllOf
   */
  addresses?: Array<CommonPhysicalAddress>;
  /**
   *
   * @type {BankingAccountDetailAdatree}
   * @memberof BankingAccountDetailAllOf
   */
  adatree?: BankingAccountDetailAdatree;
}

export const BankingAccountDetailAllOfSpecificAccountUTypeEnum = {
  TermDeposit: 'termDeposit',
  CreditCard: 'creditCard',
  Loan: 'loan',
} as const;

export type BankingAccountDetailAllOfSpecificAccountUTypeEnum =
  typeof BankingAccountDetailAllOfSpecificAccountUTypeEnum[keyof typeof BankingAccountDetailAllOfSpecificAccountUTypeEnum];

/**
 *
 * @export
 * @interface BankingAccountList
 */
export interface BankingAccountList {
  /**
   *
   * @type {BankingAccountListData}
   * @memberof BankingAccountList
   */
  data: BankingAccountListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingAccountList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingAccountList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingAccountListData
 */
export interface BankingAccountListData {
  /**
   * The list of accounts returned. If the filter results in an empty set then this array may have no records
   * @type {Array<BankingAccountDetail>}
   * @memberof BankingAccountListData
   */
  accounts: Array<BankingAccountDetail>;
}
/**
 * Array of features of the account based on the equivalent structure in Product Reference with the following additional field
 * @export
 * @interface BankingAccountProductFeature
 */
export interface BankingAccountProductFeature {
  /**
   * The type of feature described
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  featureType: BankingAccountProductFeatureFeatureTypeEnum;
  /**
   * Generic field containing additional information relevant to the [featureType](#tocSproductfeaturetypedoc) specified. Whether mandatory or not is dependent on the value of the [featureType.](#tocSproductfeaturetypedoc)
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the feature. Mandatory if the [feature type](#tocSproductfeaturetypedoc) is set to OTHER
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this feature
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  additionalInfoUri?: string;
  /**
   * True if the feature is already activated and false if the feature is available for activation. Defaults to true if absent. (note this is an additional field appended to the feature object defined in the Product Reference payload)
   * @type {boolean}
   * @memberof BankingAccountProductFeature
   */
  isActivated?: boolean;
}

export const BankingAccountProductFeatureFeatureTypeEnum = {
  AdditionalCards: 'ADDITIONAL_CARDS',
  BalanceTransfers: 'BALANCE_TRANSFERS',
  BillPayment: 'BILL_PAYMENT',
  BonusRewards: 'BONUS_REWARDS',
  CardAccess: 'CARD_ACCESS',
  CashbackOffer: 'CASHBACK_OFFER',
  ComplementaryProductDiscounts: 'COMPLEMENTARY_PRODUCT_DISCOUNTS',
  DigitalBanking: 'DIGITAL_BANKING',
  DigitalWallet: 'DIGITAL_WALLET',
  DonateInterest: 'DONATE_INTEREST',
  ExtraRepayments: 'EXTRA_REPAYMENTS',
  FraudProtection: 'FRAUD_PROTECTION',
  FreeTxns: 'FREE_TXNS',
  FreeTxnsAllowance: 'FREE_TXNS_ALLOWANCE',
  Guarantor: 'GUARANTOR',
  Insurance: 'INSURANCE',
  InstalmentPlan: 'INSTALMENT_PLAN',
  InterestFree: 'INTEREST_FREE',
  InterestFreeTransfers: 'INTEREST_FREE_TRANSFERS',
  LoyaltyProgram: 'LOYALTY_PROGRAM',
  Notifications: 'NOTIFICATIONS',
  NppEnabled: 'NPP_ENABLED',
  NppPayid: 'NPP_PAYID',
  Offset: 'OFFSET',
  Other: 'OTHER',
  Overdraft: 'OVERDRAFT',
  Redraw: 'REDRAW',
  RelationshipManagement: 'RELATIONSHIP_MANAGEMENT',
  UnlimitedTxns: 'UNLIMITED_TXNS',
} as const;

export type BankingAccountProductFeatureFeatureTypeEnum =
  typeof BankingAccountProductFeatureFeatureTypeEnum[keyof typeof BankingAccountProductFeatureFeatureTypeEnum];

/**
 *
 * @export
 * @interface BankingAccountProductFeatureAllOf
 */
export interface BankingAccountProductFeatureAllOf {
  /**
   * True if the feature is already activated and false if the feature is available for activation. Defaults to true if absent. (note this is an additional field appended to the feature object defined in the Product Reference payload)
   * @type {boolean}
   * @memberof BankingAccountProductFeatureAllOf
   */
  isActivated?: boolean;
}
/**
 *
 * @export
 * @interface BankingAuthorisedEntity
 */
export interface BankingAuthorisedEntity {
  /**
   * Description of the authorised entity derived from previously executed direct debits
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  description?: string;
  /**
   * Name of the financial institution through which the direct debit will be executed. Is required unless the payment is made via a credit card scheme
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  financialInstitution?: string;
  /**
   * Australian Business Number for the authorised entity
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  abn?: string;
  /**
   * Australian Company Number for the authorised entity
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  acn?: string;
  /**
   * Australian Registered Body Number for the authorised entity
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  arbn?: string;
}
/**
 *
 * @export
 * @interface BankingBalance
 */
export interface BankingBalance {
  /**
   * The balance of the account at this time. Should align to the balance available via other channels such as Internet Banking. Assumed to be negative if the customer has money owing
   * @type {string}
   * @memberof BankingBalance
   */
  currentBalance: string;
  /**
   * Balance representing the amount of funds available for transfer. Assumed to be zero or positive
   * @type {string}
   * @memberof BankingBalance
   */
  availableBalance: string;
  /**
   * Object representing the maximum amount of credit that is available for this account. Assumed to be zero if absent
   * @type {string}
   * @memberof BankingBalance
   */
  creditLimit?: string;
  /**
   * Object representing the available limit amortised according to payment schedule. Assumed to be zero if absent
   * @type {string}
   * @memberof BankingBalance
   */
  amortisedLimit?: string;
  /**
   * The currency for the balance amounts. If absent assumed to be AUD
   * @type {string}
   * @memberof BankingBalance
   */
  currency?: string;
  /**
   * Optional array of balances for the account in other currencies. Included to support accounts that support multi-currency purses such as Travel Cards
   * @type {Array<BankingBalancePurse>}
   * @memberof BankingBalance
   */
  purses?: Array<BankingBalancePurse>;
  /**
   * Most recent refresh date time stamp
   * @type {string}
   * @memberof BankingBalance
   */
  refreshDateTime?: string;
}
/**
 *
 * @export
 * @interface BankingBalancePurse
 */
export interface BankingBalancePurse {
  /**
   * The balance available for this additional currency purse
   * @type {string}
   * @memberof BankingBalancePurse
   */
  amount: string;
  /**
   * The currency for the purse
   * @type {string}
   * @memberof BankingBalancePurse
   */
  currency?: string;
}
/**
 *
 * @export
 * @interface BankingBillerPayee
 */
export interface BankingBillerPayee {
  /**
   * BPAY Biller Code of the Biller
   * @type {string}
   * @memberof BankingBillerPayee
   */
  billerCode: string;
  /**
   * BPAY CRN of the Biller (if available).<br/>Where the CRN contains sensitive information, it should be masked in line with how the Data Holder currently displays account identifiers in their existing online banking channels. If the contents of the CRN match the format of a Credit Card PAN they should be masked according to the rules applicable for MaskedPANString. If the contents are otherwise sensitive, then it should be masked using the rules applicable for the MaskedAccountString common type.
   * @type {string}
   * @memberof BankingBillerPayee
   */
  crn?: string;
  /**
   * Name of the Biller
   * @type {string}
   * @memberof BankingBillerPayee
   */
  billerName: string;
}
/**
 *
 * @export
 * @interface BankingCreditCardAccount
 */
export interface BankingCreditCardAccount {
  /**
   * The minimum payment amount due for the next card payment
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  minPaymentAmount: string;
  /**
   * The amount due for the next card payment
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  paymentDueAmount: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  paymentCurrency?: string;
  /**
   * Date that the next payment for the card is due
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  paymentDueDate: string;
}
/**
 *
 * @export
 * @interface BankingDigitalWalletPayee
 */
export interface BankingDigitalWalletPayee {
  /**
   * The name assigned to the digital wallet by the owner of the wallet, else the display name provided by the digital wallet provider
   * @type {string}
   * @memberof BankingDigitalWalletPayee
   */
  name: string;
  /**
   * The identifier of the digital wallet (dependent on type)
   * @type {string}
   * @memberof BankingDigitalWalletPayee
   */
  identifier: string;
  /**
   * The type of the digital wallet identifier
   * @type {string}
   * @memberof BankingDigitalWalletPayee
   */
  type: BankingDigitalWalletPayeeTypeEnum;
  /**
   * The provider of the digital wallet
   * @type {string}
   * @memberof BankingDigitalWalletPayee
   */
  provider: BankingDigitalWalletPayeeProviderEnum;
}

export const BankingDigitalWalletPayeeTypeEnum = {
  Email: 'EMAIL',
  ContactName: 'CONTACT_NAME',
  Telephone: 'TELEPHONE',
} as const;

export type BankingDigitalWalletPayeeTypeEnum =
  typeof BankingDigitalWalletPayeeTypeEnum[keyof typeof BankingDigitalWalletPayeeTypeEnum];
export const BankingDigitalWalletPayeeProviderEnum = {
  PaypalAu: 'PAYPAL_AU',
  Other: 'OTHER',
} as const;

export type BankingDigitalWalletPayeeProviderEnum =
  typeof BankingDigitalWalletPayeeProviderEnum[keyof typeof BankingDigitalWalletPayeeProviderEnum];

/**
 *
 * @export
 * @interface BankingDirectDebit
 */
export interface BankingDirectDebit {
  /**
   * A unique ID of the account adhering to the standards for ID permanence.
   * @type {string}
   * @memberof BankingDirectDebit
   */
  accountId: string;
  /**
   *
   * @type {BankingAuthorisedEntity}
   * @memberof BankingDirectDebit
   */
  authorisedEntity: BankingAuthorisedEntity;
  /**
   * The date and time of the last debit executed under this authorisation
   * @type {string}
   * @memberof BankingDirectDebit
   */
  lastDebitDateTime?: string;
  /**
   * The amount of the last debit executed under this authorisation
   * @type {string}
   * @memberof BankingDirectDebit
   */
  lastDebitAmount?: string;
  /**
   *
   * @type {Adatree}
   * @memberof BankingDirectDebit
   */
  adatree?: Adatree;
}
/**
 *
 * @export
 * @interface BankingDirectDebitAuthorisationList
 */
export interface BankingDirectDebitAuthorisationList {
  /**
   *
   * @type {BankingDirectDebitAuthorisationListData}
   * @memberof BankingDirectDebitAuthorisationList
   */
  data: BankingDirectDebitAuthorisationListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingDirectDebitAuthorisationList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingDirectDebitAuthorisationList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingDirectDebitAuthorisationListData
 */
export interface BankingDirectDebitAuthorisationListData {
  /**
   * The list of authorisations returned
   * @type {Array<BankingDirectDebit>}
   * @memberof BankingDirectDebitAuthorisationListData
   */
  directDebitAuthorisations: Array<BankingDirectDebit>;
}
/**
 *
 * @export
 * @interface BankingDomesticPayee
 */
export interface BankingDomesticPayee {
  /**
   * Type of account object included. Valid values are: **account** A standard Australian account defined by BSB/Account Number. **card** A credit or charge card to pay to (note that PANs are masked). **payId** A PayID recognised by NPP
   * @type {string}
   * @memberof BankingDomesticPayee
   */
  payeeAccountUType: BankingDomesticPayeePayeeAccountUTypeEnum;
  /**
   *
   * @type {BankingDomesticPayeeAccount}
   * @memberof BankingDomesticPayee
   */
  account?: BankingDomesticPayeeAccount;
  /**
   *
   * @type {BankingDomesticPayeeCard}
   * @memberof BankingDomesticPayee
   */
  card?: BankingDomesticPayeeCard;
  /**
   *
   * @type {BankingDomesticPayeePayId}
   * @memberof BankingDomesticPayee
   */
  payId?: BankingDomesticPayeePayId;
}

export const BankingDomesticPayeePayeeAccountUTypeEnum = {
  Account: 'account',
  Card: 'card',
  PayId: 'payId',
} as const;

export type BankingDomesticPayeePayeeAccountUTypeEnum =
  typeof BankingDomesticPayeePayeeAccountUTypeEnum[keyof typeof BankingDomesticPayeePayeeAccountUTypeEnum];

/**
 *
 * @export
 * @interface BankingDomesticPayeeAccount
 */
export interface BankingDomesticPayeeAccount {
  /**
   * Name of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeAccount
   */
  accountName?: string;
  /**
   * BSB of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeAccount
   */
  bsb: string;
  /**
   * Number of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeAccount
   */
  accountNumber: string;
}
/**
 *
 * @export
 * @interface BankingDomesticPayeeCard
 */
export interface BankingDomesticPayeeCard {
  /**
   * Name of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeCard
   */
  cardNumber: string;
}
/**
 *
 * @export
 * @interface BankingDomesticPayeePayId
 */
export interface BankingDomesticPayeePayId {
  /**
   * The name assigned to the PayID by the owner of the PayID
   * @type {string}
   * @memberof BankingDomesticPayeePayId
   */
  name?: string;
  /**
   * The identifier of the PayID (dependent on type)
   * @type {string}
   * @memberof BankingDomesticPayeePayId
   */
  identifier: string;
  /**
   * The type of the PayID
   * @type {string}
   * @memberof BankingDomesticPayeePayId
   */
  type: BankingDomesticPayeePayIdTypeEnum;
}

export const BankingDomesticPayeePayIdTypeEnum = {
  Abn: 'ABN',
  Email: 'EMAIL',
  OrgIdentifier: 'ORG_IDENTIFIER',
  Telephone: 'TELEPHONE',
} as const;

export type BankingDomesticPayeePayIdTypeEnum =
  typeof BankingDomesticPayeePayIdTypeEnum[keyof typeof BankingDomesticPayeePayIdTypeEnum];

/**
 *
 * @export
 * @interface BankingInternationalPayee
 */
export interface BankingInternationalPayee {
  /**
   *
   * @type {BankingInternationalPayeeBeneficiaryDetails}
   * @memberof BankingInternationalPayee
   */
  beneficiaryDetails: BankingInternationalPayeeBeneficiaryDetails;
  /**
   *
   * @type {BankingInternationalPayeeBankDetails}
   * @memberof BankingInternationalPayee
   */
  bankDetails: BankingInternationalPayeeBankDetails;
}
/**
 *
 * @export
 * @interface BankingInternationalPayeeBankDetails
 */
export interface BankingInternationalPayeeBankDetails {
  /**
   * Country of the recipient institution. A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  country: string;
  /**
   * Account Targeted for payment
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  accountNumber: string;
  /**
   *
   * @type {BankingInternationalPayeeBankDetailsBankAddress}
   * @memberof BankingInternationalPayeeBankDetails
   */
  bankAddress?: BankingInternationalPayeeBankDetailsBankAddress;
  /**
   * Swift bank code.  Aligns with standard [ISO 9362](https://www.iso.org/standard/60390.html)
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  beneficiaryBankBIC?: string;
  /**
   * Number for Fedwire payment (Federal Reserve Wire Network)
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  fedWireNumber?: string;
  /**
   * Sort code used for account identification in some jurisdictions
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  sortCode?: string;
  /**
   * Number for the Clearing House Interbank Payments System
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  chipNumber?: string;
  /**
   * International bank routing number
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  routingNumber?: string;
  /**
   * The legal entity identifier (LEI) for the beneficiary.  Aligns with [ISO 17442](https://www.iso.org/standard/59771.html)
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  legalEntityIdentifier?: string;
}
/**
 *
 * @export
 * @interface BankingInternationalPayeeBankDetailsBankAddress
 */
export interface BankingInternationalPayeeBankDetailsBankAddress {
  /**
   * Name of the recipient Bank
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetailsBankAddress
   */
  name: string;
  /**
   * Address of the recipient Bank
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetailsBankAddress
   */
  address: string;
}
/**
 *
 * @export
 * @interface BankingInternationalPayeeBeneficiaryDetails
 */
export interface BankingInternationalPayeeBeneficiaryDetails {
  /**
   * Name of the beneficiary
   * @type {string}
   * @memberof BankingInternationalPayeeBeneficiaryDetails
   */
  name?: string;
  /**
   * Country where the beneficiary resides. A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code
   * @type {string}
   * @memberof BankingInternationalPayeeBeneficiaryDetails
   */
  country: string;
  /**
   * Response message for the payment
   * @type {string}
   * @memberof BankingInternationalPayeeBeneficiaryDetails
   */
  message?: string;
}
/**
 *
 * @export
 * @interface BankingLoanAccount
 */
export interface BankingLoanAccount {
  /**
   * Optional original start date for the loan
   * @type {string}
   * @memberof BankingLoanAccount
   */
  originalStartDate?: string;
  /**
   * Optional original loan value
   * @type {string}
   * @memberof BankingLoanAccount
   */
  originalLoanAmount?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  originalLoanCurrency?: string;
  /**
   * Date that the loan is due to be repaid in full
   * @type {string}
   * @memberof BankingLoanAccount
   */
  loanEndDate: string;
  /**
   * Next date that an instalment is required
   * @type {string}
   * @memberof BankingLoanAccount
   */
  nextInstalmentDate: string;
  /**
   * Minimum amount of next instalment
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minInstalmentAmount?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minInstalmentCurrency?: string;
  /**
   * Maximum amount of funds that can be redrawn. If not present redraw is not available even if the feature exists for the account
   * @type {string}
   * @memberof BankingLoanAccount
   */
  maxRedraw?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  maxRedrawCurrency?: string;
  /**
   * Minimum redraw amount
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minRedraw?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minRedrawCurrency?: string;
  /**
   * Set to true if one or more offset accounts are configured for this loan account
   * @type {boolean}
   * @memberof BankingLoanAccount
   */
  offsetAccountEnabled?: boolean;
  /**
   * The accountIDs of the configured offset accounts attached to this loan. Only offset accounts that can be accessed under the current authorisation should be included. It is expected behaviour that offsetAccountEnabled is set to true but the offsetAccountIds field is absent or empty. This represents a situation where an offset account exists but details can not be accessed under the current authorisation
   * @type {Array<string>}
   * @memberof BankingLoanAccount
   */
  offsetAccountIds?: Array<string>;
  /**
   * Options in place for repayments. If absent defaults to PRINCIPAL_AND_INTEREST
   * @type {string}
   * @memberof BankingLoanAccount
   */
  repaymentType?: BankingLoanAccountRepaymentTypeEnum;
  /**
   * The expected or required repayment frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingLoanAccount
   */
  repaymentFrequency: string;
}

export const BankingLoanAccountRepaymentTypeEnum = {
  InterestOnly: 'INTEREST_ONLY',
  PrincipalAndInterest: 'PRINCIPAL_AND_INTEREST',
} as const;

export type BankingLoanAccountRepaymentTypeEnum =
  typeof BankingLoanAccountRepaymentTypeEnum[keyof typeof BankingLoanAccountRepaymentTypeEnum];

/**
 *
 * @export
 * @interface BankingPayee
 */
export interface BankingPayee {
  /**
   * ID of the payee adhering to the rules of ID permanence
   * @type {string}
   * @memberof BankingPayee
   */
  payeeId: string;
  /**
   * The short display name of the payee as provided by the customer. Where a customer has not provided a nickname, a display name derived by the bank for the payee consistent with existing digital banking channels
   * @type {string}
   * @memberof BankingPayee
   */
  nickname: string;
  /**
   * A description of the payee provided by the customer
   * @type {string}
   * @memberof BankingPayee
   */
  description?: string;
  /**
   * The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. wallet
   * @type {string}
   * @memberof BankingPayee
   */
  type: BankingPayeeTypeEnum;
  /**
   * The date the payee was created by the customer
   * @type {string}
   * @memberof BankingPayee
   */
  creationDate?: string;
}

export const BankingPayeeTypeEnum = {
  Biller: 'BILLER',
  DigitalWallet: 'DIGITAL_WALLET',
  Domestic: 'DOMESTIC',
  International: 'INTERNATIONAL',
} as const;

export type BankingPayeeTypeEnum = typeof BankingPayeeTypeEnum[keyof typeof BankingPayeeTypeEnum];

/**
 *
 * @export
 * @interface BankingPayeeDetail
 */
export interface BankingPayeeDetail {
  /**
   * ID of the payee adhering to the rules of ID permanence
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  payeeId: string;
  /**
   * The short display name of the payee as provided by the customer. Where a customer has not provided a nickname, a display name derived by the bank for the payee consistent with existing digital banking channels
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  nickname: string;
  /**
   * A description of the payee provided by the customer
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  description?: string;
  /**
   * The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. wallet
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  type: BankingPayeeDetailTypeEnum;
  /**
   * The date the payee was created by the customer
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  creationDate?: string;
  /**
   * Type of object included that describes the payee in detail
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  payeeUType: BankingPayeeDetailPayeeUTypeEnum;
  /**
   *
   * @type {BankingBillerPayee}
   * @memberof BankingPayeeDetail
   */
  biller?: BankingBillerPayee;
  /**
   *
   * @type {BankingDigitalWalletPayee}
   * @memberof BankingPayeeDetail
   */
  digitalWallet?: BankingDigitalWalletPayee;
  /**
   *
   * @type {BankingDomesticPayee}
   * @memberof BankingPayeeDetail
   */
  domestic?: BankingDomesticPayee;
  /**
   *
   * @type {BankingInternationalPayee}
   * @memberof BankingPayeeDetail
   */
  international?: BankingInternationalPayee;
  /**
   *
   * @type {Adatree}
   * @memberof BankingPayeeDetail
   */
  adatree?: Adatree;
}

export const BankingPayeeDetailTypeEnum = {
  Biller: 'BILLER',
  DigitalWallet: 'DIGITAL_WALLET',
  Domestic: 'DOMESTIC',
  International: 'INTERNATIONAL',
} as const;

export type BankingPayeeDetailTypeEnum = typeof BankingPayeeDetailTypeEnum[keyof typeof BankingPayeeDetailTypeEnum];
export const BankingPayeeDetailPayeeUTypeEnum = {
  Biller: 'biller',
  DigitalWallet: 'digitalWallet',
  Domestic: 'domestic',
  International: 'international',
} as const;

export type BankingPayeeDetailPayeeUTypeEnum =
  typeof BankingPayeeDetailPayeeUTypeEnum[keyof typeof BankingPayeeDetailPayeeUTypeEnum];

/**
 *
 * @export
 * @interface BankingPayeeDetailAllOf
 */
export interface BankingPayeeDetailAllOf {
  /**
   * Type of object included that describes the payee in detail
   * @type {string}
   * @memberof BankingPayeeDetailAllOf
   */
  payeeUType: BankingPayeeDetailAllOfPayeeUTypeEnum;
  /**
   *
   * @type {BankingBillerPayee}
   * @memberof BankingPayeeDetailAllOf
   */
  biller?: BankingBillerPayee;
  /**
   *
   * @type {BankingDigitalWalletPayee}
   * @memberof BankingPayeeDetailAllOf
   */
  digitalWallet?: BankingDigitalWalletPayee;
  /**
   *
   * @type {BankingDomesticPayee}
   * @memberof BankingPayeeDetailAllOf
   */
  domestic?: BankingDomesticPayee;
  /**
   *
   * @type {BankingInternationalPayee}
   * @memberof BankingPayeeDetailAllOf
   */
  international?: BankingInternationalPayee;
}

export const BankingPayeeDetailAllOfPayeeUTypeEnum = {
  Biller: 'biller',
  DigitalWallet: 'digitalWallet',
  Domestic: 'domestic',
  International: 'international',
} as const;

export type BankingPayeeDetailAllOfPayeeUTypeEnum =
  typeof BankingPayeeDetailAllOfPayeeUTypeEnum[keyof typeof BankingPayeeDetailAllOfPayeeUTypeEnum];

/**
 *
 * @export
 * @interface BankingPayeeDetailAllOf1
 */
export interface BankingPayeeDetailAllOf1 {
  /**
   *
   * @type {Adatree}
   * @memberof BankingPayeeDetailAllOf1
   */
  adatree?: Adatree;
}
/**
 *
 * @export
 * @interface BankingPayeeList
 */
export interface BankingPayeeList {
  /**
   *
   * @type {BankingPayeeListData}
   * @memberof BankingPayeeList
   */
  data: BankingPayeeListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingPayeeList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingPayeeList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingPayeeListData
 */
export interface BankingPayeeListData {
  /**
   *
   * @type {Array<BankingPayeeDetail>}
   * @memberof BankingPayeeListData
   */
  payees: Array<BankingPayeeDetail>;
}
/**
 *
 * @export
 * @interface BankingProductAdditionalInformationV2AdditionalInformationUris
 */
export interface BankingProductAdditionalInformationV2AdditionalInformationUris {
  /**
   * Display text providing more information about the document URI
   * @type {string}
   * @memberof BankingProductAdditionalInformationV2AdditionalInformationUris
   */
  description?: string;
  /**
   * The URI describing the additional information
   * @type {string}
   * @memberof BankingProductAdditionalInformationV2AdditionalInformationUris
   */
  additionalInfoUri: string;
}
/**
 *
 * @export
 * @interface BankingProductBundle
 */
export interface BankingProductBundle {
  /**
   * Name of the bundle
   * @type {string}
   * @memberof BankingProductBundle
   */
  name: string;
  /**
   * Description of the bundle
   * @type {string}
   * @memberof BankingProductBundle
   */
  description: string;
  /**
   * Display text providing more information on the bundle
   * @type {string}
   * @memberof BankingProductBundle
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on the bundle criteria and benefits
   * @type {string}
   * @memberof BankingProductBundle
   */
  additionalInfoUri?: string;
  /**
   * Array of product IDs for products included in the bundle that are available via the product end points.  Note that this array is not intended to represent a comprehensive model of the products included in the bundle and some products available for the bundle may not be available via the product reference end points
   * @type {Array<string>}
   * @memberof BankingProductBundle
   */
  productIds?: Array<string>;
}
/**
 * The category to which a product or account belongs. See [here](#product-categories) for more details
 * @export
 * @enum {string}
 */

export const BankingProductCategory = {
  BusinessLoans: 'BUSINESS_LOANS',
  CredAndChrgCards: 'CRED_AND_CHRG_CARDS',
  Leases: 'LEASES',
  MarginLoans: 'MARGIN_LOANS',
  Overdrafts: 'OVERDRAFTS',
  PersLoans: 'PERS_LOANS',
  RegulatedTrustAccounts: 'REGULATED_TRUST_ACCOUNTS',
  ResidentialMortgages: 'RESIDENTIAL_MORTGAGES',
  TermDeposits: 'TERM_DEPOSITS',
  TradeFinance: 'TRADE_FINANCE',
  TravelCards: 'TRAVEL_CARDS',
  TransAndSavingsAccounts: 'TRANS_AND_SAVINGS_ACCOUNTS',
} as const;

export type BankingProductCategory = typeof BankingProductCategory[keyof typeof BankingProductCategory];

/**
 *
 * @export
 * @interface BankingProductConstraint
 */
export interface BankingProductConstraint {
  /**
   * The type of constraint described.  See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductConstraint
   */
  constraintType: BankingProductConstraintConstraintTypeEnum;
  /**
   * Generic field containing additional information relevant to the [constraintType](#tocSproductconstrainttypedoc) specified.  Whether mandatory or not is dependent on the value of [constraintType](#tocSproductconstrainttypedoc)
   * @type {string}
   * @memberof BankingProductConstraint
   */
  additionalValue?: string;
  /**
   * Display text providing more information the constraint
   * @type {string}
   * @memberof BankingProductConstraint
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on the constraint
   * @type {string}
   * @memberof BankingProductConstraint
   */
  additionalInfoUri?: string;
}

export const BankingProductConstraintConstraintTypeEnum = {
  MinBalance: 'MIN_BALANCE',
  MinLimit: 'MIN_LIMIT',
  MaxBalance: 'MAX_BALANCE',
  MaxLimit: 'MAX_LIMIT',
  OpeningBalance: 'OPENING_BALANCE',
} as const;

export type BankingProductConstraintConstraintTypeEnum =
  typeof BankingProductConstraintConstraintTypeEnum[keyof typeof BankingProductConstraintConstraintTypeEnum];

/**
 *
 * @export
 * @interface BankingProductDepositRate
 */
export interface BankingProductDepositRate {
  /**
   * The type of rate (base, bonus, etc). See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  depositRateType: BankingProductDepositRateDepositRateTypeEnum;
  /**
   * The rate to be applied
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  rate: string;
  /**
   * The period after which the rate is applied to the balance to calculate the amount due for the period. Calculation of the amount is often daily (as balances may change) but accumulated until the total amount is \'applied\' to the account (see applicationFrequency). Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  calculationFrequency?: string;
  /**
   * The period after which the calculated amount(s) (see calculationFrequency) are \'applied\' (i.e. debited or credited) to the account. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  applicationFrequency?: string;
  /**
   * Rate tiers applicable for this rate
   * @type {Array<BankingProductRateTierV3>}
   * @memberof BankingProductDepositRate
   */
  tiers?: Array<BankingProductRateTierV3>;
  /**
   * Generic field containing additional information relevant to the [depositRateType](#tocSproductdepositratetypedoc) specified. Whether mandatory or not is dependent on the value of [depositRateType](#tocSproductdepositratetypedoc)
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the rate
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this rate
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  additionalInfoUri?: string;
}

export const BankingProductDepositRateDepositRateTypeEnum = {
  Bonus: 'BONUS',
  BundleBonus: 'BUNDLE_BONUS',
  Fixed: 'FIXED',
  Floating: 'FLOATING',
  Introductory: 'INTRODUCTORY',
  MarketLinked: 'MARKET_LINKED',
  Variable: 'VARIABLE',
} as const;

export type BankingProductDepositRateDepositRateTypeEnum =
  typeof BankingProductDepositRateDepositRateTypeEnum[keyof typeof BankingProductDepositRateDepositRateTypeEnum];

/**
 *
 * @export
 * @interface BankingProductDetail
 */
export interface BankingProductDetail {
  /**
   * A data holder specific unique identifier for this product. This identifier must be unique to a product but does not otherwise need to adhere to ID permanence guidelines.
   * @type {string}
   * @memberof BankingProductDetail
   */
  productId: string;
  /**
   * The date and time from which this product is effective (ie. is available for origination).  Used to enable the articulation of products to the regime before they are available for customers to originate
   * @type {string}
   * @memberof BankingProductDetail
   */
  effectiveFrom?: string;
  /**
   * The date and time at which this product will be retired and will no longer be offered.  Used to enable the managed deprecation of products
   * @type {string}
   * @memberof BankingProductDetail
   */
  effectiveTo?: string;
  /**
   * The last date and time that the information for this product was changed (or the creation date for the product if it has never been altered)
   * @type {string}
   * @memberof BankingProductDetail
   */
  lastUpdated: string;
  /**
   * The id of data holder
   * @type {string}
   * @memberof BankingProductDetail
   */
  dataHolderId: string;
  /**
   * The brand name of data holder
   * @type {string}
   * @memberof BankingProductDetail
   */
  dataHolderBrandName?: string;
  /**
   *
   * @type {BankingProductCategory}
   * @memberof BankingProductDetail
   */
  productCategory: BankingProductCategory;
  /**
   * The display name of the product
   * @type {string}
   * @memberof BankingProductDetail
   */
  name: string;
  /**
   * A description of the product
   * @type {string}
   * @memberof BankingProductDetail
   */
  description: string;
  /**
   * A label of the brand for the product. Able to be used for filtering. For data holders with single brands this value is still required
   * @type {string}
   * @memberof BankingProductDetail
   */
  brand: string;
  /**
   * An optional display name of the brand
   * @type {string}
   * @memberof BankingProductDetail
   */
  brandName?: string;
  /**
   * A link to an application web page where this product can be applied for.
   * @type {string}
   * @memberof BankingProductDetail
   */
  applicationUri?: string;
  /**
   * Indicates whether the product is specifically tailored to a circumstance.  In this case fees and prices are significantly negotiated depending on context. While all products are open to a degree of tailoring this flag indicates that tailoring is expected and thus that the provision of specific fees and rates is not applicable
   * @type {boolean}
   * @memberof BankingProductDetail
   */
  isTailored: boolean;
  /**
   *
   * @type {BankingProductV3AdditionalInformation}
   * @memberof BankingProductDetail
   */
  additionalInformation?: BankingProductV3AdditionalInformation;
  /**
   * An array of card art images
   * @type {Array<BankingProductV3CardArt>}
   * @memberof BankingProductDetail
   */
  cardArt?: Array<BankingProductV3CardArt>;
  /**
   * An array of bundles that this product participates in.  Each bundle is described by free form information but also by a list of product IDs of the other products that are included in the bundle.  It is assumed that the current product is included in the bundle also
   * @type {Array<BankingProductBundle>}
   * @memberof BankingProductDetail
   */
  bundles?: Array<BankingProductBundle>;
  /**
   * Array of features available for the product
   * @type {Array<BankingProductFeature>}
   * @memberof BankingProductDetail
   */
  features?: Array<BankingProductFeature>;
  /**
   * Constraints on the application for or operation of the product such as minimum balances or limit thresholds
   * @type {Array<BankingProductConstraint>}
   * @memberof BankingProductDetail
   */
  constraints?: Array<BankingProductConstraint>;
  /**
   * Eligibility criteria for the product
   * @type {Array<BankingProductEligibility>}
   * @memberof BankingProductDetail
   */
  eligibility?: Array<BankingProductEligibility>;
  /**
   * Fees applicable for the product
   * @type {Array<BankingProductFee>}
   * @memberof BankingProductDetail
   */
  fees?: Array<BankingProductFee>;
  /**
   * Interest rates available for deposits
   * @type {Array<BankingProductDepositRate>}
   * @memberof BankingProductDetail
   */
  depositRates?: Array<BankingProductDepositRate>;
  /**
   * Interest rates charged against lending balances
   * @type {Array<BankingProductLendingRateV2>}
   * @memberof BankingProductDetail
   */
  lendingRates?: Array<BankingProductLendingRateV2>;
}
/**
 *
 * @export
 * @interface BankingProductDetailAllOf
 */
export interface BankingProductDetailAllOf {
  /**
   * An array of bundles that this product participates in.  Each bundle is described by free form information but also by a list of product IDs of the other products that are included in the bundle.  It is assumed that the current product is included in the bundle also
   * @type {Array<BankingProductBundle>}
   * @memberof BankingProductDetailAllOf
   */
  bundles?: Array<BankingProductBundle>;
  /**
   * Array of features available for the product
   * @type {Array<BankingProductFeature>}
   * @memberof BankingProductDetailAllOf
   */
  features?: Array<BankingProductFeature>;
  /**
   * Constraints on the application for or operation of the product such as minimum balances or limit thresholds
   * @type {Array<BankingProductConstraint>}
   * @memberof BankingProductDetailAllOf
   */
  constraints?: Array<BankingProductConstraint>;
  /**
   * Eligibility criteria for the product
   * @type {Array<BankingProductEligibility>}
   * @memberof BankingProductDetailAllOf
   */
  eligibility?: Array<BankingProductEligibility>;
  /**
   * Fees applicable for the product
   * @type {Array<BankingProductFee>}
   * @memberof BankingProductDetailAllOf
   */
  fees?: Array<BankingProductFee>;
  /**
   * Interest rates available for deposits
   * @type {Array<BankingProductDepositRate>}
   * @memberof BankingProductDetailAllOf
   */
  depositRates?: Array<BankingProductDepositRate>;
  /**
   * Interest rates charged against lending balances
   * @type {Array<BankingProductLendingRateV2>}
   * @memberof BankingProductDetailAllOf
   */
  lendingRates?: Array<BankingProductLendingRateV2>;
}
/**
 *
 * @export
 * @interface BankingProductDiscount
 */
export interface BankingProductDiscount {
  /**
   * Description of the discount
   * @type {string}
   * @memberof BankingProductDiscount
   */
  description: string;
  /**
   * The type of discount. See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductDiscount
   */
  discountType: BankingProductDiscountDiscountTypeEnum;
  /**
   * Dollar value of the discount. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory.
   * @type {string}
   * @memberof BankingProductDiscount
   */
  amount?: string;
  /**
   * A discount rate calculated based on a proportion of the balance. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
   * @type {string}
   * @memberof BankingProductDiscount
   */
  balanceRate?: string;
  /**
   * A discount rate calculated based on a proportion of a transaction. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory
   * @type {string}
   * @memberof BankingProductDiscount
   */
  transactionRate?: string;
  /**
   * A discount rate calculated based on a proportion of the calculated interest accrued on the account. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
   * @type {string}
   * @memberof BankingProductDiscount
   */
  accruedRate?: string;
  /**
   * A discount rate calculated based on a proportion of the fee to which this discount is attached. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
   * @type {string}
   * @memberof BankingProductDiscount
   */
  feeRate?: string;
  /**
   * Generic field containing additional information relevant to the [discountType](#tocSproductdiscounttypedoc) specified. Whether mandatory or not is dependent on the value of [discountType](#tocSproductdiscounttypedoc)
   * @type {string}
   * @memberof BankingProductDiscount
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the discount
   * @type {string}
   * @memberof BankingProductDiscount
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this discount
   * @type {string}
   * @memberof BankingProductDiscount
   */
  additionalInfoUri?: string;
  /**
   * Eligibility constraints that apply to this discount. Mandatory if ``discountType`` is ``ELIGIBILITY_ONLY``.
   * @type {Array<BankingProductDiscountEligibility>}
   * @memberof BankingProductDiscount
   */
  eligibility?: Array<BankingProductDiscountEligibility>;
}

export const BankingProductDiscountDiscountTypeEnum = {
  Balance: 'BALANCE',
  Deposits: 'DEPOSITS',
  EligibilityOnly: 'ELIGIBILITY_ONLY',
  FeeCap: 'FEE_CAP',
  Payments: 'PAYMENTS',
} as const;

export type BankingProductDiscountDiscountTypeEnum =
  typeof BankingProductDiscountDiscountTypeEnum[keyof typeof BankingProductDiscountDiscountTypeEnum];

/**
 *
 * @export
 * @interface BankingProductDiscountEligibility
 */
export interface BankingProductDiscountEligibility {
  /**
   * The type of the specific eligibility constraint for a discount
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  discountEligibilityType: BankingProductDiscountEligibilityDiscountEligibilityTypeEnum;
  /**
   * Generic field containing additional information relevant to the [discountEligibilityType](#tocSproductdiscounteligibilitydoc) specified. Whether mandatory or not is dependent on the value of [discountEligibilityType](#tocSproductdiscounteligibilitydoc)
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  additionalValue?: string;
  /**
   * Display text providing more information on this eligibility constraint. Whether mandatory or not is dependent on the value of [discountEligibilityType](#tocSproductdiscounteligibilitydoc)
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this eligibility constraint
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  additionalInfoUri?: string;
}

export const BankingProductDiscountEligibilityDiscountEligibilityTypeEnum = {
  Business: 'BUSINESS',
  EmploymentStatus: 'EMPLOYMENT_STATUS',
  Introductory: 'INTRODUCTORY',
  MaxAge: 'MAX_AGE',
  MinAge: 'MIN_AGE',
  MinIncome: 'MIN_INCOME',
  MinTurnover: 'MIN_TURNOVER',
  NaturalPerson: 'NATURAL_PERSON',
  PensionRecipient: 'PENSION_RECIPIENT',
  ResidencyStatus: 'RESIDENCY_STATUS',
  Staff: 'STAFF',
  Student: 'STUDENT',
  Other: 'OTHER',
} as const;

export type BankingProductDiscountEligibilityDiscountEligibilityTypeEnum =
  typeof BankingProductDiscountEligibilityDiscountEligibilityTypeEnum[keyof typeof BankingProductDiscountEligibilityDiscountEligibilityTypeEnum];

/**
 *
 * @export
 * @interface BankingProductEligibility
 */
export interface BankingProductEligibility {
  /**
   * The type of eligibility criteria described.  See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductEligibility
   */
  eligibilityType: BankingProductEligibilityEligibilityTypeEnum;
  /**
   * Generic field containing additional information relevant to the [eligibilityType](#tocSproducteligibilitytypedoc) specified. Whether mandatory or not is dependent on the value of [eligibilityType](#tocSproducteligibilitytypedoc)
   * @type {string}
   * @memberof BankingProductEligibility
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the [eligibility](#tocSproducteligibilitytypedoc) criteria. Mandatory if the field is set to OTHER
   * @type {string}
   * @memberof BankingProductEligibility
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this eligibility criteria
   * @type {string}
   * @memberof BankingProductEligibility
   */
  additionalInfoUri?: string;
}

export const BankingProductEligibilityEligibilityTypeEnum = {
  Business: 'BUSINESS',
  EmploymentStatus: 'EMPLOYMENT_STATUS',
  MaxAge: 'MAX_AGE',
  MinAge: 'MIN_AGE',
  MinIncome: 'MIN_INCOME',
  MinTurnover: 'MIN_TURNOVER',
  NaturalPerson: 'NATURAL_PERSON',
  PensionRecipient: 'PENSION_RECIPIENT',
  ResidencyStatus: 'RESIDENCY_STATUS',
  Staff: 'STAFF',
  Student: 'STUDENT',
  Other: 'OTHER',
} as const;

export type BankingProductEligibilityEligibilityTypeEnum =
  typeof BankingProductEligibilityEligibilityTypeEnum[keyof typeof BankingProductEligibilityEligibilityTypeEnum];

/**
 *
 * @export
 * @interface BankingProductFeature
 */
export interface BankingProductFeature {
  /**
   * The type of feature described
   * @type {string}
   * @memberof BankingProductFeature
   */
  featureType: BankingProductFeatureFeatureTypeEnum;
  /**
   * Generic field containing additional information relevant to the [featureType](#tocSproductfeaturetypedoc) specified. Whether mandatory or not is dependent on the value of the [featureType.](#tocSproductfeaturetypedoc)
   * @type {string}
   * @memberof BankingProductFeature
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the feature. Mandatory if the [feature type](#tocSproductfeaturetypedoc) is set to OTHER
   * @type {string}
   * @memberof BankingProductFeature
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this feature
   * @type {string}
   * @memberof BankingProductFeature
   */
  additionalInfoUri?: string;
}

export const BankingProductFeatureFeatureTypeEnum = {
  AdditionalCards: 'ADDITIONAL_CARDS',
  BalanceTransfers: 'BALANCE_TRANSFERS',
  BillPayment: 'BILL_PAYMENT',
  BonusRewards: 'BONUS_REWARDS',
  CardAccess: 'CARD_ACCESS',
  CashbackOffer: 'CASHBACK_OFFER',
  ComplementaryProductDiscounts: 'COMPLEMENTARY_PRODUCT_DISCOUNTS',
  DigitalBanking: 'DIGITAL_BANKING',
  DigitalWallet: 'DIGITAL_WALLET',
  DonateInterest: 'DONATE_INTEREST',
  ExtraRepayments: 'EXTRA_REPAYMENTS',
  FraudProtection: 'FRAUD_PROTECTION',
  FreeTxns: 'FREE_TXNS',
  FreeTxnsAllowance: 'FREE_TXNS_ALLOWANCE',
  Guarantor: 'GUARANTOR',
  Insurance: 'INSURANCE',
  InstalmentPlan: 'INSTALMENT_PLAN',
  InterestFree: 'INTEREST_FREE',
  InterestFreeTransfers: 'INTEREST_FREE_TRANSFERS',
  LoyaltyProgram: 'LOYALTY_PROGRAM',
  Notifications: 'NOTIFICATIONS',
  NppEnabled: 'NPP_ENABLED',
  NppPayid: 'NPP_PAYID',
  Offset: 'OFFSET',
  Other: 'OTHER',
  Overdraft: 'OVERDRAFT',
  Redraw: 'REDRAW',
  RelationshipManagement: 'RELATIONSHIP_MANAGEMENT',
  UnlimitedTxns: 'UNLIMITED_TXNS',
} as const;

export type BankingProductFeatureFeatureTypeEnum =
  typeof BankingProductFeatureFeatureTypeEnum[keyof typeof BankingProductFeatureFeatureTypeEnum];

/**
 *
 * @export
 * @interface BankingProductFee
 */
export interface BankingProductFee {
  /**
   * Name of the fee
   * @type {string}
   * @memberof BankingProductFee
   */
  name: string;
  /**
   * The type of fee
   * @type {string}
   * @memberof BankingProductFee
   */
  feeType: BankingProductFeeFeeTypeEnum;
  /**
   * The amount charged for the fee. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied
   * @type {string}
   * @memberof BankingProductFee
   */
  amount?: string;
  /**
   * A fee rate calculated based on a proportion of the balance. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied.
   * @type {string}
   * @memberof BankingProductFee
   */
  balanceRate?: string;
  /**
   * A fee rate calculated based on a proportion of a transaction. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied
   * @type {string}
   * @memberof BankingProductFee
   */
  transactionRate?: string;
  /**
   * A fee rate calculated based on a proportion of the calculated interest accrued on the account. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied
   * @type {string}
   * @memberof BankingProductFee
   */
  accruedRate?: string;
  /**
   * The indicative frequency with which the fee is calculated on the account. Only applies if balanceRate or accruedRate is also present. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductFee
   */
  accrualFrequency?: string;
  /**
   * The currency the fee will be charged in. Assumes AUD if absent
   * @type {string}
   * @memberof BankingProductFee
   */
  currency?: string;
  /**
   * Generic field containing additional information relevant to the [feeType](#tocSproductfeetypedoc) specified. Whether mandatory or not is dependent on the value of [feeType](#tocSproductfeetypedoc)
   * @type {string}
   * @memberof BankingProductFee
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the fee
   * @type {string}
   * @memberof BankingProductFee
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this fee
   * @type {string}
   * @memberof BankingProductFee
   */
  additionalInfoUri?: string;
  /**
   * An optional list of discounts to this fee that may be available
   * @type {Array<BankingProductDiscount>}
   * @memberof BankingProductFee
   */
  discounts?: Array<BankingProductDiscount>;
}

export const BankingProductFeeFeeTypeEnum = {
  Deposit: 'DEPOSIT',
  Event: 'EVENT',
  Exit: 'EXIT',
  Payment: 'PAYMENT',
  Periodic: 'PERIODIC',
  Purchase: 'PURCHASE',
  Transaction: 'TRANSACTION',
  Upfront: 'UPFRONT',
  Variable: 'VARIABLE',
  Withdrawal: 'WITHDRAWAL',
} as const;

export type BankingProductFeeFeeTypeEnum =
  typeof BankingProductFeeFeeTypeEnum[keyof typeof BankingProductFeeFeeTypeEnum];

/**
 *
 * @export
 * @interface BankingProductLendingRateV2
 */
export interface BankingProductLendingRateV2 {
  /**
   * The type of rate (fixed, variable, etc). See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  lendingRateType: BankingProductLendingRateV2LendingRateTypeEnum;
  /**
   * The rate to be applied
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  rate: string;
  /**
   * A comparison rate equivalent for this rate
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  comparisonRate?: string;
  /**
   * The period after which the rate is applied to the balance to calculate the amount due for the period. Calculation of the amount is often daily (as balances may change) but accumulated until the total amount is \'applied\' to the account (see applicationFrequency). Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  calculationFrequency?: string;
  /**
   * The period after which the calculated amount(s) (see calculationFrequency) are \'applied\' (i.e. debited or credited) to the account. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  applicationFrequency?: string;
  /**
   * When loan payments are due to be paid within each period. The investment benefit of earlier payments affect the rate that can be offered
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  interestPaymentDue?: BankingProductLendingRateV2InterestPaymentDueEnum;
  /**
   * Options in place for repayments. If absent, the lending rate is applicable to all repayment types
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  repaymentType?: BankingProductLendingRateV2RepaymentTypeEnum;
  /**
   * The reason for taking out the loan. If absent, the lending rate is applicable to all loan purposes
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  loanPurpose?: BankingProductLendingRateV2LoanPurposeEnum;
  /**
   * Rate tiers applicable for this rate
   * @type {Array<BankingProductRateTierV3>}
   * @memberof BankingProductLendingRateV2
   */
  tiers?: Array<BankingProductRateTierV3>;
  /**
   * Generic field containing additional information relevant to the [lendingRateType](#tocSproductlendingratetypedoc) specified. Whether mandatory or not is dependent on the value of [lendingRateType](#tocSproductlendingratetypedoc)
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the rate.
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this rate
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  additionalInfoUri?: string;
}

export const BankingProductLendingRateV2LendingRateTypeEnum = {
  BundleDiscountFixed: 'BUNDLE_DISCOUNT_FIXED',
  BundleDiscountVariable: 'BUNDLE_DISCOUNT_VARIABLE',
  CashAdvance: 'CASH_ADVANCE',
  Discount: 'DISCOUNT',
  Floating: 'FLOATING',
  Introductory: 'INTRODUCTORY',
  MarketLinked: 'MARKET_LINKED',
  Penalty: 'PENALTY',
  Purchase: 'PURCHASE',
  Variable: 'VARIABLE',
  Fixed: 'FIXED',
} as const;

export type BankingProductLendingRateV2LendingRateTypeEnum =
  typeof BankingProductLendingRateV2LendingRateTypeEnum[keyof typeof BankingProductLendingRateV2LendingRateTypeEnum];
export const BankingProductLendingRateV2InterestPaymentDueEnum = {
  Advance: 'IN_ADVANCE',
  Arrears: 'IN_ARREARS',
} as const;

export type BankingProductLendingRateV2InterestPaymentDueEnum =
  typeof BankingProductLendingRateV2InterestPaymentDueEnum[keyof typeof BankingProductLendingRateV2InterestPaymentDueEnum];
export const BankingProductLendingRateV2RepaymentTypeEnum = {
  InterestOnly: 'INTEREST_ONLY',
  PrincipalAndInterest: 'PRINCIPAL_AND_INTEREST',
} as const;

export type BankingProductLendingRateV2RepaymentTypeEnum =
  typeof BankingProductLendingRateV2RepaymentTypeEnum[keyof typeof BankingProductLendingRateV2RepaymentTypeEnum];
export const BankingProductLendingRateV2LoanPurposeEnum = {
  OwnerOccupied: 'OWNER_OCCUPIED',
  Investment: 'INVESTMENT',
} as const;

export type BankingProductLendingRateV2LoanPurposeEnum =
  typeof BankingProductLendingRateV2LoanPurposeEnum[keyof typeof BankingProductLendingRateV2LoanPurposeEnum];

/**
 *
 * @export
 * @interface BankingProductList
 */
export interface BankingProductList {
  /**
   *
   * @type {BankingProductListData}
   * @memberof BankingProductList
   */
  data: BankingProductListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingProductList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingProductList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingProductListData
 */
export interface BankingProductListData {
  /**
   *
   * @type {Array<BankingProductDetail>}
   * @memberof BankingProductListData
   */
  products: Array<BankingProductDetail>;
}
/**
 * Defines a condition for the applicability of a tiered rate
 * @export
 * @interface BankingProductRateCondition
 */
export interface BankingProductRateCondition {
  /**
   * Display text providing more information on the condition
   * @type {string}
   * @memberof BankingProductRateCondition
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this condition
   * @type {string}
   * @memberof BankingProductRateCondition
   */
  additionalInfoUri?: string;
}
/**
 * Defines the criteria and conditions for which a rate applies
 * @export
 * @interface BankingProductRateTierV3
 */
export interface BankingProductRateTierV3 {
  /**
   * A display name for the tier
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  name: string;
  /**
   * The unit of measure that applies to the tierValueMinimum and tierValueMaximum values e.g. a **DOLLAR** amount. **PERCENT** (in the case of loan-to-value ratio or LVR). Tier term period representing a discrete number of **MONTH**\'s or **DAY**\'s (in the case of term deposit tiers)
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  unitOfMeasure: BankingProductRateTierV3UnitOfMeasureEnum;
  /**
   * The number of tierUnitOfMeasure units that form the lower bound of the tier. The tier should be inclusive of this value
   * @type {number}
   * @memberof BankingProductRateTierV3
   */
  minimumValue: number;
  /**
   * The number of tierUnitOfMeasure units that form the upper bound of the tier or band. For a tier with a discrete value (as opposed to a range of values e.g. 1 month) this must be the same as tierValueMinimum. Where this is the same as the tierValueMinimum value of the next-higher tier the referenced tier should be exclusive of this value. For example a term deposit of 2 months falls into the upper tier of the following tiers: (1 - 2 months, 2 - 3 months). If absent the tier\'s range has no upper bound.
   * @type {number}
   * @memberof BankingProductRateTierV3
   */
  maximumValue?: number;
  /**
   * The method used to calculate the amount to be applied using one or more tiers. A single rate may be applied to the entire balance or each applicable tier rate is applied to the portion of the balance that falls into that tier (referred to as \'bands\' or \'steps\')
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  rateApplicationMethod?: BankingProductRateTierV3RateApplicationMethodEnum;
  /**
   *
   * @type {BankingProductRateCondition}
   * @memberof BankingProductRateTierV3
   */
  applicabilityConditions?: BankingProductRateCondition;
  /**
   * Display text providing more information on the rate tier.
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this rate tier
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  additionalInfoUri?: string;
}

export const BankingProductRateTierV3UnitOfMeasureEnum = {
  Dollar: 'DOLLAR',
  Percent: 'PERCENT',
  Day: 'DAY',
  Month: 'MONTH',
} as const;

export type BankingProductRateTierV3UnitOfMeasureEnum =
  typeof BankingProductRateTierV3UnitOfMeasureEnum[keyof typeof BankingProductRateTierV3UnitOfMeasureEnum];
export const BankingProductRateTierV3RateApplicationMethodEnum = {
  PerTier: 'PER_TIER',
  WholeBalance: 'WHOLE_BALANCE',
} as const;

export type BankingProductRateTierV3RateApplicationMethodEnum =
  typeof BankingProductRateTierV3RateApplicationMethodEnum[keyof typeof BankingProductRateTierV3RateApplicationMethodEnum];

/**
 *
 * @export
 * @interface BankingProductV3
 */
export interface BankingProductV3 {
  /**
   * A data holder specific unique identifier for this product. This identifier must be unique to a product but does not otherwise need to adhere to ID permanence guidelines.
   * @type {string}
   * @memberof BankingProductV3
   */
  productId: string;
  /**
   * The date and time from which this product is effective (ie. is available for origination).  Used to enable the articulation of products to the regime before they are available for customers to originate
   * @type {string}
   * @memberof BankingProductV3
   */
  effectiveFrom?: string;
  /**
   * The date and time at which this product will be retired and will no longer be offered.  Used to enable the managed deprecation of products
   * @type {string}
   * @memberof BankingProductV3
   */
  effectiveTo?: string;
  /**
   * The last date and time that the information for this product was changed (or the creation date for the product if it has never been altered)
   * @type {string}
   * @memberof BankingProductV3
   */
  lastUpdated: string;
  /**
   * The id of data holder
   * @type {string}
   * @memberof BankingProductV3
   */
  dataHolderId: string;
  /**
   * The brand name of data holder
   * @type {string}
   * @memberof BankingProductV3
   */
  dataHolderBrandName?: string;
  /**
   *
   * @type {BankingProductCategory}
   * @memberof BankingProductV3
   */
  productCategory: BankingProductCategory;
  /**
   * The display name of the product
   * @type {string}
   * @memberof BankingProductV3
   */
  name: string;
  /**
   * A description of the product
   * @type {string}
   * @memberof BankingProductV3
   */
  description: string;
  /**
   * A label of the brand for the product. Able to be used for filtering. For data holders with single brands this value is still required
   * @type {string}
   * @memberof BankingProductV3
   */
  brand: string;
  /**
   * An optional display name of the brand
   * @type {string}
   * @memberof BankingProductV3
   */
  brandName?: string;
  /**
   * A link to an application web page where this product can be applied for.
   * @type {string}
   * @memberof BankingProductV3
   */
  applicationUri?: string;
  /**
   * Indicates whether the product is specifically tailored to a circumstance.  In this case fees and prices are significantly negotiated depending on context. While all products are open to a degree of tailoring this flag indicates that tailoring is expected and thus that the provision of specific fees and rates is not applicable
   * @type {boolean}
   * @memberof BankingProductV3
   */
  isTailored: boolean;
  /**
   *
   * @type {BankingProductV3AdditionalInformation}
   * @memberof BankingProductV3
   */
  additionalInformation?: BankingProductV3AdditionalInformation;
  /**
   * An array of card art images
   * @type {Array<BankingProductV3CardArt>}
   * @memberof BankingProductV3
   */
  cardArt?: Array<BankingProductV3CardArt>;
}
/**
 * Object that contains links to additional information on specific topics
 * @export
 * @interface BankingProductV3AdditionalInformation
 */
export interface BankingProductV3AdditionalInformation {
  /**
   * General overview of the product
   * @type {string}
   * @memberof BankingProductV3AdditionalInformation
   */
  overviewUri?: string;
  /**
   * Terms and conditions for the product
   * @type {string}
   * @memberof BankingProductV3AdditionalInformation
   */
  termsUri?: string;
  /**
   * Eligibility rules and criteria for the product
   * @type {string}
   * @memberof BankingProductV3AdditionalInformation
   */
  eligibilityUri?: string;
  /**
   * Description of fees, pricing, discounts, exemptions and bonuses for the product
   * @type {string}
   * @memberof BankingProductV3AdditionalInformation
   */
  feesAndPricingUri?: string;
  /**
   * Description of a bundle that this product can be part of
   * @type {string}
   * @memberof BankingProductV3AdditionalInformation
   */
  bundleUri?: string;
  /**
   * An array of additional general overviews for the product or features of the product, if applicable. To be treated as secondary documents to the `overviewUri`. Only to be used if there is a primary `overviewUri`.
   * @type {Array<BankingProductAdditionalInformationV2AdditionalInformationUris>}
   * @memberof BankingProductV3AdditionalInformation
   */
  additionalOverviewUris?: Array<BankingProductAdditionalInformationV2AdditionalInformationUris>;
  /**
   * An array of additional terms and conditions for the product, if applicable. To be treated as secondary documents to the `termsUri`. Only to be used if there is a primary `termsUri`.
   * @type {Array<BankingProductAdditionalInformationV2AdditionalInformationUris>}
   * @memberof BankingProductV3AdditionalInformation
   */
  additionalTermsUris?: Array<BankingProductAdditionalInformationV2AdditionalInformationUris>;
  /**
   * An array of additional eligibility rules and criteria for the product, if applicable. To be treated as secondary documents to the `eligibilityUri`. Only to be used if there is a primary `eligibilityUri`.
   * @type {Array<BankingProductAdditionalInformationV2AdditionalInformationUris>}
   * @memberof BankingProductV3AdditionalInformation
   */
  additionalEligibilityUris?: Array<BankingProductAdditionalInformationV2AdditionalInformationUris>;
  /**
   * An array of additional fees, pricing, discounts, exemptions and bonuses for the product, if applicable. To be treated as secondary documents to the `feesAndPricingUri`. Only to be used if there is a primary `feesAndPricingUri`.
   * @type {Array<BankingProductAdditionalInformationV2AdditionalInformationUris>}
   * @memberof BankingProductV3AdditionalInformation
   */
  additionalFeesAndPricingUris?: Array<BankingProductAdditionalInformationV2AdditionalInformationUris>;
  /**
   * An array of additional bundles for the product, if applicable. To be treated as secondary documents to the `bundleUri`. Only to be used if there is a primary `bundleUri`.
   * @type {Array<BankingProductAdditionalInformationV2AdditionalInformationUris>}
   * @memberof BankingProductV3AdditionalInformation
   */
  additionalBundleUris?: Array<BankingProductAdditionalInformationV2AdditionalInformationUris>;
}
/**
 *
 * @export
 * @interface BankingProductV3CardArt
 */
export interface BankingProductV3CardArt {
  /**
   * Display label for the specific image
   * @type {string}
   * @memberof BankingProductV3CardArt
   */
  title?: string;
  /**
   * URI reference to a PNG, JPG or GIF image with proportions defined by ISO 7810 ID-1 and width no greater than 512 pixels. The URI reference may be a link or url-encoded data URI [RFC 2397](https://tools.ietf.org/html/rfc2397)
   * @type {string}
   * @memberof BankingProductV3CardArt
   */
  imageUri: string;
}
/**
 *
 * @export
 * @interface BankingScheduledPayment
 */
export interface BankingScheduledPayment {
  /**
   * A unique ID of the scheduled payment adhering to the standards for ID permanence
   * @type {string}
   * @memberof BankingScheduledPayment
   */
  scheduledPaymentId: string;
  /**
   * The short display name of the payee as provided by the customer
   * @type {string}
   * @memberof BankingScheduledPayment
   */
  nickname?: string;
  /**
   * The reference for the transaction that will be used by the originating institution for the purposes of constructing a statement narrative on the payer\'s account. Empty string if no data provided
   * @type {string}
   * @memberof BankingScheduledPayment
   */
  payerReference: string;
  /**
   * The reference for the transaction that will be provided by the originating institution. Empty string if no data provided
   * @type {string}
   * @memberof BankingScheduledPayment
   */
  payeeReference: string;
  /**
   * Indicates whether the schedule is currently active. The value SKIP is equivalent to ACTIVE except that the customer has requested the next normal occurrence to be skipped.
   * @type {string}
   * @memberof BankingScheduledPayment
   */
  status: BankingScheduledPaymentStatusEnum;
  /**
   *
   * @type {BankingScheduledPaymentFrom}
   * @memberof BankingScheduledPayment
   */
  from: BankingScheduledPaymentFrom;
  /**
   *
   * @type {Array<BankingScheduledPaymentSet>}
   * @memberof BankingScheduledPayment
   */
  paymentSet: Array<BankingScheduledPaymentSet>;
  /**
   *
   * @type {BankingScheduledPaymentRecurrence}
   * @memberof BankingScheduledPayment
   */
  recurrence: BankingScheduledPaymentRecurrence;
  /**
   *
   * @type {Adatree}
   * @memberof BankingScheduledPayment
   */
  adatree: Adatree;
}

export const BankingScheduledPaymentStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Skip: 'SKIP',
} as const;

export type BankingScheduledPaymentStatusEnum =
  typeof BankingScheduledPaymentStatusEnum[keyof typeof BankingScheduledPaymentStatusEnum];

/**
 * Object containing details of the source of the payment. Currently only specifies an account ID but provided as an object to facilitate future extensibility and consistency with the to object
 * @export
 * @interface BankingScheduledPaymentFrom
 */
export interface BankingScheduledPaymentFrom {
  /**
   * ID of the account that is the source of funds for the payment
   * @type {string}
   * @memberof BankingScheduledPaymentFrom
   */
  accountId: string;
}
/**
 *
 * @export
 * @interface BankingScheduledPaymentInterval
 */
export interface BankingScheduledPaymentInterval {
  /**
   * An interval for the payment. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations)  (excludes recurrence syntax) with components less than a day in length ignored. This duration defines the period between payments starting with nextPaymentDate
   * @type {string}
   * @memberof BankingScheduledPaymentInterval
   */
  interval: string;
  /**
   * Uses an interval to define the ordinal day within the interval defined by the interval field on which the payment occurs. If the resulting duration is 0 days in length or larger than the number of days in the interval then the payment will occur on the last day of the interval. A duration of 1 day indicates the first day of the interval. If absent the assumed value is P1D. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax) with components less than a day in length ignored. The first day of a week is considered to be Monday.
   * @type {string}
   * @memberof BankingScheduledPaymentInterval
   */
  dayInInterval?: string;
}
/**
 * Object containing the detail of the schedule for the payment
 * @export
 * @interface BankingScheduledPaymentRecurrence
 */
export interface BankingScheduledPaymentRecurrence {
  /**
   * The date of the next payment under the recurrence schedule
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrence
   */
  nextPaymentDate?: string;
  /**
   * The type of recurrence used to define the schedule
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrence
   */
  recurrenceUType: BankingScheduledPaymentRecurrenceRecurrenceUTypeEnum;
  /**
   *
   * @type {BankingScheduledPaymentRecurrenceOnceOff}
   * @memberof BankingScheduledPaymentRecurrence
   */
  onceOff?: BankingScheduledPaymentRecurrenceOnceOff;
  /**
   *
   * @type {BankingScheduledPaymentRecurrenceIntervalSchedule}
   * @memberof BankingScheduledPaymentRecurrence
   */
  intervalSchedule?: BankingScheduledPaymentRecurrenceIntervalSchedule;
  /**
   *
   * @type {BankingScheduledPaymentRecurrenceLastWeekday}
   * @memberof BankingScheduledPaymentRecurrence
   */
  lastWeekDay?: BankingScheduledPaymentRecurrenceLastWeekday;
  /**
   *
   * @type {BankingScheduledPaymentRecurrenceEventBased}
   * @memberof BankingScheduledPaymentRecurrence
   */
  eventBased?: BankingScheduledPaymentRecurrenceEventBased;
}

export const BankingScheduledPaymentRecurrenceRecurrenceUTypeEnum = {
  OnceOff: 'onceOff',
  IntervalSchedule: 'intervalSchedule',
  LastWeekDay: 'lastWeekDay',
  EventBased: 'eventBased',
} as const;

export type BankingScheduledPaymentRecurrenceRecurrenceUTypeEnum =
  typeof BankingScheduledPaymentRecurrenceRecurrenceUTypeEnum[keyof typeof BankingScheduledPaymentRecurrenceRecurrenceUTypeEnum];

/**
 * Indicates that the schedule of payments is defined according to an external event that cannot be predetermined. Mandatory if recurrenceUType is set to eventBased
 * @export
 * @interface BankingScheduledPaymentRecurrenceEventBased
 */
export interface BankingScheduledPaymentRecurrenceEventBased {
  /**
   * Description of the event and conditions that will result in the payment. Expected to be formatted for display to a customer
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceEventBased
   */
  description: string;
}
/**
 * Indicates that the schedule of payments is defined by a series of intervals. Mandatory if recurrenceUType is set to intervalSchedule
 * @export
 * @interface BankingScheduledPaymentRecurrenceIntervalSchedule
 */
export interface BankingScheduledPaymentRecurrenceIntervalSchedule {
  /**
   * The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceIntervalSchedule
   */
  finalPaymentDate?: string;
  /**
   * Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value, If neither field is present the payments will continue indefinitely
   * @type {number}
   * @memberof BankingScheduledPaymentRecurrenceIntervalSchedule
   */
  paymentsRemaining?: number;
  /**
   * Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceIntervalSchedule
   */
  nonBusinessDayTreatment?: BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentEnum;
  /**
   * An array of interval objects defining the payment schedule.  Each entry in the array is additive, in that it adds payments to the overall payment schedule.  If multiple intervals result in a payment on the same day then only one payment will be made. Must have at least one entry
   * @type {Array<BankingScheduledPaymentInterval>}
   * @memberof BankingScheduledPaymentRecurrenceIntervalSchedule
   */
  intervals: Array<BankingScheduledPaymentInterval>;
}

export const BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentEnum = {
  After: 'AFTER',
  Before: 'BEFORE',
  On: 'ON',
  Only: 'ONLY',
} as const;

export type BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentEnum =
  typeof BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentEnum[keyof typeof BankingScheduledPaymentRecurrenceIntervalScheduleNonBusinessDayTreatmentEnum];

/**
 * Indicates that the schedule of payments is defined according to the last occurrence of a specific weekday in an interval. Mandatory if recurrenceUType is set to lastWeekDay
 * @export
 * @interface BankingScheduledPaymentRecurrenceLastWeekday
 */
export interface BankingScheduledPaymentRecurrenceLastWeekday {
  /**
   * The limit date after which no more payments should be made using this schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceLastWeekday
   */
  finalPaymentDate?: string;
  /**
   * Indicates the number of payments remaining in the schedule. If both finalPaymentDate and paymentsRemaining are present then payments will stop according to the most constraining value. If neither field is present the payments will continue indefinitely
   * @type {number}
   * @memberof BankingScheduledPaymentRecurrenceLastWeekday
   */
  paymentsRemaining?: number;
  /**
   * The interval for the payment. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax) with components less than a day in length ignored. This duration defines the period between payments starting with nextPaymentDate
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceLastWeekday
   */
  interval: string;
  /**
   * The weekDay specified. The payment will occur on the last occurrence of this weekday in the interval.
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceLastWeekday
   */
  lastWeekDay: BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDayEnum;
  /**
   * Enumerated field giving the treatment where a scheduled payment date is not a business day. If absent assumed to be ON.<br/>**AFTER** - If a scheduled payment date is a non-business day the payment will be made on the first business day after the scheduled payment date.<br/>**BEFORE** - If a scheduled payment date is a non-business day the payment will be made on the first business day before the scheduled payment date.<br/>**ON** - If a scheduled payment date is a non-business day the payment will be made on that day regardless.<br/>**ONLY** - Payments only occur on business days. If a scheduled payment date is a non-business day the payment will be ignored
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceLastWeekday
   */
  nonBusinessDayTreatment?: BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentEnum;
}

export const BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDayEnum = {
  Mon: 'MON',
  Tue: 'TUE',
  Wed: 'WED',
  Thu: 'THU',
  Fri: 'FRI',
  Sat: 'SAT',
  Sun: 'SUN',
} as const;

export type BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDayEnum =
  typeof BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDayEnum[keyof typeof BankingScheduledPaymentRecurrenceLastWeekdayLastWeekDayEnum];
export const BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentEnum = {
  After: 'AFTER',
  Before: 'BEFORE',
  On: 'ON',
  Only: 'ONLY',
} as const;

export type BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentEnum =
  typeof BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentEnum[keyof typeof BankingScheduledPaymentRecurrenceLastWeekdayNonBusinessDayTreatmentEnum];

/**
 * Indicates that the payment is a once off payment on a specific future date. Mandatory if recurrenceUType is set to onceOff
 * @export
 * @interface BankingScheduledPaymentRecurrenceOnceOff
 */
export interface BankingScheduledPaymentRecurrenceOnceOff {
  /**
   * The scheduled date for the once off payment
   * @type {string}
   * @memberof BankingScheduledPaymentRecurrenceOnceOff
   */
  paymentDate: string;
}
/**
 * The set of payment amounts and destination accounts for this payment accommodating multi-part payments. A single entry indicates a simple payment with one destination account. Must have at least one entry
 * @export
 * @interface BankingScheduledPaymentSet
 */
export interface BankingScheduledPaymentSet {
  /**
   *
   * @type {BankingScheduledPaymentTo}
   * @memberof BankingScheduledPaymentSet
   */
  to: BankingScheduledPaymentTo;
  /**
   * Flag indicating whether the amount of the payment is calculated based on the context of the event. For instance a payment to reduce the balance of a credit card to zero. If absent then false is assumed
   * @type {boolean}
   * @memberof BankingScheduledPaymentSet
   */
  isAmountCalculated?: boolean;
  /**
   * The amount of the next payment if known. Mandatory unless the isAmountCalculated field is set to true. Must be zero or positive if present
   * @type {string}
   * @memberof BankingScheduledPaymentSet
   */
  amount?: string;
  /**
   * The currency for the payment. AUD assumed if not present
   * @type {string}
   * @memberof BankingScheduledPaymentSet
   */
  currency?: string;
}
/**
 * Object containing details of the destination of the payment. Used to specify a variety of payment destination types
 * @export
 * @interface BankingScheduledPaymentTo
 */
export interface BankingScheduledPaymentTo {
  /**
   * The type of object provided that specifies the destination of the funds for the payment.
   * @type {string}
   * @memberof BankingScheduledPaymentTo
   */
  toUType: BankingScheduledPaymentToToUTypeEnum;
  /**
   * Present if toUType is set to accountId. Indicates that the payment is to another account that is accessible under the current consent
   * @type {string}
   * @memberof BankingScheduledPaymentTo
   */
  accountId?: string;
  /**
   * Present if toUType is set to payeeId. Indicates that the payment is to registered payee that can be accessed using the payee end point. If the Bank Payees scope has not been consented to then a payeeId should not be provided and the full payee details should be provided instead
   * @type {string}
   * @memberof BankingScheduledPaymentTo
   */
  payeeId?: string;
  /**
   *
   * @type {BankingDomesticPayee}
   * @memberof BankingScheduledPaymentTo
   */
  domestic?: BankingDomesticPayee;
  /**
   *
   * @type {BankingBillerPayee}
   * @memberof BankingScheduledPaymentTo
   */
  biller?: BankingBillerPayee;
  /**
   *
   * @type {BankingInternationalPayee}
   * @memberof BankingScheduledPaymentTo
   */
  international?: BankingInternationalPayee;
}

export const BankingScheduledPaymentToToUTypeEnum = {
  AccountId: 'accountId',
  PayeeId: 'payeeId',
  Domestic: 'domestic',
  Biller: 'biller',
  International: 'international',
} as const;

export type BankingScheduledPaymentToToUTypeEnum =
  typeof BankingScheduledPaymentToToUTypeEnum[keyof typeof BankingScheduledPaymentToToUTypeEnum];

/**
 *
 * @export
 * @interface BankingScheduledPaymentsList
 */
export interface BankingScheduledPaymentsList {
  /**
   *
   * @type {BankingScheduledPaymentsListData}
   * @memberof BankingScheduledPaymentsList
   */
  data: BankingScheduledPaymentsListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingScheduledPaymentsList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingScheduledPaymentsList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingScheduledPaymentsListData
 */
export interface BankingScheduledPaymentsListData {
  /**
   * The list of scheduled payments to return
   * @type {Array<BankingScheduledPayment>}
   * @memberof BankingScheduledPaymentsListData
   */
  scheduledPayments: Array<BankingScheduledPayment>;
}
/**
 *
 * @export
 * @interface BankingTermDepositAccount
 */
export interface BankingTermDepositAccount {
  /**
   * The lodgement date of the original deposit
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  lodgementDate: string;
  /**
   * Maturity date for the term deposit
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityDate: string;
  /**
   * Amount to be paid upon maturity. If absent it implies the amount to paid is variable and cannot currently be calculated
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityAmount?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityCurrency?: string;
  /**
   * Current instructions on action to be taken at maturity. This includes default actions that may be specified in the terms and conditions for the product e.g. roll-over to the same term and frequency of interest payments
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityInstructions: BankingTermDepositAccountMaturityInstructionsEnum;
}

export const BankingTermDepositAccountMaturityInstructionsEnum = {
  RolledOver: 'ROLLED_OVER',
  PaidOutAtMaturity: 'PAID_OUT_AT_MATURITY',
  HoldOnMaturity: 'HOLD_ON_MATURITY',
} as const;

export type BankingTermDepositAccountMaturityInstructionsEnum =
  typeof BankingTermDepositAccountMaturityInstructionsEnum[keyof typeof BankingTermDepositAccountMaturityInstructionsEnum];

/**
 *
 * @export
 * @interface BankingTransaction
 */
export interface BankingTransaction {
  /**
   * ID of the account for which transactions are provided
   * @type {string}
   * @memberof BankingTransaction
   */
  accountId: string;
  /**
   * A unique ID of the transaction adhering to the standards for ID permanence.  This is mandatory (through hashing if necessary) unless there are specific and justifiable technical reasons why a transaction cannot be uniquely identified for a particular account type
   * @type {string}
   * @memberof BankingTransaction
   */
  transactionId?: string;
  /**
   * True if extended information is available using the transaction detail end point. False if extended data is not available
   * @type {boolean}
   * @memberof BankingTransaction
   */
  isDetailAvailable: boolean;
  /**
   * The type of the transaction
   * @type {string}
   * @memberof BankingTransaction
   */
  type: BankingTransactionTypeEnum;
  /**
   * Status of the transaction whether pending or posted. Note that there is currently no provision in the standards to guarantee the ability to correlate a pending transaction with an associated posted transaction
   * @type {string}
   * @memberof BankingTransaction
   */
  status: BankingTransactionStatusEnum;
  /**
   * The transaction description as applied by the financial institution
   * @type {string}
   * @memberof BankingTransaction
   */
  description: string;
  /**
   * The time the transaction was posted. This field is Mandatory if the transaction has status POSTED.  This is the time that appears on a standard statement. DateTimeString can be found at https://consumerdatastandardsaustralia.github.io/standards/#common-field-types
   * @type {string}
   * @memberof BankingTransaction
   */
  postingDateTime?: string;
  /**
   * Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry
   * @type {string}
   * @memberof BankingTransaction
   */
  valueDateTime?: string;
  /**
   * The time the transaction was executed by the originating customer, if available
   * @type {string}
   * @memberof BankingTransaction
   */
  executionDateTime?: string;
  /**
   * The value of the transaction. Negative values mean money was outgoing from the account
   * @type {string}
   * @memberof BankingTransaction
   */
  amount: string;
  /**
   * The currency for the transaction amount. AUD assumed if not present
   * @type {string}
   * @memberof BankingTransaction
   */
  currency?: string;
  /**
   * The reference for the transaction provided by the originating institution. Empty string if no data provided
   * @type {string}
   * @memberof BankingTransaction
   */
  reference: string;
  /**
   * Name of the merchant for an outgoing payment to a merchant
   * @type {string}
   * @memberof BankingTransaction
   */
  merchantName?: string;
  /**
   * The merchant category code (or MCC) for an outgoing payment to a merchant
   * @type {string}
   * @memberof BankingTransaction
   */
  merchantCategoryCode?: string;
  /**
   * BPAY Biller Code for the transaction (if available)
   * @type {string}
   * @memberof BankingTransaction
   */
  billerCode?: string;
  /**
   * Name of the BPAY biller for the transaction (if available)
   * @type {string}
   * @memberof BankingTransaction
   */
  billerName?: string;
  /**
   * BPAY CRN for the transaction (if available)
   * @type {string}
   * @memberof BankingTransaction
   */
  crn?: string;
  /**
   * 6 Digit APCA number for the initiating institution. The field is fixed-width and padded with leading zeros if applicable.
   * @type {string}
   * @memberof BankingTransaction
   */
  apcaNumber?: string;
  /**
   *
   * @type {BankingTransactionExtendedData}
   * @memberof BankingTransaction
   */
  extendedData?: BankingTransactionExtendedData;
  /**
   *
   * @type {BankingTransactionAdatree}
   * @memberof BankingTransaction
   */
  adatree?: BankingTransactionAdatree;
}

export const BankingTransactionTypeEnum = {
  DirectDebit: 'DIRECT_DEBIT',
  Fee: 'FEE',
  InterestCharged: 'INTEREST_CHARGED',
  InterestPaid: 'INTEREST_PAID',
  Payment: 'PAYMENT',
  TransferOutgoing: 'TRANSFER_OUTGOING',
  TransferIncoming: 'TRANSFER_INCOMING',
  Other: 'OTHER',
} as const;

export type BankingTransactionTypeEnum = typeof BankingTransactionTypeEnum[keyof typeof BankingTransactionTypeEnum];
export const BankingTransactionStatusEnum = {
  Pending: 'PENDING',
  Posted: 'POSTED',
} as const;

export type BankingTransactionStatusEnum =
  typeof BankingTransactionStatusEnum[keyof typeof BankingTransactionStatusEnum];

/**
 * Extra data and metadata provided by Adatree for transactions
 * @export
 * @interface BankingTransactionAdatree
 */
export interface BankingTransactionAdatree {
  /**
   * Consent Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  consentId: string;
  /**
   * Consumer Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  consumerId: string;
  /**
   * CDR Arrangement for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  cdrArrangementId: string;
  /**
   * Data Holder Brand Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  dataHolderBrandId: string;
  /**
   * Use Case Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  useCaseId: string;
  /**
   * resource ID generated by Adatree; the ADHs do not always provide a transaction Id so we generate an id to uniquely identify a transaction
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  resourceId: string;
}
/**
 *
 * @export
 * @interface BankingTransactionAdatreeAllOf
 */
export interface BankingTransactionAdatreeAllOf {
  /**
   * resource ID generated by Adatree; the ADHs do not always provide a transaction Id so we generate an id to uniquely identify a transaction
   * @type {string}
   * @memberof BankingTransactionAdatreeAllOf
   */
  resourceId?: string;
}
/**
 *
 * @export
 * @interface BankingTransactionExtendedData
 */
export interface BankingTransactionExtendedData {
  /**
   * Label of the originating payer. Mandatory for inbound payment
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  payer?: string;
  /**
   * Label of the target PayID.  Mandatory for an outbound payment. The name assigned to the BSB/Account Number or PayID (by the owner of the PayID)
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  payee?: string;
  /**
   * Optional extended data provided specific to transaction originated via NPP
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  extensionUType?: BankingTransactionExtendedDataExtensionUTypeEnum;
  /**
   *
   * @type {BankingTransactionExtendedDataX2p101Payload}
   * @memberof BankingTransactionExtendedData
   */
  x2p101Payload?: BankingTransactionExtendedDataX2p101Payload;
  /**
   * Identifier of the applicable overlay service. Valid values are: X2P1.01
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  service: BankingTransactionExtendedDataServiceEnum;
}

export const BankingTransactionExtendedDataExtensionUTypeEnum = {
  X2p101Payload: 'x2p101Payload',
} as const;

export type BankingTransactionExtendedDataExtensionUTypeEnum =
  typeof BankingTransactionExtendedDataExtensionUTypeEnum[keyof typeof BankingTransactionExtendedDataExtensionUTypeEnum];
export const BankingTransactionExtendedDataServiceEnum = {
  X2P101: 'X2P1.01',
} as const;

export type BankingTransactionExtendedDataServiceEnum =
  typeof BankingTransactionExtendedDataServiceEnum[keyof typeof BankingTransactionExtendedDataServiceEnum];

/**
 *
 * @export
 * @interface BankingTransactionExtendedDataX2p101Payload
 */
export interface BankingTransactionExtendedDataX2p101Payload {
  /**
   * An extended string description. Only present if specified by the extensionUType field
   * @type {string}
   * @memberof BankingTransactionExtendedDataX2p101Payload
   */
  extendedDescription: string;
  /**
   * An end to end ID for the payment created at initiation
   * @type {string}
   * @memberof BankingTransactionExtendedDataX2p101Payload
   */
  endToEndId?: string;
  /**
   * Purpose of the payment.  Format is defined by NPP standards for the x2p1.01 overlay service
   * @type {string}
   * @memberof BankingTransactionExtendedDataX2p101Payload
   */
  purposeCode?: string;
}
/**
 *
 * @export
 * @interface BankingTransactionList
 */
export interface BankingTransactionList {
  /**
   *
   * @type {BankingTransactionListData}
   * @memberof BankingTransactionList
   */
  data: BankingTransactionListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingTransactionList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingTransactionList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingTransactionListData
 */
export interface BankingTransactionListData {
  /**
   *
   * @type {Array<BankingTransaction>}
   * @memberof BankingTransactionListData
   */
  transactions: Array<BankingTransaction>;
}
/**
 *
 * @export
 * @interface CommonCustomer
 */
export interface CommonCustomer {
  /**
   * The type of customer object that is present
   * @type {string}
   * @memberof CommonCustomer
   */
  customerUType: CommonCustomerCustomerUTypeEnum;
  /**
   *
   * @type {CommonPersonDetail}
   * @memberof CommonCustomer
   */
  person?: CommonPersonDetail;
  /**
   *
   * @type {CommonOrganisationDetail}
   * @memberof CommonCustomer
   */
  organisation?: CommonOrganisationDetail;
  /**
   *
   * @type {Adatree}
   * @memberof CommonCustomer
   */
  adatree: Adatree;
}

export const CommonCustomerCustomerUTypeEnum = {
  Person: 'person',
  Organisation: 'organisation',
} as const;

export type CommonCustomerCustomerUTypeEnum =
  typeof CommonCustomerCustomerUTypeEnum[keyof typeof CommonCustomerCustomerUTypeEnum];

/**
 *
 * @export
 * @interface CommonEmailAddress
 */
export interface CommonEmailAddress {
  /**
   * May be true for one and only one email record in the collection. Denotes the default email address
   * @type {boolean}
   * @memberof CommonEmailAddress
   */
  isPreferred?: boolean;
  /**
   * The purpose for the email, as specified by the customer (Enumeration)
   * @type {string}
   * @memberof CommonEmailAddress
   */
  purpose: CommonEmailAddressPurposeEnum;
  /**
   * A correctly formatted email address, as defined by the addr_spec format in [RFC 5322](https://www.ietf.org/rfc/rfc5322.txt)
   * @type {string}
   * @memberof CommonEmailAddress
   */
  address: string;
}

export const CommonEmailAddressPurposeEnum = {
  Work: 'WORK',
  Home: 'HOME',
  Other: 'OTHER',
  Unspecified: 'UNSPECIFIED',
} as const;

export type CommonEmailAddressPurposeEnum =
  typeof CommonEmailAddressPurposeEnum[keyof typeof CommonEmailAddressPurposeEnum];

/**
 *
 * @export
 * @interface CommonOrganisation
 */
export interface CommonOrganisation {
  /**
   * The date and time that this record was last updated by the customer. If no update has occurred then this date should reflect the initial creation date for the data
   * @type {string}
   * @memberof CommonOrganisation
   */
  lastUpdateTime?: string;
  /**
   * The first name of the individual providing access on behalf of the organisation. For people with single names this field need not be present.  The single name should be in the lastName field
   * @type {string}
   * @memberof CommonOrganisation
   */
  agentFirstName?: string;
  /**
   * The last name of the individual providing access on behalf of the organisation. For people with single names the single name should be in this field
   * @type {string}
   * @memberof CommonOrganisation
   */
  agentLastName: string;
  /**
   * The role of the individual identified as the agent who is providing authorisation.  Expected to be used for display. Default to Unspecified if the role is not known
   * @type {string}
   * @memberof CommonOrganisation
   */
  agentRole: string;
  /**
   * Name of the organisation
   * @type {string}
   * @memberof CommonOrganisation
   */
  businessName: string;
  /**
   * Legal name, if different to the business name
   * @type {string}
   * @memberof CommonOrganisation
   */
  legalName?: string;
  /**
   * Short name used for communication, if different to the business name
   * @type {string}
   * @memberof CommonOrganisation
   */
  shortName?: string;
  /**
   * Australian Business Number for the organisation
   * @type {string}
   * @memberof CommonOrganisation
   */
  abn?: string;
  /**
   * Australian Company Number for the organisation. Required only if an ACN is applicable for the organisation type
   * @type {string}
   * @memberof CommonOrganisation
   */
  acn?: string;
  /**
   * True if registered with the ACNC.  False if not. Absent or null if not confirmed.
   * @type {boolean}
   * @memberof CommonOrganisation
   */
  isACNCRegistered?: boolean;
  /**
   * A valid [ANZSIC](http://www.abs.gov.au/ANZSIC) code for the organisation. If the industry code held by the data holder is not one of the supported [ANZSIC](http://www.abs.gov.au/ANZSIC) versions, then it must not be supplied.
   * @type {string}
   * @memberof CommonOrganisation
   */
  industryCode?: string;
  /**
   * The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if ``industryCode`` is also supplied. If ``industryCode`` is supplied but ``industryCodeVersion`` is absent, default is ``ANZSIC_1292.0_2006_V2.0``
   * @type {string}
   * @memberof CommonOrganisation
   */
  industryCodeVersion?: CommonOrganisationIndustryCodeVersionEnum;
  /**
   * Legal organisation type
   * @type {string}
   * @memberof CommonOrganisation
   */
  organisationType: CommonOrganisationOrganisationTypeEnum;
  /**
   * Enumeration with values from [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country codes.  Assumed to be AUS if absent
   * @type {string}
   * @memberof CommonOrganisation
   */
  registeredCountry?: string;
  /**
   * The date the organisation described was established
   * @type {string}
   * @memberof CommonOrganisation
   */
  establishmentDate?: string;
}

export const CommonOrganisationIndustryCodeVersionEnum = {
  V10: 'ANZSIC_1292.0_2006_V1.0',
  V20: 'ANZSIC_1292.0_2006_V2.0',
} as const;

export type CommonOrganisationIndustryCodeVersionEnum =
  typeof CommonOrganisationIndustryCodeVersionEnum[keyof typeof CommonOrganisationIndustryCodeVersionEnum];
export const CommonOrganisationOrganisationTypeEnum = {
  Company: 'COMPANY',
  GovernmentEntity: 'GOVERNMENT_ENTITY',
  Partnership: 'PARTNERSHIP',
  SoleTrader: 'SOLE_TRADER',
  Trust: 'TRUST',
  Other: 'OTHER',
} as const;

export type CommonOrganisationOrganisationTypeEnum =
  typeof CommonOrganisationOrganisationTypeEnum[keyof typeof CommonOrganisationOrganisationTypeEnum];

/**
 *
 * @export
 * @interface CommonOrganisationDetail
 */
export interface CommonOrganisationDetail {
  /**
   * The date and time that this record was last updated by the customer. If no update has occurred then this date should reflect the initial creation date for the data
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  lastUpdateTime?: string;
  /**
   * The first name of the individual providing access on behalf of the organisation. For people with single names this field need not be present.  The single name should be in the lastName field
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  agentFirstName?: string;
  /**
   * The last name of the individual providing access on behalf of the organisation. For people with single names the single name should be in this field
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  agentLastName: string;
  /**
   * The role of the individual identified as the agent who is providing authorisation.  Expected to be used for display. Default to Unspecified if the role is not known
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  agentRole: string;
  /**
   * Name of the organisation
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  businessName: string;
  /**
   * Legal name, if different to the business name
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  legalName?: string;
  /**
   * Short name used for communication, if different to the business name
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  shortName?: string;
  /**
   * Australian Business Number for the organisation
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  abn?: string;
  /**
   * Australian Company Number for the organisation. Required only if an ACN is applicable for the organisation type
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  acn?: string;
  /**
   * True if registered with the ACNC.  False if not. Absent or null if not confirmed.
   * @type {boolean}
   * @memberof CommonOrganisationDetail
   */
  isACNCRegistered?: boolean;
  /**
   * A valid [ANZSIC](http://www.abs.gov.au/ANZSIC) code for the organisation. If the industry code held by the data holder is not one of the supported [ANZSIC](http://www.abs.gov.au/ANZSIC) versions, then it must not be supplied.
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  industryCode?: string;
  /**
   * The applicable [ANZSIC](http://www.abs.gov.au/ANZSIC) release version of the industry code provided. Should only be supplied if ``industryCode`` is also supplied. If ``industryCode`` is supplied but ``industryCodeVersion`` is absent, default is ``ANZSIC_1292.0_2006_V2.0``
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  industryCodeVersion?: CommonOrganisationDetailIndustryCodeVersionEnum;
  /**
   * Legal organisation type
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  organisationType: CommonOrganisationDetailOrganisationTypeEnum;
  /**
   * Enumeration with values from [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country codes.  Assumed to be AUS if absent
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  registeredCountry?: string;
  /**
   * The date the organisation described was established
   * @type {string}
   * @memberof CommonOrganisationDetail
   */
  establishmentDate?: string;
  /**
   * Must contain at least one address. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
   * @type {Array<CommonPhysicalAddressWithPurpose>}
   * @memberof CommonOrganisationDetail
   */
  physicalAddresses: Array<CommonPhysicalAddressWithPurpose>;
}

export const CommonOrganisationDetailIndustryCodeVersionEnum = {
  V10: 'ANZSIC_1292.0_2006_V1.0',
  V20: 'ANZSIC_1292.0_2006_V2.0',
} as const;

export type CommonOrganisationDetailIndustryCodeVersionEnum =
  typeof CommonOrganisationDetailIndustryCodeVersionEnum[keyof typeof CommonOrganisationDetailIndustryCodeVersionEnum];
export const CommonOrganisationDetailOrganisationTypeEnum = {
  Company: 'COMPANY',
  GovernmentEntity: 'GOVERNMENT_ENTITY',
  Partnership: 'PARTNERSHIP',
  SoleTrader: 'SOLE_TRADER',
  Trust: 'TRUST',
  Other: 'OTHER',
} as const;

export type CommonOrganisationDetailOrganisationTypeEnum =
  typeof CommonOrganisationDetailOrganisationTypeEnum[keyof typeof CommonOrganisationDetailOrganisationTypeEnum];

/**
 *
 * @export
 * @interface CommonOrganisationDetailAllOf
 */
export interface CommonOrganisationDetailAllOf {
  /**
   * Must contain at least one address. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
   * @type {Array<CommonPhysicalAddressWithPurpose>}
   * @memberof CommonOrganisationDetailAllOf
   */
  physicalAddresses: Array<CommonPhysicalAddressWithPurpose>;
}
/**
 * Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
 * @export
 * @interface CommonPAFAddress
 */
export interface CommonPAFAddress {
  /**
   * Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
   * @type {string}
   * @memberof CommonPAFAddress
   */
  dpid?: string;
  /**
   * Thoroughfare number for a property (first number in a property ranged address)
   * @type {number}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber1?: number;
  /**
   * Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
   * @type {string}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber1Suffix?: string;
  /**
   * Second thoroughfare number (only used if the property has a ranged address eg 23-25)
   * @type {number}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber2?: number;
  /**
   * Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
   * @type {string}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber2Suffix?: string;
  /**
   * Type of flat or unit for the address
   * @type {string}
   * @memberof CommonPAFAddress
   */
  flatUnitType?: string;
  /**
   * Unit number (including suffix, if applicable)
   * @type {string}
   * @memberof CommonPAFAddress
   */
  flatUnitNumber?: string;
  /**
   * Type of floor or level for the address
   * @type {string}
   * @memberof CommonPAFAddress
   */
  floorLevelType?: string;
  /**
   * Floor or level number (including alpha characters)
   * @type {string}
   * @memberof CommonPAFAddress
   */
  floorLevelNumber?: string;
  /**
   * Allotment number for the address
   * @type {string}
   * @memberof CommonPAFAddress
   */
  lotNumber?: string;
  /**
   * Building/Property name 1
   * @type {string}
   * @memberof CommonPAFAddress
   */
  buildingName1?: string;
  /**
   * Building/Property name 2
   * @type {string}
   * @memberof CommonPAFAddress
   */
  buildingName2?: string;
  /**
   * The name of the street
   * @type {string}
   * @memberof CommonPAFAddress
   */
  streetName?: string;
  /**
   * The street type. Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof CommonPAFAddress
   */
  streetType?: string;
  /**
   * The street type suffix. Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof CommonPAFAddress
   */
  streetSuffix?: string;
  /**
   * Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postalDeliveryType?: string;
  /**
   * Postal delivery number if the address is a postal delivery type
   * @type {number}
   * @memberof CommonPAFAddress
   */
  postalDeliveryNumber?: number;
  /**
   * Postal delivery number prefix related to the postal delivery number
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postalDeliveryNumberPrefix?: string;
  /**
   * Postal delivery number suffix related to the postal delivery number
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postalDeliveryNumberSuffix?: string;
  /**
   * Full name of locality
   * @type {string}
   * @memberof CommonPAFAddress
   */
  localityName: string;
  /**
   * Postcode for the locality
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postcode: string;
  /**
   * State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
   * @type {string}
   * @memberof CommonPAFAddress
   */
  state: string;
}
/**
 *
 * @export
 * @interface CommonPerson
 */
export interface CommonPerson {
  /**
   * The date and time that this record was last updated by the customer.  If no update has occurred then this date should reflect the initial creation date for the data
   * @type {string}
   * @memberof CommonPerson
   */
  lastUpdateTime?: string;
  /**
   * For people with single names this field need not be present.  The single name should be in the lastName field
   * @type {string}
   * @memberof CommonPerson
   */
  firstName?: string;
  /**
   * For people with single names the single name should be in this field
   * @type {string}
   * @memberof CommonPerson
   */
  lastName: string;
  /**
   * Field is mandatory but array may be empty
   * @type {Array<string>}
   * @memberof CommonPerson
   */
  middleNames: Array<string>;
  /**
   * Also known as title or salutation.  The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
   * @type {string}
   * @memberof CommonPerson
   */
  prefix?: string;
  /**
   * Used for a trailing suffix to the name (e.g. Jr)
   * @type {string}
   * @memberof CommonPerson
   */
  suffix?: string;
  /**
   * Value is a valid [ANZSCO](http://www.abs.gov.au/ANZSCO) Standard Occupation classification code. If the occupation code held by the data holder is not one of the supported [ANZSCO](http://www.abs.gov.au/ANZSCO) versions, then it must not be supplied.
   * @type {string}
   * @memberof CommonPerson
   */
  occupationCode?: string;
  /**
   * The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an ``occupationCode`` is supplied. If ``occupationCode`` is supplied but ``occupationCodeVersion`` is absent, default is ``ANZSCO_1220.0_2013_V1.2``
   * @type {string}
   * @memberof CommonPerson
   */
  occupationCodeVersion?: CommonPersonOccupationCodeVersionEnum;
}

export const CommonPersonOccupationCodeVersionEnum = {
  _2006V10: 'ANZSCO_1220.0_2006_V1.0',
  _2006V11: 'ANZSCO_1220.0_2006_V1.1',
  _2013V12: 'ANZSCO_1220.0_2013_V1.2',
  _2013V13: 'ANZSCO_1220.0_2013_V1.3',
} as const;

export type CommonPersonOccupationCodeVersionEnum =
  typeof CommonPersonOccupationCodeVersionEnum[keyof typeof CommonPersonOccupationCodeVersionEnum];

/**
 *
 * @export
 * @interface CommonPersonDetail
 */
export interface CommonPersonDetail {
  /**
   * The date and time that this record was last updated by the customer.  If no update has occurred then this date should reflect the initial creation date for the data
   * @type {string}
   * @memberof CommonPersonDetail
   */
  lastUpdateTime?: string;
  /**
   * For people with single names this field need not be present.  The single name should be in the lastName field
   * @type {string}
   * @memberof CommonPersonDetail
   */
  firstName?: string;
  /**
   * For people with single names the single name should be in this field
   * @type {string}
   * @memberof CommonPersonDetail
   */
  lastName: string;
  /**
   * Field is mandatory but array may be empty
   * @type {Array<string>}
   * @memberof CommonPersonDetail
   */
  middleNames: Array<string>;
  /**
   * Also known as title or salutation.  The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
   * @type {string}
   * @memberof CommonPersonDetail
   */
  prefix?: string;
  /**
   * Used for a trailing suffix to the name (e.g. Jr)
   * @type {string}
   * @memberof CommonPersonDetail
   */
  suffix?: string;
  /**
   * Value is a valid [ANZSCO](http://www.abs.gov.au/ANZSCO) Standard Occupation classification code. If the occupation code held by the data holder is not one of the supported [ANZSCO](http://www.abs.gov.au/ANZSCO) versions, then it must not be supplied.
   * @type {string}
   * @memberof CommonPersonDetail
   */
  occupationCode?: string;
  /**
   * The applicable **[[ANZSCO]](#iref-ANZSCO)** release version of the occupation code provided. Mandatory if an ``occupationCode`` is supplied. If ``occupationCode`` is supplied but ``occupationCodeVersion`` is absent, default is ``ANZSCO_1220.0_2013_V1.2``
   * @type {string}
   * @memberof CommonPersonDetail
   */
  occupationCodeVersion?: CommonPersonDetailOccupationCodeVersionEnum;
  /**
   * Array is mandatory but may be empty if no phone numbers are held
   * @type {Array<CommonPhoneNumber>}
   * @memberof CommonPersonDetail
   */
  phoneNumbers: Array<CommonPhoneNumber>;
  /**
   * May be empty
   * @type {Array<CommonEmailAddress>}
   * @memberof CommonPersonDetail
   */
  emailAddresses: Array<CommonEmailAddress>;
  /**
   * Must contain at least one address. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
   * @type {Array<CommonPhysicalAddressWithPurpose>}
   * @memberof CommonPersonDetail
   */
  physicalAddresses: Array<CommonPhysicalAddressWithPurpose>;
}

export const CommonPersonDetailOccupationCodeVersionEnum = {
  _2006V10: 'ANZSCO_1220.0_2006_V1.0',
  _2006V11: 'ANZSCO_1220.0_2006_V1.1',
  _2013V12: 'ANZSCO_1220.0_2013_V1.2',
  _2013V13: 'ANZSCO_1220.0_2013_V1.3',
} as const;

export type CommonPersonDetailOccupationCodeVersionEnum =
  typeof CommonPersonDetailOccupationCodeVersionEnum[keyof typeof CommonPersonDetailOccupationCodeVersionEnum];

/**
 *
 * @export
 * @interface CommonPersonDetailAllOf
 */
export interface CommonPersonDetailAllOf {
  /**
   * Array is mandatory but may be empty if no phone numbers are held
   * @type {Array<CommonPhoneNumber>}
   * @memberof CommonPersonDetailAllOf
   */
  phoneNumbers: Array<CommonPhoneNumber>;
  /**
   * May be empty
   * @type {Array<CommonEmailAddress>}
   * @memberof CommonPersonDetailAllOf
   */
  emailAddresses: Array<CommonEmailAddress>;
  /**
   * Must contain at least one address. One and only one address may have the purpose of REGISTERED. Zero or one, and no more than one, record may have the purpose of MAIL. If zero then the REGISTERED address is to be used for mail
   * @type {Array<CommonPhysicalAddressWithPurpose>}
   * @memberof CommonPersonDetailAllOf
   */
  physicalAddresses: Array<CommonPhysicalAddressWithPurpose>;
}
/**
 *
 * @export
 * @interface CommonPhoneNumber
 */
export interface CommonPhoneNumber {
  /**
   * May be true for one and only one entry to indicate the preferred phone number. Assumed to be \'false\' if not present
   * @type {boolean}
   * @memberof CommonPhoneNumber
   */
  isPreferred?: boolean;
  /**
   * The purpose of the number as specified by the customer
   * @type {string}
   * @memberof CommonPhoneNumber
   */
  purpose: CommonPhoneNumberPurposeEnum;
  /**
   * If absent, assumed to be Australia (+61). The + should be included
   * @type {string}
   * @memberof CommonPhoneNumber
   */
  countryCode?: string;
  /**
   * Required for non Mobile Phones, if field is present and refers to Australian code - the leading 0 should be omitted.
   * @type {string}
   * @memberof CommonPhoneNumber
   */
  areaCode?: string;
  /**
   * The actual phone number, with leading zeros as appropriate
   * @type {string}
   * @memberof CommonPhoneNumber
   */
  number: string;
  /**
   * An extension number (if applicable)
   * @type {string}
   * @memberof CommonPhoneNumber
   */
  extension?: string;
  /**
   * Fully formatted phone number with country code, area code, number and extension incorporated. Formatted according to section 5.1.4. of [RFC 3966](https://www.ietf.org/rfc/rfc3966.txt)
   * @type {string}
   * @memberof CommonPhoneNumber
   */
  fullNumber: string;
}

export const CommonPhoneNumberPurposeEnum = {
  Mobile: 'MOBILE',
  Home: 'HOME',
  International: 'INTERNATIONAL',
  Work: 'WORK',
  Other: 'OTHER',
  Unspecified: 'UNSPECIFIED',
} as const;

export type CommonPhoneNumberPurposeEnum =
  typeof CommonPhoneNumberPurposeEnum[keyof typeof CommonPhoneNumberPurposeEnum];

/**
 *
 * @export
 * @interface CommonPhysicalAddress
 */
export interface CommonPhysicalAddress {
  /**
   * The type of address object present
   * @type {string}
   * @memberof CommonPhysicalAddress
   */
  addressUType: CommonPhysicalAddressAddressUTypeEnum;
  /**
   *
   * @type {CommonSimpleAddress}
   * @memberof CommonPhysicalAddress
   */
  simple?: CommonSimpleAddress;
  /**
   *
   * @type {CommonPAFAddress}
   * @memberof CommonPhysicalAddress
   */
  paf?: CommonPAFAddress;
}

export const CommonPhysicalAddressAddressUTypeEnum = {
  Simple: 'simple',
  Paf: 'paf',
} as const;

export type CommonPhysicalAddressAddressUTypeEnum =
  typeof CommonPhysicalAddressAddressUTypeEnum[keyof typeof CommonPhysicalAddressAddressUTypeEnum];

/**
 *
 * @export
 * @interface CommonPhysicalAddressWithPurpose
 */
export interface CommonPhysicalAddressWithPurpose {
  /**
   * The type of address object present
   * @type {string}
   * @memberof CommonPhysicalAddressWithPurpose
   */
  addressUType: CommonPhysicalAddressWithPurposeAddressUTypeEnum;
  /**
   *
   * @type {CommonSimpleAddress}
   * @memberof CommonPhysicalAddressWithPurpose
   */
  simple?: CommonSimpleAddress;
  /**
   *
   * @type {CommonPAFAddress}
   * @memberof CommonPhysicalAddressWithPurpose
   */
  paf?: CommonPAFAddress;
  /**
   * Enumeration of values indicating the purpose of the physical address
   * @type {string}
   * @memberof CommonPhysicalAddressWithPurpose
   */
  purpose: CommonPhysicalAddressWithPurposePurposeEnum;
}

export const CommonPhysicalAddressWithPurposeAddressUTypeEnum = {
  Simple: 'simple',
  Paf: 'paf',
} as const;

export type CommonPhysicalAddressWithPurposeAddressUTypeEnum =
  typeof CommonPhysicalAddressWithPurposeAddressUTypeEnum[keyof typeof CommonPhysicalAddressWithPurposeAddressUTypeEnum];
export const CommonPhysicalAddressWithPurposePurposeEnum = {
  Mail: 'MAIL',
  Physical: 'PHYSICAL',
  Registered: 'REGISTERED',
  Work: 'WORK',
  Other: 'OTHER',
} as const;

export type CommonPhysicalAddressWithPurposePurposeEnum =
  typeof CommonPhysicalAddressWithPurposePurposeEnum[keyof typeof CommonPhysicalAddressWithPurposePurposeEnum];

/**
 *
 * @export
 * @interface CommonPhysicalAddressWithPurposeAllOf
 */
export interface CommonPhysicalAddressWithPurposeAllOf {
  /**
   * Enumeration of values indicating the purpose of the physical address
   * @type {string}
   * @memberof CommonPhysicalAddressWithPurposeAllOf
   */
  purpose: CommonPhysicalAddressWithPurposeAllOfPurposeEnum;
}

export const CommonPhysicalAddressWithPurposeAllOfPurposeEnum = {
  Mail: 'MAIL',
  Physical: 'PHYSICAL',
  Registered: 'REGISTERED',
  Work: 'WORK',
  Other: 'OTHER',
} as const;

export type CommonPhysicalAddressWithPurposeAllOfPurposeEnum =
  typeof CommonPhysicalAddressWithPurposeAllOfPurposeEnum[keyof typeof CommonPhysicalAddressWithPurposeAllOfPurposeEnum];

/**
 *
 * @export
 * @interface CommonSimpleAddress
 */
export interface CommonSimpleAddress {
  /**
   * Name of the individual or business formatted for inclusion in an address used for physical mail
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  mailingName?: string;
  /**
   * First line of the standard address object
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  addressLine1: string;
  /**
   * Second line of the standard address object
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  addressLine2?: string;
  /**
   * Third line of the standard address object
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  addressLine3?: string;
  /**
   * Mandatory for Australian addresses
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  postcode?: string;
  /**
   * Name of the city or locality
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  city: string;
  /**
   * Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  state: string;
  /**
   * A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  country?: string;
}
/**
 *
 * @export
 * @interface EnergyAccountBaseV2
 */
export interface EnergyAccountBaseV2 {
  /**
   * The ID of the account.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyAccountBaseV2
   */
  accountId: string;
  /**
   * Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
   * @type {string}
   * @memberof EnergyAccountBaseV2
   */
  accountNumber?: string;
  /**
   * An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
   * @type {string}
   * @memberof EnergyAccountBaseV2
   */
  displayName?: string;
  /**
   * Open or closed status for the account. If not present then OPEN is assumed
   * @type {string}
   * @memberof EnergyAccountBaseV2
   */
  openStatus?: EnergyAccountBaseV2OpenStatusEnum;
  /**
   * The date that the account was created or opened. Mandatory if openStatus is OPEN
   * @type {string}
   * @memberof EnergyAccountBaseV2
   */
  creationDate: string;
}

export const EnergyAccountBaseV2OpenStatusEnum = {
  Closed: 'CLOSED',
  Open: 'OPEN',
} as const;

export type EnergyAccountBaseV2OpenStatusEnum =
  typeof EnergyAccountBaseV2OpenStatusEnum[keyof typeof EnergyAccountBaseV2OpenStatusEnum];

/**
 *
 * @export
 * @interface EnergyAccountDetailV2
 */
export interface EnergyAccountDetailV2 {
  /**
   * The ID of the account.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyAccountDetailV2
   */
  accountId: string;
  /**
   * Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
   * @type {string}
   * @memberof EnergyAccountDetailV2
   */
  accountNumber?: string;
  /**
   * An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
   * @type {string}
   * @memberof EnergyAccountDetailV2
   */
  displayName?: string;
  /**
   * Open or closed status for the account. If not present then OPEN is assumed
   * @type {string}
   * @memberof EnergyAccountDetailV2
   */
  openStatus?: EnergyAccountDetailV2OpenStatusEnum;
  /**
   * The date that the account was created or opened. Mandatory if openStatus is OPEN
   * @type {string}
   * @memberof EnergyAccountDetailV2
   */
  creationDate: string;
  /**
   * The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
   * @type {string}
   * @memberof EnergyAccountDetailV2
   */
  balance?: string;
  /**
   * The array of plans containing service points and associated plan details
   * @type {Array<EnergyAccountDetailV2AllOfPlans>}
   * @memberof EnergyAccountDetailV2
   */
  plans: Array<EnergyAccountDetailV2AllOfPlans>;
  /**
   * The array of agreed payment schedules
   * @type {Array<EnergyPaymentSchedule>}
   * @memberof EnergyAccountDetailV2
   */
  paymentSchedules?: Array<EnergyPaymentSchedule>;
  /**
   * Array may be empty if no concessions exist
   * @type {Array<EnergyConcession>}
   * @memberof EnergyAccountDetailV2
   */
  concessions?: Array<EnergyConcession>;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyAccountDetailV2
   */
  adatree: Adatree;
}

export const EnergyAccountDetailV2OpenStatusEnum = {
  Closed: 'CLOSED',
  Open: 'OPEN',
} as const;

export type EnergyAccountDetailV2OpenStatusEnum =
  typeof EnergyAccountDetailV2OpenStatusEnum[keyof typeof EnergyAccountDetailV2OpenStatusEnum];

/**
 * The array of plans containing service points and associated plan details
 * @export
 * @interface EnergyAccountDetailV2AllOf
 */
export interface EnergyAccountDetailV2AllOf {
  /**
   * The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
   * @type {string}
   * @memberof EnergyAccountDetailV2AllOf
   */
  balance?: string;
  /**
   * The array of plans containing service points and associated plan details
   * @type {Array<EnergyAccountDetailV2AllOfPlans>}
   * @memberof EnergyAccountDetailV2AllOf
   */
  plans: Array<EnergyAccountDetailV2AllOfPlans>;
  /**
   * The array of agreed payment schedules
   * @type {Array<EnergyPaymentSchedule>}
   * @memberof EnergyAccountDetailV2AllOf
   */
  paymentSchedules?: Array<EnergyPaymentSchedule>;
  /**
   * Array may be empty if no concessions exist
   * @type {Array<EnergyConcession>}
   * @memberof EnergyAccountDetailV2AllOf
   */
  concessions?: Array<EnergyConcession>;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyAccountDetailV2AllOf
   */
  adatree: Adatree;
}
/**
 *
 * @export
 * @interface EnergyAccountDetailV2AllOfAuthorisedContacts
 */
export interface EnergyAccountDetailV2AllOfAuthorisedContacts {
  /**
   * For people with single names this field need not be present. The single name should be in the lastName field
   * @type {string}
   * @memberof EnergyAccountDetailV2AllOfAuthorisedContacts
   */
  firstName?: string;
  /**
   * For people with single names the single name should be in this field
   * @type {string}
   * @memberof EnergyAccountDetailV2AllOfAuthorisedContacts
   */
  lastName: string;
  /**
   * Field is mandatory but array may be empty
   * @type {Array<string>}
   * @memberof EnergyAccountDetailV2AllOfAuthorisedContacts
   */
  middleNames?: Array<string>;
  /**
   * Also known as title or salutation. The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
   * @type {string}
   * @memberof EnergyAccountDetailV2AllOfAuthorisedContacts
   */
  prefix?: string;
  /**
   * Used for a trailing suffix to the name (e.g. Jr)
   * @type {string}
   * @memberof EnergyAccountDetailV2AllOfAuthorisedContacts
   */
  suffix?: string;
}
/**
 * Detail on the plan applicable to this account. Mandatory if openStatus is OPEN
 * @export
 * @interface EnergyAccountDetailV2AllOfPlanDetail
 */
export interface EnergyAccountDetailV2AllOfPlanDetail {
  /**
   * The fuel types covered by the plan
   * @type {string}
   * @memberof EnergyAccountDetailV2AllOfPlanDetail
   */
  fuelType: EnergyAccountDetailV2AllOfPlanDetailFuelTypeEnum;
  /**
   * Flag that indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up). Has no meaning if the plan has a fuelType of DUAL. If absent the value is assumed to be false
   * @type {boolean}
   * @memberof EnergyAccountDetailV2AllOfPlanDetail
   */
  isContingentPlan?: boolean;
  /**
   * Charges for metering included in the plan
   * @type {Array<EnergyPlanDetailAllOfMeteringCharges>}
   * @memberof EnergyAccountDetailV2AllOfPlanDetail
   */
  meteringCharges?: Array<EnergyPlanDetailAllOfMeteringCharges>;
  /**
   *
   * @type {EnergyPlanContract}
   * @memberof EnergyAccountDetailV2AllOfPlanDetail
   */
  gasContract?: EnergyPlanContract;
  /**
   *
   * @type {EnergyPlanContract}
   * @memberof EnergyAccountDetailV2AllOfPlanDetail
   */
  electricityContract?: EnergyPlanContract;
}

export const EnergyAccountDetailV2AllOfPlanDetailFuelTypeEnum = {
  Electricity: 'ELECTRICITY',
  Gas: 'GAS',
  Dual: 'DUAL',
} as const;

export type EnergyAccountDetailV2AllOfPlanDetailFuelTypeEnum =
  typeof EnergyAccountDetailV2AllOfPlanDetailFuelTypeEnum[keyof typeof EnergyAccountDetailV2AllOfPlanDetailFuelTypeEnum];

/**
 *
 * @export
 * @interface EnergyAccountDetailV2AllOfPlans
 */
export interface EnergyAccountDetailV2AllOfPlans {
  /**
   * Optional display name for the plan provided by the customer to help differentiate multiple plans
   * @type {string}
   * @memberof EnergyAccountDetailV2AllOfPlans
   */
  nickname?: string;
  /**
   * An array of servicePointIds, representing NMIs, that this account is linked to
   * @type {Array<string>}
   * @memberof EnergyAccountDetailV2AllOfPlans
   */
  servicePointIds: Array<string>;
  /**
   *
   * @type {EnergyAccountV2AllOfPlanOverview}
   * @memberof EnergyAccountDetailV2AllOfPlans
   */
  planOverview?: EnergyAccountV2AllOfPlanOverview;
  /**
   *
   * @type {EnergyAccountDetailV2AllOfPlanDetail}
   * @memberof EnergyAccountDetailV2AllOfPlans
   */
  planDetail?: EnergyAccountDetailV2AllOfPlanDetail;
  /**
   * An array of additional contacts that are authorised to act on this account
   * @type {Array<EnergyAccountDetailV2AllOfAuthorisedContacts>}
   * @memberof EnergyAccountDetailV2AllOfPlans
   */
  authorisedContacts?: Array<EnergyAccountDetailV2AllOfAuthorisedContacts>;
}
/**
 *
 * @export
 * @interface EnergyAccountList
 */
export interface EnergyAccountList {
  /**
   *
   * @type {EnergyAccountListData}
   * @memberof EnergyAccountList
   */
  data: EnergyAccountListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyAccountList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyAccountList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyAccountListData
 */
export interface EnergyAccountListData {
  /**
   * The list of energy accounts returned. If the filter results in an empty set then this array may have no records
   * @type {Array<EnergyAccountDetailV2>}
   * @memberof EnergyAccountListData
   */
  accounts: Array<EnergyAccountDetailV2>;
}
/**
 *
 * @export
 * @interface EnergyAccountV2
 */
export interface EnergyAccountV2 {
  /**
   * The ID of the account.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyAccountV2
   */
  accountId: string;
  /**
   * Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
   * @type {string}
   * @memberof EnergyAccountV2
   */
  accountNumber?: string;
  /**
   * An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
   * @type {string}
   * @memberof EnergyAccountV2
   */
  displayName?: string;
  /**
   * Open or closed status for the account. If not present then OPEN is assumed
   * @type {string}
   * @memberof EnergyAccountV2
   */
  openStatus?: EnergyAccountV2OpenStatusEnum;
  /**
   * The date that the account was created or opened. Mandatory if openStatus is OPEN
   * @type {string}
   * @memberof EnergyAccountV2
   */
  creationDate: string;
  /**
   * The array of plans containing service points and associated plan details
   * @type {Array<EnergyAccountV2AllOfPlans>}
   * @memberof EnergyAccountV2
   */
  plans: Array<EnergyAccountV2AllOfPlans>;
}

export const EnergyAccountV2OpenStatusEnum = {
  Closed: 'CLOSED',
  Open: 'OPEN',
} as const;

export type EnergyAccountV2OpenStatusEnum =
  typeof EnergyAccountV2OpenStatusEnum[keyof typeof EnergyAccountV2OpenStatusEnum];

/**
 * The array of plans containing service points and associated plan details
 * @export
 * @interface EnergyAccountV2AllOf
 */
export interface EnergyAccountV2AllOf {
  /**
   * The array of plans containing service points and associated plan details
   * @type {Array<EnergyAccountV2AllOfPlans>}
   * @memberof EnergyAccountV2AllOf
   */
  plans: Array<EnergyAccountV2AllOfPlans>;
}
/**
 * Mandatory if openStatus is OPEN
 * @export
 * @interface EnergyAccountV2AllOfPlanOverview
 */
export interface EnergyAccountV2AllOfPlanOverview {
  /**
   * The name of the plan if one exists
   * @type {string}
   * @memberof EnergyAccountV2AllOfPlanOverview
   */
  displayName?: string;
  /**
   * The start date of the applicability of this plan
   * @type {string}
   * @memberof EnergyAccountV2AllOfPlanOverview
   */
  startDate: string;
  /**
   * The end date of the applicability of this plan
   * @type {string}
   * @memberof EnergyAccountV2AllOfPlanOverview
   */
  endDate?: string;
}
/**
 *
 * @export
 * @interface EnergyAccountV2AllOfPlans
 */
export interface EnergyAccountV2AllOfPlans {
  /**
   * Optional display name for the plan provided by the customer to help differentiate multiple plans
   * @type {string}
   * @memberof EnergyAccountV2AllOfPlans
   */
  nickname?: string;
  /**
   * An array of servicePointIds, representing NMIs, that this plan is linked to.  If there are no service points allocated to this plan then an empty array would be expected
   * @type {Array<string>}
   * @memberof EnergyAccountV2AllOfPlans
   */
  servicePointIds: Array<string>;
  /**
   *
   * @type {EnergyAccountV2AllOfPlanOverview}
   * @memberof EnergyAccountV2AllOfPlans
   */
  planOverview?: EnergyAccountV2AllOfPlanOverview;
}
/**
 *
 * @export
 * @interface EnergyBillingDemandTransaction
 */
export interface EnergyBillingDemandTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  invoiceNumber?: string;
  /**
   * The time of use type that the transaction applies to
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  timeOfUseType: EnergyBillingDemandTransactionTimeOfUseTypeEnum;
  /**
   * Optional description of the transaction that can be used for display purposes
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  description?: string;
  /**
   * Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
   * @type {boolean}
   * @memberof EnergyBillingDemandTransaction
   */
  isEstimate?: boolean;
  /**
   * Date and time when the demand period starts
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  startDate: string;
  /**
   * Date and time when the demand period ends
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  endDate: string;
  /**
   * The rate for the demand charge in kVA.  A negative value indicates power generated
   * @type {number}
   * @memberof EnergyBillingDemandTransaction
   */
  rate: number;
  /**
   * The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  amount: string;
  /**
   * Additional calculation factors that inform the transaction
   * @type {Array<EnergyBillingUsageTransactionCalculationFactors>}
   * @memberof EnergyBillingDemandTransaction
   */
  calculationFactors?: Array<EnergyBillingUsageTransactionCalculationFactors>;
  /**
   * Optional array of adjustments arising for this transaction
   * @type {Array<EnergyBillingUsageTransactionAdjustments>}
   * @memberof EnergyBillingDemandTransaction
   */
  adjustments?: Array<EnergyBillingUsageTransactionAdjustments>;
}

export const EnergyBillingDemandTransactionTimeOfUseTypeEnum = {
  Peak: 'PEAK',
  OffPeak: 'OFF_PEAK',
  OffPeakDemandCharge: 'OFF_PEAK_DEMAND_CHARGE',
  Shoulder: 'SHOULDER',
  Shoulder1: 'SHOULDER1',
  Shoulder2: 'SHOULDER2',
  ControlledLoad: 'CONTROLLED_LOAD',
  Solar: 'SOLAR',
  Aggregate: 'AGGREGATE',
} as const;

export type EnergyBillingDemandTransactionTimeOfUseTypeEnum =
  typeof EnergyBillingDemandTransactionTimeOfUseTypeEnum[keyof typeof EnergyBillingDemandTransactionTimeOfUseTypeEnum];

/**
 *
 * @export
 * @interface EnergyBillingList
 */
export interface EnergyBillingList {
  /**
   *
   * @type {EnergyBillingListData}
   * @memberof EnergyBillingList
   */
  data: EnergyBillingListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyBillingList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyBillingList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyBillingListData
 */
export interface EnergyBillingListData {
  /**
   * Array of transactions sorted by date and time in descending order
   * @type {Array<EnergyBillingTransaction>}
   * @memberof EnergyBillingListData
   */
  transactions: Array<EnergyBillingTransaction>;
}
/**
 *
 * @export
 * @interface EnergyBillingOnceOffTransaction
 */
export interface EnergyBillingOnceOffTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  invoiceNumber?: string;
  /**
   * The amount of the charge or credit.  A positive value indicates a charge and a negative value indicates a credit
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  amount: string;
  /**
   * A free text description of the item
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  description: string;
}
/**
 *
 * @export
 * @interface EnergyBillingOtherTransaction
 */
export interface EnergyBillingOtherTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  invoiceNumber?: string;
  /**
   * Optional start date for the application of the charge
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  startDate?: string;
  /**
   * Optional end date for the application of the charge
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  endDate?: string;
  /**
   * Type of charge. Assumed to be other if absent
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  type?: EnergyBillingOtherTransactionTypeEnum;
  /**
   * The amount of the charge
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  amount: string;
  /**
   * A free text description of the item
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  description: string;
  /**
   * Additional calculation factors that inform the transaction
   * @type {Array<EnergyBillingUsageTransactionCalculationFactors>}
   * @memberof EnergyBillingOtherTransaction
   */
  calculationFactors?: Array<EnergyBillingUsageTransactionCalculationFactors>;
  /**
   * Optional array of adjustments arising for this transaction
   * @type {Array<EnergyBillingUsageTransactionAdjustments>}
   * @memberof EnergyBillingOtherTransaction
   */
  adjustments?: Array<EnergyBillingUsageTransactionAdjustments>;
}

export const EnergyBillingOtherTransactionTypeEnum = {
  Environmental: 'ENVIRONMENTAL',
  Regulated: 'REGULATED',
  Network: 'NETWORK',
  Metering: 'METERING',
  RetailService: 'RETAIL_SERVICE',
  Rcti: 'RCTI',
  Other: 'OTHER',
} as const;

export type EnergyBillingOtherTransactionTypeEnum =
  typeof EnergyBillingOtherTransactionTypeEnum[keyof typeof EnergyBillingOtherTransactionTypeEnum];

/**
 *
 * @export
 * @interface EnergyBillingPaymentTransaction
 */
export interface EnergyBillingPaymentTransaction {
  /**
   * The amount paid
   * @type {string}
   * @memberof EnergyBillingPaymentTransaction
   */
  amount: string;
  /**
   * The method of payment
   * @type {string}
   * @memberof EnergyBillingPaymentTransaction
   */
  method: EnergyBillingPaymentTransactionMethodEnum;
}

export const EnergyBillingPaymentTransactionMethodEnum = {
  DirectDebit: 'DIRECT_DEBIT',
  Card: 'CARD',
  Transfer: 'TRANSFER',
  Bpay: 'BPAY',
  Cash: 'CASH',
  Cheque: 'CHEQUE',
  Other: 'OTHER',
} as const;

export type EnergyBillingPaymentTransactionMethodEnum =
  typeof EnergyBillingPaymentTransactionMethodEnum[keyof typeof EnergyBillingPaymentTransactionMethodEnum];

/**
 *
 * @export
 * @interface EnergyBillingTransaction
 */
export interface EnergyBillingTransaction {
  /**
   * The ID of the account for which transaction applies
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  accountId: string;
  /**
   * The date and time that the transaction occurred
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  executionDateTime: string;
  /**
   * The GST incurred in the transaction.  Should not be included for credits or payments.  If absent zero is assumed
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  gst?: string;
  /**
   * Indicator of the type of transaction object present in this record
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  transactionUType: EnergyBillingTransactionTransactionUTypeEnum;
  /**
   *
   * @type {EnergyBillingUsageTransaction}
   * @memberof EnergyBillingTransaction
   */
  usage?: EnergyBillingUsageTransaction;
  /**
   *
   * @type {EnergyBillingDemandTransaction}
   * @memberof EnergyBillingTransaction
   */
  demand?: EnergyBillingDemandTransaction;
  /**
   *
   * @type {EnergyBillingOnceOffTransaction}
   * @memberof EnergyBillingTransaction
   */
  onceOff?: EnergyBillingOnceOffTransaction;
  /**
   *
   * @type {EnergyBillingOtherTransaction}
   * @memberof EnergyBillingTransaction
   */
  otherCharges?: EnergyBillingOtherTransaction;
  /**
   *
   * @type {EnergyBillingPaymentTransaction}
   * @memberof EnergyBillingTransaction
   */
  payment?: EnergyBillingPaymentTransaction;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyBillingTransaction
   */
  adatree: Adatree;
}

export const EnergyBillingTransactionTransactionUTypeEnum = {
  Usage: 'usage',
  Demand: 'demand',
  OnceOff: 'onceOff',
  OtherCharges: 'otherCharges',
  Payment: 'payment',
} as const;

export type EnergyBillingTransactionTransactionUTypeEnum =
  typeof EnergyBillingTransactionTransactionUTypeEnum[keyof typeof EnergyBillingTransactionTransactionUTypeEnum];

/**
 *
 * @export
 * @interface EnergyBillingUsageTransaction
 */
export interface EnergyBillingUsageTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  invoiceNumber?: string;
  /**
   * The time of use type that the transaction applies to
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  timeOfUseType: EnergyBillingUsageTransactionTimeOfUseTypeEnum;
  /**
   * Optional description of the transaction that can be used for display purposes
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  description?: string;
  /**
   * Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
   * @type {boolean}
   * @memberof EnergyBillingUsageTransaction
   */
  isEstimate?: boolean;
  /**
   * Date and time when the usage period starts
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  startDate: string;
  /**
   * Date and time when the usage period ends
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  endDate: string;
  /**
   * The measurement unit of rate. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  measureUnit?: EnergyBillingUsageTransactionMeasureUnitEnum;
  /**
   * The usage for the period in measure unit.  A negative value indicates power generated
   * @type {number}
   * @memberof EnergyBillingUsageTransaction
   */
  usage: number;
  /**
   * The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  amount: string;
  /**
   * Additional calculation factors that inform the transaction
   * @type {Array<EnergyBillingUsageTransactionCalculationFactors>}
   * @memberof EnergyBillingUsageTransaction
   */
  calculationFactors?: Array<EnergyBillingUsageTransactionCalculationFactors>;
  /**
   * Optional array of adjustments arising for this transaction
   * @type {Array<EnergyBillingUsageTransactionAdjustments>}
   * @memberof EnergyBillingUsageTransaction
   */
  adjustments?: Array<EnergyBillingUsageTransactionAdjustments>;
}

export const EnergyBillingUsageTransactionTimeOfUseTypeEnum = {
  Peak: 'PEAK',
  OffPeak: 'OFF_PEAK',
  OffPeakDemandCharge: 'OFF_PEAK_DEMAND_CHARGE',
  Shoulder: 'SHOULDER',
  Shoulder1: 'SHOULDER1',
  Shoulder2: 'SHOULDER2',
  ControlledLoad: 'CONTROLLED_LOAD',
  Solar: 'SOLAR',
  Aggregate: 'AGGREGATE',
} as const;

export type EnergyBillingUsageTransactionTimeOfUseTypeEnum =
  typeof EnergyBillingUsageTransactionTimeOfUseTypeEnum[keyof typeof EnergyBillingUsageTransactionTimeOfUseTypeEnum];
export const EnergyBillingUsageTransactionMeasureUnitEnum = {
  Kwh: 'KWH',
  Kva: 'KVA',
  Kvar: 'KVAR',
  Kvarh: 'KVARH',
  Kw: 'KW',
  Days: 'DAYS',
  Meter: 'METER',
  Month: 'MONTH',
} as const;

export type EnergyBillingUsageTransactionMeasureUnitEnum =
  typeof EnergyBillingUsageTransactionMeasureUnitEnum[keyof typeof EnergyBillingUsageTransactionMeasureUnitEnum];

/**
 *
 * @export
 * @interface EnergyBillingUsageTransactionAdjustments
 */
export interface EnergyBillingUsageTransactionAdjustments {
  /**
   * The amount of the adjustment
   * @type {string}
   * @memberof EnergyBillingUsageTransactionAdjustments
   */
  amount: string;
  /**
   * A free text description of the adjustment
   * @type {string}
   * @memberof EnergyBillingUsageTransactionAdjustments
   */
  description: string;
}
/**
 *
 * @export
 * @interface EnergyBillingUsageTransactionCalculationFactors
 */
export interface EnergyBillingUsageTransactionCalculationFactors {
  /**
   * The value of the calculation factor
   * @type {number}
   * @memberof EnergyBillingUsageTransactionCalculationFactors
   */
  value: number;
  /**
   * The type of the calculation factor
   * @type {string}
   * @memberof EnergyBillingUsageTransactionCalculationFactors
   */
  type: EnergyBillingUsageTransactionCalculationFactorsTypeEnum;
}

export const EnergyBillingUsageTransactionCalculationFactorsTypeEnum = {
  Dlf: 'DLF',
  Mlf: 'MLF',
} as const;

export type EnergyBillingUsageTransactionCalculationFactorsTypeEnum =
  typeof EnergyBillingUsageTransactionCalculationFactorsTypeEnum[keyof typeof EnergyBillingUsageTransactionCalculationFactorsTypeEnum];

/**
 *
 * @export
 * @interface EnergyConcession
 */
export interface EnergyConcession {
  /**
   * Indicator of the method of concession calculation
   * @type {string}
   * @memberof EnergyConcession
   */
  type: EnergyConcessionTypeEnum;
  /**
   * The display name of the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  displayName: string;
  /**
   * Display text providing more information on the concession Mandatory if type is VARIABLE
   * @type {string}
   * @memberof EnergyConcession
   */
  additionalInfo?: string;
  /**
   * Optional link to additional information regarding the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  additionalInfoUri?: string;
  /**
   * Optional start date for the application of the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  startDate?: string;
  /**
   * Optional end date for the application of the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  endDate?: string;
  /**
   * Conditional attribute for frequency at which a concession is applied. Required if type is FIXED_AMOUNT or FIXED_PERCENTAGE. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyConcession
   */
  discountFrequency?: string;
  /**
   * Conditional attribute for the amount of discount for the concession- required if type is FIXED_AMOUNT
   * @type {string}
   * @memberof EnergyConcession
   */
  amount?: string;
  /**
   * Conditional attribute for the percentage of discount of concession - required if type is FIXED_PERCENTAGE
   * @type {string}
   * @memberof EnergyConcession
   */
  percentage?: string;
  /**
   * Array of ENUM\'s to specify what the concession applies to. Multiple ENUM values can be provided. If absent, USAGE is assumed
   * @type {Array<string>}
   * @memberof EnergyConcession
   */
  appliedTo?: Array<EnergyConcessionAppliedToEnum>;
}

export const EnergyConcessionTypeEnum = {
  FixedAmount: 'FIXED_AMOUNT',
  FixedPercentage: 'FIXED_PERCENTAGE',
  Variable: 'VARIABLE',
} as const;

export type EnergyConcessionTypeEnum = typeof EnergyConcessionTypeEnum[keyof typeof EnergyConcessionTypeEnum];
export const EnergyConcessionAppliedToEnum = {
  Invoice: 'INVOICE',
  Usage: 'USAGE',
  ServiceCharge: 'SERVICE_CHARGE',
  ControlledLoad: 'CONTROLLED_LOAD',
} as const;

export type EnergyConcessionAppliedToEnum =
  typeof EnergyConcessionAppliedToEnum[keyof typeof EnergyConcessionAppliedToEnum];

/**
 *
 * @export
 * @interface EnergyDerRecord
 */
export interface EnergyDerRecord {
  /**
   * Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyDerRecord
   */
  servicePointId: string;
  /**
   * Approved small generating unit capacity as agreed with NSP in the connection agreement, expressed in kVA. Value of 0 indicates no DER record exists for the given servicePointId
   * @type {number}
   * @memberof EnergyDerRecord
   */
  approvedCapacity: number;
  /**
   * The number of phases available for the installation of DER. Acceptable values are 0, 1, 2 or 3. Value of 0 indicates no DER record exists for the given servicePointId
   * @type {number}
   * @memberof EnergyDerRecord
   */
  availablePhasesCount: number;
  /**
   * The number of phases that DER is connected to. Acceptable values are 0, 1, 2 or 3. Value of 0 indicates no DER record exists for the given servicePointId
   * @type {number}
   * @memberof EnergyDerRecord
   */
  installedPhasesCount: number;
  /**
   * For identification of small generating units designed with the ability to operate in an islanded mode
   * @type {boolean}
   * @memberof EnergyDerRecord
   */
  islandableInstallation: boolean;
  /**
   * For DER installations where NSPs specify the need for additional forms of protection above those inbuilt in an inverter.  If absent then assumed to be false
   * @type {boolean}
   * @memberof EnergyDerRecord
   */
  hasCentralProtectionControl?: boolean;
  /**
   *
   * @type {EnergyDerRecordProtectionMode}
   * @memberof EnergyDerRecord
   */
  protectionMode?: EnergyDerRecordProtectionMode;
  /**
   *
   * @type {Array<EnergyDerRecordAcConnections>}
   * @memberof EnergyDerRecord
   */
  acConnections: Array<EnergyDerRecordAcConnections>;
}
/**
 *
 * @export
 * @interface EnergyDerRecordAcConnections
 */
export interface EnergyDerRecordAcConnections {
  /**
   * AC Connection ID as defined in the DER register.  Does not align with CDR ID permanence standards
   * @type {number}
   * @memberof EnergyDerRecordAcConnections
   */
  connectionIdentifier: number;
  /**
   * Number of AC Connections in the group. For the suite of AC Connections to be considered as a group, all of the AC Connections included must have the same attributes
   * @type {number}
   * @memberof EnergyDerRecordAcConnections
   */
  count: number;
  /**
   * Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be OTHER.
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  equipmentType?: EnergyDerRecordAcConnectionsEquipmentTypeEnum;
  /**
   * The name of the inverter manufacturer. Mandatory if equipmentType is INVERTER
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  manufacturerName?: string;
  /**
   * The inverter series. Mandatory if equipmentType is INVERTER
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  inverterSeries?: string;
  /**
   * The inverter model number. Mandatory if equipmentType is INVERTER
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  inverterModelNumber?: string;
  /**
   * The date that the DER installation is commissioned
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  commissioningDate: string;
  /**
   * Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  status: EnergyDerRecordAcConnectionsStatusEnum;
  /**
   * The rated AC output power that is listed in the product specified by the manufacturer. Mandatory if equipmentType is INVERTER. Default is 0 if value not known
   * @type {number}
   * @memberof EnergyDerRecordAcConnections
   */
  inverterDeviceCapacity?: number;
  /**
   *
   * @type {Array<EnergyDerRecordDerDevices>}
   * @memberof EnergyDerRecordAcConnections
   */
  derDevices: Array<EnergyDerRecordDerDevices>;
}

export const EnergyDerRecordAcConnectionsEquipmentTypeEnum = {
  Inverter: 'INVERTER',
  Other: 'OTHER',
} as const;

export type EnergyDerRecordAcConnectionsEquipmentTypeEnum =
  typeof EnergyDerRecordAcConnectionsEquipmentTypeEnum[keyof typeof EnergyDerRecordAcConnectionsEquipmentTypeEnum];
export const EnergyDerRecordAcConnectionsStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Decommissioned: 'DECOMMISSIONED',
} as const;

export type EnergyDerRecordAcConnectionsStatusEnum =
  typeof EnergyDerRecordAcConnectionsStatusEnum[keyof typeof EnergyDerRecordAcConnectionsStatusEnum];

/**
 *
 * @export
 * @interface EnergyDerRecordDerDevices
 */
export interface EnergyDerRecordDerDevices {
  /**
   * Unique identifier for a single DER device or a group of DER devices with the same attributes. Does not align with CDR ID permanence standards
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  deviceIdentifier: number;
  /**
   * Number of devices in the group of DER devices
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  count: number;
  /**
   * The name of the device manufacturer. If absent then assumed to be unknown
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  manufacturer?: string;
  /**
   * The model number of the device. If absent then assumed to be unknown
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  modelNumber?: string;
  /**
   * Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  status?: EnergyDerRecordDerDevicesStatusEnum;
  /**
   * Used to indicate the primary technology used in the DER device
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  type: EnergyDerRecordDerDevicesTypeEnum;
  /**
   * Used to indicate the primary technology used in the DER device. This field is also used to record for example the battery chemistry, or the type of PV panel. It is also used to record if a battery is contained in an electric vehicle connected in a vehicle-to-grid arrangement. If absent then assumed to be other
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  subtype?: string;
  /**
   * Maximum output in kVA that is listed in the product specification by the manufacturer. This refers to the capacity of each unit within the device group. Default is 0 if value not known
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  nominalRatedCapacity: number;
  /**
   * Maximum storage capacity in kVAh. This refers to the capacity of each storage module within the device group. Mandatory if type is equal to STORAGE. Default is 0 if value not known
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  nominalStorageCapacity?: number;
}

export const EnergyDerRecordDerDevicesStatusEnum = {
  Active: 'ACTIVE',
  Inactive: 'INACTIVE',
  Decommissioned: 'DECOMMISSIONED',
} as const;

export type EnergyDerRecordDerDevicesStatusEnum =
  typeof EnergyDerRecordDerDevicesStatusEnum[keyof typeof EnergyDerRecordDerDevicesStatusEnum];
export const EnergyDerRecordDerDevicesTypeEnum = {
  Fossil: 'FOSSIL',
  Hydro: 'HYDRO',
  Wind: 'WIND',
  SolarPv: 'SOLAR_PV',
  Renewable: 'RENEWABLE',
  Geothermal: 'GEOTHERMAL',
  Storage: 'STORAGE',
  Other: 'OTHER',
} as const;

export type EnergyDerRecordDerDevicesTypeEnum =
  typeof EnergyDerRecordDerDevicesTypeEnum[keyof typeof EnergyDerRecordDerDevicesTypeEnum];

/**
 * Required only when the hasCentralProtectionAndControl flag is set to true.  One or more of the object fields will be provided to describe the protection modes in place
 * @export
 * @interface EnergyDerRecordProtectionMode
 */
export interface EnergyDerRecordProtectionMode {
  /**
   * Maximum amount of power (kVA) that may be exported from a connection point to the grid, as monitored by a control / relay function. An absent value indicates no limit
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  exportLimitKva?: number;
  /**
   * Protective function limit in Hz.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underFrequencyProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underFrequencyProtectionDelay?: number;
  /**
   * Protective function limit in Hz.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overFrequencyProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overFrequencyProtectionDelay?: number;
  /**
   * Protective function limit in V.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underVoltageProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underVoltageProtectionDelay?: number;
  /**
   * Protective function limit in V.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overVoltageProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overVoltageProtectionDelay?: number;
  /**
   * Sustained over voltage.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  sustainedOverVoltage?: number;
  /**
   * Sustained Over voltage protection delay in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  sustainedOverVoltageDelay?: number;
  /**
   * Rate of change of frequency trip point (Hz/s).
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  frequencyRateOfChange?: number;
  /**
   * Trip angle in degrees.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  voltageVectorShift?: number;
  /**
   * Description of the form of inter-trip (e.g. \'from local substation\').
   * @type {string}
   * @memberof EnergyDerRecordProtectionMode
   */
  interTripScheme?: string;
  /**
   * Trip voltage.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  neutralVoltageDisplacement?: number;
}
/**
 *
 * @export
 * @interface EnergyInvoice
 */
export interface EnergyInvoice {
  /**
   * The ID of the account for which the invoice was issued
   * @type {string}
   * @memberof EnergyInvoice
   */
  accountId: string;
  /**
   * The number assigned to this invoice by the energy Retailer
   * @type {string}
   * @memberof EnergyInvoice
   */
  invoiceNumber: string;
  /**
   * The date that the invoice was actually issued (as opposed to generated or calculated)
   * @type {string}
   * @memberof EnergyInvoice
   */
  issueDate: string;
  /**
   * The date that the invoice is due to be paid
   * @type {string}
   * @memberof EnergyInvoice
   */
  dueDate?: string;
  /**
   *
   * @type {EnergyInvoicePeriod}
   * @memberof EnergyInvoice
   */
  period?: EnergyInvoicePeriod;
  /**
   * The net amount due for this invoice regardless of previous balance
   * @type {string}
   * @memberof EnergyInvoice
   */
  invoiceAmount?: string;
  /**
   * The total GST amount for this invoice.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoice
   */
  gstAmount?: string;
  /**
   *
   * @type {EnergyInvoicePayOnTimeDiscount}
   * @memberof EnergyInvoice
   */
  payOnTimeDiscount?: EnergyInvoicePayOnTimeDiscount;
  /**
   * The account balance at the time the invoice was issued
   * @type {string}
   * @memberof EnergyInvoice
   */
  balanceAtIssue: string;
  /**
   * Array of service point IDs to which this invoice applies. May be empty if the invoice contains no electricity usage related charges
   * @type {Array<string>}
   * @memberof EnergyInvoice
   */
  servicePoints: Array<string>;
  /**
   *
   * @type {EnergyInvoiceGasUsageCharges}
   * @memberof EnergyInvoice
   */
  gas?: EnergyInvoiceGasUsageCharges;
  /**
   *
   * @type {EnergyInvoiceElectricityUsageCharges}
   * @memberof EnergyInvoice
   */
  electricity?: EnergyInvoiceElectricityUsageCharges;
  /**
   *
   * @type {EnergyInvoiceAccountCharges}
   * @memberof EnergyInvoice
   */
  accountCharges?: EnergyInvoiceAccountCharges;
  /**
   * Indicator of the payment status for the invoice
   * @type {string}
   * @memberof EnergyInvoice
   */
  paymentStatus: EnergyInvoicePaymentStatusEnum;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyInvoice
   */
  adatree: Adatree;
}

export const EnergyInvoicePaymentStatusEnum = {
  Paid: 'PAID',
  PartiallyPaid: 'PARTIALLY_PAID',
  NotPaid: 'NOT_PAID',
} as const;

export type EnergyInvoicePaymentStatusEnum =
  typeof EnergyInvoicePaymentStatusEnum[keyof typeof EnergyInvoicePaymentStatusEnum];

/**
 * Object contain charges and credits related to electricity usage
 * @export
 * @interface EnergyInvoiceAccountCharges
 */
export interface EnergyInvoiceAccountCharges {
  /**
   * The aggregate total of account level charges for the period covered by the invoice
   * @type {string}
   * @memberof EnergyInvoiceAccountCharges
   */
  totalCharges: string;
  /**
   * The aggregate total of account level discounts or credits for the period covered by the invoice
   * @type {string}
   * @memberof EnergyInvoiceAccountCharges
   */
  totalDiscounts: string;
  /**
   * The total GST for all account level charges.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoiceAccountCharges
   */
  totalGst?: string;
}
/**
 *
 * @export
 * @interface EnergyInvoiceElectricityUsageCharges
 */
export interface EnergyInvoiceElectricityUsageCharges {
  /**
   * The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalUsageCharges: string;
  /**
   * The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalGenerationCredits: string;
  /**
   * The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalOnceOffCharges: string;
  /**
   * The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalOnceOffDiscounts: string;
  /**
   * Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
   * @type {Array<EnergyInvoiceGasUsageChargesOtherCharges>}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  otherCharges?: Array<EnergyInvoiceGasUsageChargesOtherCharges>;
  /**
   * The total GST for all electricity usage charges.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalGst?: string;
}
/**
 *
 * @export
 * @interface EnergyInvoiceGasUsageCharges
 */
export interface EnergyInvoiceGasUsageCharges {
  /**
   * The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalUsageCharges: string;
  /**
   * The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalGenerationCredits: string;
  /**
   * The aggregate total of any once off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalOnceOffCharges: string;
  /**
   * The aggregate total of any once off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalOnceOffDiscounts: string;
  /**
   * Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
   * @type {Array<EnergyInvoiceGasUsageChargesOtherCharges>}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  otherCharges?: Array<EnergyInvoiceGasUsageChargesOtherCharges>;
  /**
   * The total GST for all electricity usage charges.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalGst?: string;
}
/**
 *
 * @export
 * @interface EnergyInvoiceGasUsageChargesOtherCharges
 */
export interface EnergyInvoiceGasUsageChargesOtherCharges {
  /**
   * Type of charge. Assumed to be other if absent
   * @type {string}
   * @memberof EnergyInvoiceGasUsageChargesOtherCharges
   */
  type?: EnergyInvoiceGasUsageChargesOtherChargesTypeEnum;
  /**
   * The aggregate total of charges for this item (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageChargesOtherCharges
   */
  amount: string;
  /**
   * A free text description of the type of charge
   * @type {string}
   * @memberof EnergyInvoiceGasUsageChargesOtherCharges
   */
  description: string;
}

export const EnergyInvoiceGasUsageChargesOtherChargesTypeEnum = {
  Environmental: 'ENVIRONMENTAL',
  Regulated: 'REGULATED',
  Network: 'NETWORK',
  Metering: 'METERING',
  RetailService: 'RETAIL_SERVICE',
  Rcti: 'RCTI',
  Other: 'OTHER',
} as const;

export type EnergyInvoiceGasUsageChargesOtherChargesTypeEnum =
  typeof EnergyInvoiceGasUsageChargesOtherChargesTypeEnum[keyof typeof EnergyInvoiceGasUsageChargesOtherChargesTypeEnum];

/**
 *
 * @export
 * @interface EnergyInvoiceList
 */
export interface EnergyInvoiceList {
  /**
   *
   * @type {EnergyInvoiceListData}
   * @memberof EnergyInvoiceList
   */
  data: EnergyInvoiceListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyInvoiceList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyInvoiceList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyInvoiceListData
 */
export interface EnergyInvoiceListData {
  /**
   * Array of invoices sorted by issue date in descending order
   * @type {Array<EnergyInvoice>}
   * @memberof EnergyInvoiceListData
   */
  invoices: Array<EnergyInvoice>;
}
/**
 * A discount for on time payment
 * @export
 * @interface EnergyInvoicePayOnTimeDiscount
 */
export interface EnergyInvoicePayOnTimeDiscount {
  /**
   * The amount that will be discounted if the invoice is paid by the date specified
   * @type {string}
   * @memberof EnergyInvoicePayOnTimeDiscount
   */
  discountAmount: string;
  /**
   * The GST amount that will be discounted if the invoice is paid by the date specified.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoicePayOnTimeDiscount
   */
  gstAmount?: string;
  /**
   * The date by which the invoice must be paid to receive the pay on time discount
   * @type {string}
   * @memberof EnergyInvoicePayOnTimeDiscount
   */
  date: string;
}
/**
 * Object containing the start and end date for the period covered by the invoice.  Mandatory if any usage or demand based charges are included in the invoice
 * @export
 * @interface EnergyInvoicePeriod
 */
export interface EnergyInvoicePeriod {
  /**
   * The start date of the period covered by this invoice
   * @type {string}
   * @memberof EnergyInvoicePeriod
   */
  startDate: string;
  /**
   * The end date of the period covered by this invoice
   * @type {string}
   * @memberof EnergyInvoicePeriod
   */
  endDate: string;
}
/**
 *
 * @export
 * @interface EnergyPaymentSchedule
 */
export interface EnergyPaymentSchedule {
  /**
   * Optional payment amount indicating that a constant payment amount is scheduled to be paid (used in bill smooting scenarios)
   * @type {string}
   * @memberof EnergyPaymentSchedule
   */
  amount?: string;
  /**
   * The type of object present in this response
   * @type {string}
   * @memberof EnergyPaymentSchedule
   */
  paymentScheduleUType: EnergyPaymentSchedulePaymentScheduleUTypeEnum;
  /**
   *
   * @type {EnergyPaymentScheduleCardDebit}
   * @memberof EnergyPaymentSchedule
   */
  cardDebit?: EnergyPaymentScheduleCardDebit;
  /**
   *
   * @type {EnergyPaymentScheduleDirectDebit}
   * @memberof EnergyPaymentSchedule
   */
  directDebit?: EnergyPaymentScheduleDirectDebit;
  /**
   *
   * @type {EnergyPaymentScheduleDigitalWallet}
   * @memberof EnergyPaymentSchedule
   */
  digitalWallet?: EnergyPaymentScheduleDigitalWallet;
  /**
   *
   * @type {EnergyPaymentScheduleManualPayment}
   * @memberof EnergyPaymentSchedule
   */
  manualPayment?: EnergyPaymentScheduleManualPayment;
}

export const EnergyPaymentSchedulePaymentScheduleUTypeEnum = {
  CardDebit: 'cardDebit',
  DirectDebit: 'directDebit',
  ManualPayment: 'manualPayment',
  DigitalWallet: 'digitalWallet',
} as const;

export type EnergyPaymentSchedulePaymentScheduleUTypeEnum =
  typeof EnergyPaymentSchedulePaymentScheduleUTypeEnum[keyof typeof EnergyPaymentSchedulePaymentScheduleUTypeEnum];

/**
 * Represents a regular credit card payment schedule. Mandatory if paymentScheduleUType is set to cardDebit
 * @export
 * @interface EnergyPaymentScheduleCardDebit
 */
export interface EnergyPaymentScheduleCardDebit {
  /**
   * The type of credit card held on file
   * @type {string}
   * @memberof EnergyPaymentScheduleCardDebit
   */
  cardScheme: EnergyPaymentScheduleCardDebitCardSchemeEnum;
  /**
   * The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPaymentScheduleCardDebit
   */
  paymentFrequency: string;
  /**
   * The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
   * @type {string}
   * @memberof EnergyPaymentScheduleCardDebit
   */
  calculationType: EnergyPaymentScheduleCardDebitCalculationTypeEnum;
}

export const EnergyPaymentScheduleCardDebitCardSchemeEnum = {
  Visa: 'VISA',
  Mastercard: 'MASTERCARD',
  Amex: 'AMEX',
  Diners: 'DINERS',
  Other: 'OTHER',
  Unknown: 'UNKNOWN',
} as const;

export type EnergyPaymentScheduleCardDebitCardSchemeEnum =
  typeof EnergyPaymentScheduleCardDebitCardSchemeEnum[keyof typeof EnergyPaymentScheduleCardDebitCardSchemeEnum];
export const EnergyPaymentScheduleCardDebitCalculationTypeEnum = {
  Static: 'STATIC',
  Balance: 'BALANCE',
  Calculated: 'CALCULATED',
} as const;

export type EnergyPaymentScheduleCardDebitCalculationTypeEnum =
  typeof EnergyPaymentScheduleCardDebitCalculationTypeEnum[keyof typeof EnergyPaymentScheduleCardDebitCalculationTypeEnum];

/**
 * Represents a regular payment from a digital wallet. Mandatory if paymentScheduleUType is set to digitalWallet
 * @export
 * @interface EnergyPaymentScheduleDigitalWallet
 */
export interface EnergyPaymentScheduleDigitalWallet {
  /**
   * The name assigned to the digital wallet by the owner of the wallet, else the display name provided by the digital wallet provider
   * @type {string}
   * @memberof EnergyPaymentScheduleDigitalWallet
   */
  name: string;
  /**
   * The identifier of the digital wallet (dependent on type)
   * @type {string}
   * @memberof EnergyPaymentScheduleDigitalWallet
   */
  identifier: string;
  /**
   * The type of the digital wallet identifier
   * @type {string}
   * @memberof EnergyPaymentScheduleDigitalWallet
   */
  type: EnergyPaymentScheduleDigitalWalletTypeEnum;
  /**
   * The provider of the digital wallet
   * @type {string}
   * @memberof EnergyPaymentScheduleDigitalWallet
   */
  provider: EnergyPaymentScheduleDigitalWalletProviderEnum;
  /**
   * The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPaymentScheduleDigitalWallet
   */
  paymentFrequency: string;
  /**
   * The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
   * @type {string}
   * @memberof EnergyPaymentScheduleDigitalWallet
   */
  calculationType: EnergyPaymentScheduleDigitalWalletCalculationTypeEnum;
}

export const EnergyPaymentScheduleDigitalWalletTypeEnum = {
  Email: 'EMAIL',
  ContactName: 'CONTACT_NAME',
  Telephone: 'TELEPHONE',
} as const;

export type EnergyPaymentScheduleDigitalWalletTypeEnum =
  typeof EnergyPaymentScheduleDigitalWalletTypeEnum[keyof typeof EnergyPaymentScheduleDigitalWalletTypeEnum];
export const EnergyPaymentScheduleDigitalWalletProviderEnum = {
  PaypalAu: 'PAYPAL_AU',
  Other: 'OTHER',
} as const;

export type EnergyPaymentScheduleDigitalWalletProviderEnum =
  typeof EnergyPaymentScheduleDigitalWalletProviderEnum[keyof typeof EnergyPaymentScheduleDigitalWalletProviderEnum];
export const EnergyPaymentScheduleDigitalWalletCalculationTypeEnum = {
  Static: 'STATIC',
  Balance: 'BALANCE',
  Calculated: 'CALCULATED',
} as const;

export type EnergyPaymentScheduleDigitalWalletCalculationTypeEnum =
  typeof EnergyPaymentScheduleDigitalWalletCalculationTypeEnum[keyof typeof EnergyPaymentScheduleDigitalWalletCalculationTypeEnum];

/**
 * Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
 * @export
 * @interface EnergyPaymentScheduleDirectDebit
 */
export interface EnergyPaymentScheduleDirectDebit {
  /**
   * Flag indicating that the account details are tokenised and cannot be shared.  False if absent
   * @type {boolean}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  isTokenised?: boolean;
  /**
   * The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  bsb?: string;
  /**
   * The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  accountNumber?: string;
  /**
   * The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  paymentFrequency: string;
  /**
   * The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  calculationType: EnergyPaymentScheduleDirectDebitCalculationTypeEnum;
}

export const EnergyPaymentScheduleDirectDebitCalculationTypeEnum = {
  Static: 'STATIC',
  Balance: 'BALANCE',
  Calculated: 'CALCULATED',
} as const;

export type EnergyPaymentScheduleDirectDebitCalculationTypeEnum =
  typeof EnergyPaymentScheduleDirectDebitCalculationTypeEnum[keyof typeof EnergyPaymentScheduleDirectDebitCalculationTypeEnum];

/**
 * Represents a manual payment schedule where the customer pays in response to a delivered statement. Mandatory if paymentScheduleUType is set to manualPayment
 * @export
 * @interface EnergyPaymentScheduleManualPayment
 */
export interface EnergyPaymentScheduleManualPayment {
  /**
   * The frequency with which a bill will be issued.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPaymentScheduleManualPayment
   */
  billFrequency: string;
}
/**
 *
 * @export
 * @interface EnergyPlan
 */
export interface EnergyPlan {
  /**
   * The ID of the specific plan
   * @type {string}
   * @memberof EnergyPlan
   */
  planId: string;
  /**
   * The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
   * @type {string}
   * @memberof EnergyPlan
   */
  effectiveFrom?: string;
  /**
   * The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
   * @type {string}
   * @memberof EnergyPlan
   */
  effectiveTo?: string;
  /**
   * The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
   * @type {string}
   * @memberof EnergyPlan
   */
  lastUpdated: string;
  /**
   * The display name of the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  displayName?: string;
  /**
   * A description of the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  description?: string;
  /**
   * The type of the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  type: EnergyPlanTypeEnum;
  /**
   * The fuel types covered by the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  fuelType: EnergyPlanFuelTypeEnum;
  /**
   * The ID of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlan
   */
  brand: string;
  /**
   * The display name of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlan
   */
  brandName: string;
  /**
   * A link to an application web page where this plan can be applied for
   * @type {string}
   * @memberof EnergyPlan
   */
  applicationUri?: string;
  /**
   *
   * @type {EnergyPlanAdditionalInformation}
   * @memberof EnergyPlan
   */
  additionalInformation?: EnergyPlanAdditionalInformation;
  /**
   * The type of customer that the plan is offered to.  If absent then the plan is available to all customers
   * @type {string}
   * @memberof EnergyPlan
   */
  customerType?: EnergyPlanCustomerTypeEnum;
  /**
   *
   * @type {EnergyPlanGeography}
   * @memberof EnergyPlan
   */
  geography?: EnergyPlanGeography;
}

export const EnergyPlanTypeEnum = {
  Standing: 'STANDING',
  Market: 'MARKET',
  Regulated: 'REGULATED',
} as const;

export type EnergyPlanTypeEnum = typeof EnergyPlanTypeEnum[keyof typeof EnergyPlanTypeEnum];
export const EnergyPlanFuelTypeEnum = {
  Electricity: 'ELECTRICITY',
  Gas: 'GAS',
  Dual: 'DUAL',
} as const;

export type EnergyPlanFuelTypeEnum = typeof EnergyPlanFuelTypeEnum[keyof typeof EnergyPlanFuelTypeEnum];
export const EnergyPlanCustomerTypeEnum = {
  Residential: 'RESIDENTIAL',
  Business: 'BUSINESS',
} as const;

export type EnergyPlanCustomerTypeEnum = typeof EnergyPlanCustomerTypeEnum[keyof typeof EnergyPlanCustomerTypeEnum];

/**
 * Object that contains links to additional information on specific topics
 * @export
 * @interface EnergyPlanAdditionalInformation
 */
export interface EnergyPlanAdditionalInformation {
  /**
   * A link to a general overview of the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  overviewUri?: string;
  /**
   * A link to terms and conditions for the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  termsUri?: string;
  /**
   * A link to detail on eligibility criteria for the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  eligibilityUri?: string;
  /**
   * A link to detail on pricing for the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  pricingUri?: string;
  /**
   * A link to detail on bundles that this plan can be a part of
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  bundleUri?: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContract
 */
export interface EnergyPlanContract {
  /**
   * Free text field containing additional information of the fees for this contract
   * @type {string}
   * @memberof EnergyPlanContract
   */
  additionalFeeInformation?: string;
  /**
   * The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
   * @type {string}
   * @memberof EnergyPlanContract
   */
  pricingModel: EnergyPlanContractPricingModelEnum;
  /**
   * Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
   * @type {string}
   * @memberof EnergyPlanContract
   */
  timeZone?: EnergyPlanContractTimeZoneEnum;
  /**
   * Flag indicating whether prices are fixed or variable
   * @type {boolean}
   * @memberof EnergyPlanContract
   */
  isFixed: boolean;
  /**
   * Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
   * @type {string}
   * @memberof EnergyPlanContract
   */
  variation?: string;
  /**
   * Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
   * @type {string}
   * @memberof EnergyPlanContract
   */
  onExpiryDescription?: string;
  /**
   * Payment options for this contract
   * @type {Array<string>}
   * @memberof EnergyPlanContract
   */
  paymentOption: Array<EnergyPlanContractPaymentOptionEnum>;
  /**
   *
   * @type {EnergyPlanContractIntrinsicGreenPower}
   * @memberof EnergyPlanContract
   */
  intrinsicGreenPower?: EnergyPlanContractIntrinsicGreenPower;
  /**
   * Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
   * @type {Array<EnergyPlanContractControlledLoadInner>}
   * @memberof EnergyPlanContract
   */
  controlledLoad?: Array<EnergyPlanContractControlledLoadInner>;
  /**
   * Optional list of incentives available for the contract
   * @type {Array<EnergyPlanContractIncentivesInner>}
   * @memberof EnergyPlanContract
   */
  incentives?: Array<EnergyPlanContractIncentivesInner>;
  /**
   * Optional list of discounts available for the contract
   * @type {Array<EnergyPlanContractDiscountsInner>}
   * @memberof EnergyPlanContract
   */
  discounts?: Array<EnergyPlanContractDiscountsInner>;
  /**
   * Optional list of charges applicable to green power
   * @type {Array<EnergyPlanContractGreenPowerChargesInner>}
   * @memberof EnergyPlanContract
   */
  greenPowerCharges?: Array<EnergyPlanContractGreenPowerChargesInner>;
  /**
   * Eligibility restrictions or requirements
   * @type {Array<EnergyPlanContractEligibilityInner>}
   * @memberof EnergyPlanContract
   */
  eligibility?: Array<EnergyPlanContractEligibilityInner>;
  /**
   * An array of fees applicable to the plan
   * @type {Array<EnergyPlanContractFeesInner>}
   * @memberof EnergyPlanContract
   */
  fees?: Array<EnergyPlanContractFeesInner>;
  /**
   * Array of feed in tariffs for solar power
   * @type {Array<EnergyPlanContractSolarFeedInTariffInner>}
   * @memberof EnergyPlanContract
   */
  solarFeedInTariff?: Array<EnergyPlanContractSolarFeedInTariffInner>;
  /**
   * Array of tariff periods
   * @type {Array<EnergyPlanContractTariffPeriodInner>}
   * @memberof EnergyPlanContract
   */
  tariffPeriod: Array<EnergyPlanContractTariffPeriodInner>;
}

export const EnergyPlanContractPricingModelEnum = {
  SingleRate: 'SINGLE_RATE',
  SingleRateContLoad: 'SINGLE_RATE_CONT_LOAD',
  TimeOfUse: 'TIME_OF_USE',
  TimeOfUseContLoad: 'TIME_OF_USE_CONT_LOAD',
  Flexible: 'FLEXIBLE',
  FlexibleContLoad: 'FLEXIBLE_CONT_LOAD',
  Quota: 'QUOTA',
} as const;

export type EnergyPlanContractPricingModelEnum =
  typeof EnergyPlanContractPricingModelEnum[keyof typeof EnergyPlanContractPricingModelEnum];
export const EnergyPlanContractTimeZoneEnum = {
  Local: 'LOCAL',
  Aest: 'AEST',
} as const;

export type EnergyPlanContractTimeZoneEnum =
  typeof EnergyPlanContractTimeZoneEnum[keyof typeof EnergyPlanContractTimeZoneEnum];
export const EnergyPlanContractPaymentOptionEnum = {
  PaperBill: 'PAPER_BILL',
  CreditCard: 'CREDIT_CARD',
  DirectDebit: 'DIRECT_DEBIT',
  Bpay: 'BPAY',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractPaymentOptionEnum =
  typeof EnergyPlanContractPaymentOptionEnum[keyof typeof EnergyPlanContractPaymentOptionEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractControlledLoadInner
 */
export interface EnergyPlanContractControlledLoadInner {
  /**
   * A display name for the controlled load
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInner
   */
  displayName: string;
  /**
   * Specifies the type of controlloed load rate
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInner
   */
  rateBlockUType: EnergyPlanContractControlledLoadInnerRateBlockUTypeEnum;
  /**
   * Optional start date of the application of the controlled load rate
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInner
   */
  startDate?: string;
  /**
   * Optional end date of the application of the controlled load rate
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInner
   */
  endDate?: string;
  /**
   *
   * @type {EnergyPlanContractControlledLoadInnerSingleRate}
   * @memberof EnergyPlanContractControlledLoadInner
   */
  singleRate?: EnergyPlanContractControlledLoadInnerSingleRate;
  /**
   * Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
   * @type {Array<EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner>}
   * @memberof EnergyPlanContractControlledLoadInner
   */
  timeOfUseRates?: Array<EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner>;
}

export const EnergyPlanContractControlledLoadInnerRateBlockUTypeEnum = {
  SingleRate: 'singleRate',
  TimeOfUseRates: 'timeOfUseRates',
} as const;

export type EnergyPlanContractControlledLoadInnerRateBlockUTypeEnum =
  typeof EnergyPlanContractControlledLoadInnerRateBlockUTypeEnum[keyof typeof EnergyPlanContractControlledLoadInnerRateBlockUTypeEnum];

/**
 * Object representing a single controlled load rate.  Required if rateBlockUType is singleRate
 * @export
 * @interface EnergyPlanContractControlledLoadInnerSingleRate
 */
export interface EnergyPlanContractControlledLoadInnerSingleRate {
  /**
   * Display name of the controlled load rate
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerSingleRate
   */
  displayName: string;
  /**
   * Description of the controlled load rate
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerSingleRate
   */
  description?: string;
  /**
   * The daily supply charge (exclusive of GST) for this controlled load tier
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerSingleRate
   */
  dailySupplyCharge?: string;
  /**
   * Array of controlled load rates in order of usage volume
   * @type {Array<EnergyPlanContractControlledLoadInnerSingleRateRatesInner>}
   * @memberof EnergyPlanContractControlledLoadInnerSingleRate
   */
  rates: Array<EnergyPlanContractControlledLoadInnerSingleRateRatesInner>;
}
/**
 *
 * @export
 * @interface EnergyPlanContractControlledLoadInnerSingleRateRatesInner
 */
export interface EnergyPlanContractControlledLoadInnerSingleRateRatesInner {
  /**
   * Unit price of usage per  measure unit (exclusive of GST)
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerSingleRateRatesInner
   */
  unitPrice: string;
  /**
   * The measurement unit of rate. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerSingleRateRatesInner
   */
  measureUnit?: EnergyPlanContractControlledLoadInnerSingleRateRatesInnerMeasureUnitEnum;
  /**
   * Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
   * @type {number}
   * @memberof EnergyPlanContractControlledLoadInnerSingleRateRatesInner
   */
  volume?: number;
}

export const EnergyPlanContractControlledLoadInnerSingleRateRatesInnerMeasureUnitEnum = {
  Kwh: 'KWH',
  Kva: 'KVA',
  Kvar: 'KVAR',
  Kvarh: 'KVARH',
  Kw: 'KW',
  Days: 'DAYS',
  Meter: 'METER',
  Month: 'MONTH',
} as const;

export type EnergyPlanContractControlledLoadInnerSingleRateRatesInnerMeasureUnitEnum =
  typeof EnergyPlanContractControlledLoadInnerSingleRateRatesInnerMeasureUnitEnum[keyof typeof EnergyPlanContractControlledLoadInnerSingleRateRatesInnerMeasureUnitEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner
 */
export interface EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner {
  /**
   * Display name of the controlled load rate
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner
   */
  displayName: string;
  /**
   * Description of the controlled load rate
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner
   */
  description?: string;
  /**
   * The daily supply charge (exclusive of GST) for this controlled load tier
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner
   */
  dailySupplyCharge?: string;
  /**
   * Array of controlled load rates in order of usage volume
   * @type {Array<EnergyPlanContractControlledLoadInnerSingleRateRatesInner>}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner
   */
  rates: Array<EnergyPlanContractControlledLoadInnerSingleRateRatesInner>;
  /**
   * Array of times of use.
   * @type {Array<EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner>}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner
   */
  timeOfUse: Array<EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner>;
  /**
   * The type of usage that the rate applies to
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInner
   */
  type: EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTypeEnum;
}

export const EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTypeEnum = {
  Peak: 'PEAK',
  OffPeak: 'OFF_PEAK',
  Shoulder: 'SHOULDER',
  SolarSponge: 'SOLAR_SPONGE',
} as const;

export type EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTypeEnum =
  typeof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTypeEnum[keyof typeof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner
 */
export interface EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner {
  /**
   * The days that the rate applies to
   * @type {Array<string>}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  days?: Array<EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum>;
  /**
   * The beginning of the time period per day for which the controlled load rate applies. Required if endTime provided
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  startTime?: string;
  /**
   * The end of the time period per day for which the controlled load rate applies. Required if startTime provided
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  endTime?: string;
  /**
   * Display text providing more information on the contrlled load, for e.g. controlled load availability if specific day/time is not known. Required if startTime and endTime absent or if additionalInfoUri provided
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  additionalInfo?: string;
  /**
   * Optional link to additional information regarding the controlled load
   * @type {string}
   * @memberof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  additionalInfoUri?: string;
}

export const EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum = {
  Sun: 'SUN',
  Mon: 'MON',
  Tue: 'TUE',
  Wed: 'WED',
  Thu: 'THU',
  Fri: 'FRI',
  Sat: 'SAT',
  PublicHolidays: 'PUBLIC_HOLIDAYS',
} as const;

export type EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum =
  typeof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum[keyof typeof EnergyPlanContractControlledLoadInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractDiscountsInner
 */
export interface EnergyPlanContractDiscountsInner {
  /**
   * The display name of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInner
   */
  displayName: string;
  /**
   * The description of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInner
   */
  description?: string;
  /**
   * The type of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInner
   */
  type: EnergyPlanContractDiscountsInnerTypeEnum;
  /**
   * The type of the discount.  Mandatory if the discount type is CONDITIONAL
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInner
   */
  category?: EnergyPlanContractDiscountsInnerCategoryEnum;
  /**
   * Optional end date for the discount after which the discount is no longer available
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInner
   */
  endDate?: string;
  /**
   * The method of calculation of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInner
   */
  methodUType: EnergyPlanContractDiscountsInnerMethodUTypeEnum;
  /**
   *
   * @type {EnergyPlanContractDiscountsInnerPercentOfBill}
   * @memberof EnergyPlanContractDiscountsInner
   */
  percentOfBill?: EnergyPlanContractDiscountsInnerPercentOfBill;
  /**
   *
   * @type {EnergyPlanContractDiscountsInnerPercentOfUse}
   * @memberof EnergyPlanContractDiscountsInner
   */
  percentOfUse?: EnergyPlanContractDiscountsInnerPercentOfUse;
  /**
   *
   * @type {EnergyPlanContractDiscountsInnerFixedAmount}
   * @memberof EnergyPlanContractDiscountsInner
   */
  fixedAmount?: EnergyPlanContractDiscountsInnerFixedAmount;
  /**
   *
   * @type {EnergyPlanContractDiscountsInnerPercentOverThreshold}
   * @memberof EnergyPlanContractDiscountsInner
   */
  percentOverThreshold?: EnergyPlanContractDiscountsInnerPercentOverThreshold;
}

export const EnergyPlanContractDiscountsInnerTypeEnum = {
  Conditional: 'CONDITIONAL',
  Guaranteed: 'GUARANTEED',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractDiscountsInnerTypeEnum =
  typeof EnergyPlanContractDiscountsInnerTypeEnum[keyof typeof EnergyPlanContractDiscountsInnerTypeEnum];
export const EnergyPlanContractDiscountsInnerCategoryEnum = {
  PayOnTime: 'PAY_ON_TIME',
  DirectDebit: 'DIRECT_DEBIT',
  GuaranteedDiscount: 'GUARANTEED_DISCOUNT',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractDiscountsInnerCategoryEnum =
  typeof EnergyPlanContractDiscountsInnerCategoryEnum[keyof typeof EnergyPlanContractDiscountsInnerCategoryEnum];
export const EnergyPlanContractDiscountsInnerMethodUTypeEnum = {
  PercentOfBill: 'percentOfBill',
  PercentOfUse: 'percentOfUse',
  FixedAmount: 'fixedAmount',
  PercentOverThreshold: 'percentOverThreshold',
} as const;

export type EnergyPlanContractDiscountsInnerMethodUTypeEnum =
  typeof EnergyPlanContractDiscountsInnerMethodUTypeEnum[keyof typeof EnergyPlanContractDiscountsInnerMethodUTypeEnum];

/**
 * Required if methodUType is fixedAmount
 * @export
 * @interface EnergyPlanContractDiscountsInnerFixedAmount
 */
export interface EnergyPlanContractDiscountsInnerFixedAmount {
  /**
   * The amount of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInnerFixedAmount
   */
  amount: string;
}
/**
 * Required if methodUType is percentOfBill
 * @export
 * @interface EnergyPlanContractDiscountsInnerPercentOfBill
 */
export interface EnergyPlanContractDiscountsInnerPercentOfBill {
  /**
   * The rate of the discount applied to the bill amount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInnerPercentOfBill
   */
  rate: string;
}
/**
 * Required if methodUType is percentOfUse
 * @export
 * @interface EnergyPlanContractDiscountsInnerPercentOfUse
 */
export interface EnergyPlanContractDiscountsInnerPercentOfUse {
  /**
   * The rate of the discount applied to the usageamount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInnerPercentOfUse
   */
  rate: string;
}
/**
 * Required if methodUType is percentOverThreshold
 * @export
 * @interface EnergyPlanContractDiscountsInnerPercentOverThreshold
 */
export interface EnergyPlanContractDiscountsInnerPercentOverThreshold {
  /**
   * The rate of the discount over the usage amount
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInnerPercentOverThreshold
   */
  rate: string;
  /**
   * The usage amount threshold above which the discount applies
   * @type {string}
   * @memberof EnergyPlanContractDiscountsInnerPercentOverThreshold
   */
  usageAmount: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractEligibilityInner
 */
export interface EnergyPlanContractEligibilityInner {
  /**
   * The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
   * @type {string}
   * @memberof EnergyPlanContractEligibilityInner
   */
  type: EnergyPlanContractEligibilityInnerTypeEnum;
  /**
   * Information of the eligibility restriction specific to the type of the restriction
   * @type {string}
   * @memberof EnergyPlanContractEligibilityInner
   */
  information: string;
  /**
   * A description of the eligibility restriction
   * @type {string}
   * @memberof EnergyPlanContractEligibilityInner
   */
  description?: string;
}

export const EnergyPlanContractEligibilityInnerTypeEnum = {
  ExistingCust: 'EXISTING_CUST',
  ExistingPool: 'EXISTING_POOL',
  ExistingSolar: 'EXISTING_SOLAR',
  ExistingBattery: 'EXISTING_BATTERY',
  ExistingSmartMeter: 'EXISTING_SMART_METER',
  ExistingBasicMeter: 'EXISTING_BASIC_METER',
  SeniorCard: 'SENIOR_CARD',
  SmallBusiness: 'SMALL_BUSINESS',
  NoSolarFit: 'NO_SOLAR_FIT',
  NewCustomer: 'NEW_CUSTOMER',
  OnlineOnly: 'ONLINE_ONLY',
  ReqEquipSupplier: 'REQ_EQUIP_SUPPLIER',
  ThirdPartyOnly: 'THIRD_PARTY_ONLY',
  SportClubMember: 'SPORT_CLUB_MEMBER',
  OrgMember: 'ORG_MEMBER',
  SpecificLocation: 'SPECIFIC_LOCATION',
  MinimumUsage: 'MINIMUM_USAGE',
  LoyaltyMember: 'LOYALTY_MEMBER',
  GroupBuyMember: 'GROUP_BUY_MEMBER',
  ContingentPlan: 'CONTINGENT_PLAN',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractEligibilityInnerTypeEnum =
  typeof EnergyPlanContractEligibilityInnerTypeEnum[keyof typeof EnergyPlanContractEligibilityInnerTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractFeesInner
 */
export interface EnergyPlanContractFeesInner {
  /**
   * The type of the fee
   * @type {string}
   * @memberof EnergyPlanContractFeesInner
   */
  type: EnergyPlanContractFeesInnerTypeEnum;
  /**
   * The term of the fee
   * @type {string}
   * @memberof EnergyPlanContractFeesInner
   */
  term: EnergyPlanContractFeesInnerTermEnum;
  /**
   * The fee amount. Required if term is not PERCENT_OF_BILL
   * @type {string}
   * @memberof EnergyPlanContractFeesInner
   */
  amount?: string;
  /**
   * The fee rate. Required if term is PERCENT_OF_BILL
   * @type {string}
   * @memberof EnergyPlanContractFeesInner
   */
  rate?: string;
  /**
   * A description of the fee
   * @type {string}
   * @memberof EnergyPlanContractFeesInner
   */
  description?: string;
}

export const EnergyPlanContractFeesInnerTypeEnum = {
  Exit: 'EXIT',
  Establishment: 'ESTABLISHMENT',
  LatePayment: 'LATE_PAYMENT',
  Disconnection: 'DISCONNECTION',
  DisconnectMoveOut: 'DISCONNECT_MOVE_OUT',
  DisconnectNonPay: 'DISCONNECT_NON_PAY',
  Reconnection: 'RECONNECTION',
  Connection: 'CONNECTION',
  PaymentProcessing: 'PAYMENT_PROCESSING',
  CcProcessing: 'CC_PROCESSING',
  ChequeDishonour: 'CHEQUE_DISHONOUR',
  DdDishonour: 'DD_DISHONOUR',
  Membership: 'MEMBERSHIP',
  Contribution: 'CONTRIBUTION',
  PaperBill: 'PAPER_BILL',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractFeesInnerTypeEnum =
  typeof EnergyPlanContractFeesInnerTypeEnum[keyof typeof EnergyPlanContractFeesInnerTypeEnum];
export const EnergyPlanContractFeesInnerTermEnum = {
  Fixed: 'FIXED',
  _1Year: '1_YEAR',
  _2Year: '2_YEAR',
  _3Year: '3_YEAR',
  _4Year: '4_YEAR',
  _5Year: '5_YEAR',
  PercentOfBill: 'PERCENT_OF_BILL',
  Annual: 'ANNUAL',
  Daily: 'DAILY',
  Weekly: 'WEEKLY',
  Monthly: 'MONTHLY',
  Biannual: 'BIANNUAL',
  Variable: 'VARIABLE',
} as const;

export type EnergyPlanContractFeesInnerTermEnum =
  typeof EnergyPlanContractFeesInnerTermEnum[keyof typeof EnergyPlanContractFeesInnerTermEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractFull
 */
export interface EnergyPlanContractFull {
  /**
   * Free text field containing additional information of the fees for this contract
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  additionalFeeInformation?: string;
  /**
   * The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE** - energy usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE** - energy usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  pricingModel: EnergyPlanContractFullPricingModelEnum;
  /**
   * Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds. Defaults to AEST if absent
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  timeZone?: EnergyPlanContractFullTimeZoneEnum;
  /**
   * Flag indicating whether prices are fixed or variable
   * @type {boolean}
   * @memberof EnergyPlanContractFull
   */
  isFixed: boolean;
  /**
   * Free text description of price variation policy and conditions for the contract.  Mandatory if `isFixed` is false
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  variation?: string;
  /**
   * Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  onExpiryDescription?: string;
  /**
   * Payment options for this contract
   * @type {Array<string>}
   * @memberof EnergyPlanContractFull
   */
  paymentOption: Array<EnergyPlanContractFullPaymentOptionEnum>;
  /**
   *
   * @type {EnergyPlanContractIntrinsicGreenPower}
   * @memberof EnergyPlanContractFull
   */
  intrinsicGreenPower?: EnergyPlanContractIntrinsicGreenPower;
  /**
   * Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
   * @type {Array<EnergyPlanContractControlledLoadInner>}
   * @memberof EnergyPlanContractFull
   */
  controlledLoad?: Array<EnergyPlanContractControlledLoadInner>;
  /**
   * Optional list of incentives available for the contract
   * @type {Array<EnergyPlanContractIncentivesInner>}
   * @memberof EnergyPlanContractFull
   */
  incentives?: Array<EnergyPlanContractIncentivesInner>;
  /**
   * Optional list of discounts available for the contract
   * @type {Array<EnergyPlanContractDiscountsInner>}
   * @memberof EnergyPlanContractFull
   */
  discounts?: Array<EnergyPlanContractDiscountsInner>;
  /**
   * Optional list of charges applicable to green power
   * @type {Array<EnergyPlanContractGreenPowerChargesInner>}
   * @memberof EnergyPlanContractFull
   */
  greenPowerCharges?: Array<EnergyPlanContractGreenPowerChargesInner>;
  /**
   * Eligibility restrictions or requirements
   * @type {Array<EnergyPlanContractEligibilityInner>}
   * @memberof EnergyPlanContractFull
   */
  eligibility?: Array<EnergyPlanContractEligibilityInner>;
  /**
   * An array of fees applicable to the plan
   * @type {Array<EnergyPlanContractFeesInner>}
   * @memberof EnergyPlanContractFull
   */
  fees?: Array<EnergyPlanContractFeesInner>;
  /**
   * Array of feed in tariffs for solar power
   * @type {Array<EnergyPlanContractSolarFeedInTariffInner>}
   * @memberof EnergyPlanContractFull
   */
  solarFeedInTariff?: Array<EnergyPlanContractSolarFeedInTariffInner>;
  /**
   * Array of tariff periods
   * @type {Array<EnergyPlanContractTariffPeriodInner>}
   * @memberof EnergyPlanContractFull
   */
  tariffPeriod: Array<EnergyPlanContractTariffPeriodInner>;
  /**
   * The term for the contract.  If absent assumes no specified term
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  termType?: EnergyPlanContractFullTermTypeEnum;
  /**
   * Description of the benefit period.  Should only be present if termType has the value ONGOING
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  benefitPeriod?: string;
  /**
   * Free text description of the terms for the contract
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  terms?: string;
  /**
   * An array of the meter types that this contract is available for
   * @type {Array<string>}
   * @memberof EnergyPlanContractFull
   */
  meterTypes?: Array<string>;
  /**
   * Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
   * @type {number}
   * @memberof EnergyPlanContractFull
   */
  coolingOffDays?: number;
  /**
   * An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {Array<string>}
   * @memberof EnergyPlanContractFull
   */
  billFrequency: Array<string>;
}

export const EnergyPlanContractFullPricingModelEnum = {
  SingleRate: 'SINGLE_RATE',
  SingleRateContLoad: 'SINGLE_RATE_CONT_LOAD',
  TimeOfUse: 'TIME_OF_USE',
  TimeOfUseContLoad: 'TIME_OF_USE_CONT_LOAD',
  Flexible: 'FLEXIBLE',
  FlexibleContLoad: 'FLEXIBLE_CONT_LOAD',
  Quota: 'QUOTA',
} as const;

export type EnergyPlanContractFullPricingModelEnum =
  typeof EnergyPlanContractFullPricingModelEnum[keyof typeof EnergyPlanContractFullPricingModelEnum];
export const EnergyPlanContractFullTimeZoneEnum = {
  Local: 'LOCAL',
  Aest: 'AEST',
} as const;

export type EnergyPlanContractFullTimeZoneEnum =
  typeof EnergyPlanContractFullTimeZoneEnum[keyof typeof EnergyPlanContractFullTimeZoneEnum];
export const EnergyPlanContractFullPaymentOptionEnum = {
  PaperBill: 'PAPER_BILL',
  CreditCard: 'CREDIT_CARD',
  DirectDebit: 'DIRECT_DEBIT',
  Bpay: 'BPAY',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractFullPaymentOptionEnum =
  typeof EnergyPlanContractFullPaymentOptionEnum[keyof typeof EnergyPlanContractFullPaymentOptionEnum];
export const EnergyPlanContractFullTermTypeEnum = {
  _1Year: '1_YEAR',
  _2Year: '2_YEAR',
  _3Year: '3_YEAR',
  _4Year: '4_YEAR',
  _5Year: '5_YEAR',
  Ongoing: 'ONGOING',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractFullTermTypeEnum =
  typeof EnergyPlanContractFullTermTypeEnum[keyof typeof EnergyPlanContractFullTermTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractFullAllOf
 */
export interface EnergyPlanContractFullAllOf {
  /**
   * The term for the contract.  If absent assumes no specified term
   * @type {string}
   * @memberof EnergyPlanContractFullAllOf
   */
  termType?: EnergyPlanContractFullAllOfTermTypeEnum;
  /**
   * Description of the benefit period.  Should only be present if termType has the value ONGOING
   * @type {string}
   * @memberof EnergyPlanContractFullAllOf
   */
  benefitPeriod?: string;
  /**
   * Free text description of the terms for the contract
   * @type {string}
   * @memberof EnergyPlanContractFullAllOf
   */
  terms?: string;
  /**
   * An array of the meter types that this contract is available for
   * @type {Array<string>}
   * @memberof EnergyPlanContractFullAllOf
   */
  meterTypes?: Array<string>;
  /**
   * Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
   * @type {number}
   * @memberof EnergyPlanContractFullAllOf
   */
  coolingOffDays?: number;
  /**
   * An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {Array<string>}
   * @memberof EnergyPlanContractFullAllOf
   */
  billFrequency: Array<string>;
}

export const EnergyPlanContractFullAllOfTermTypeEnum = {
  _1Year: '1_YEAR',
  _2Year: '2_YEAR',
  _3Year: '3_YEAR',
  _4Year: '4_YEAR',
  _5Year: '5_YEAR',
  Ongoing: 'ONGOING',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractFullAllOfTermTypeEnum =
  typeof EnergyPlanContractFullAllOfTermTypeEnum[keyof typeof EnergyPlanContractFullAllOfTermTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractGreenPowerChargesInner
 */
export interface EnergyPlanContractGreenPowerChargesInner {
  /**
   * The display name of the charge
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerChargesInner
   */
  displayName: string;
  /**
   * The description of the charge
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerChargesInner
   */
  description?: string;
  /**
   * The applicable green power scheme
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerChargesInner
   */
  scheme: EnergyPlanContractGreenPowerChargesInnerSchemeEnum;
  /**
   * The type of charge
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerChargesInner
   */
  type: EnergyPlanContractGreenPowerChargesInnerTypeEnum;
  /**
   * Array of charge tiers based on the percentage of green power used for the period implied by the type.  Array is in order of increasing percentage of green power
   * @type {Array<EnergyPlanContractGreenPowerChargesInnerTiersInner>}
   * @memberof EnergyPlanContractGreenPowerChargesInner
   */
  tiers: Array<EnergyPlanContractGreenPowerChargesInnerTiersInner>;
}

export const EnergyPlanContractGreenPowerChargesInnerSchemeEnum = {
  Greenpower: 'GREENPOWER',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractGreenPowerChargesInnerSchemeEnum =
  typeof EnergyPlanContractGreenPowerChargesInnerSchemeEnum[keyof typeof EnergyPlanContractGreenPowerChargesInnerSchemeEnum];
export const EnergyPlanContractGreenPowerChargesInnerTypeEnum = {
  FixedPerDay: 'FIXED_PER_DAY',
  FixedPerWeek: 'FIXED_PER_WEEK',
  FixedPerMonth: 'FIXED_PER_MONTH',
  FixedPerUnit: 'FIXED_PER_UNIT',
  PercentOfUse: 'PERCENT_OF_USE',
  PercentOfBill: 'PERCENT_OF_BILL',
} as const;

export type EnergyPlanContractGreenPowerChargesInnerTypeEnum =
  typeof EnergyPlanContractGreenPowerChargesInnerTypeEnum[keyof typeof EnergyPlanContractGreenPowerChargesInnerTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractGreenPowerChargesInnerTiersInner
 */
export interface EnergyPlanContractGreenPowerChargesInnerTiersInner {
  /**
   * The upper percentage of green power used applicable for this tier
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerChargesInnerTiersInner
   */
  percentGreen: string;
  /**
   * The rate of the charge if the type implies the application of a rate
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerChargesInnerTiersInner
   */
  rate?: string;
  /**
   * The amount of the charge if the type implies the application of a fixed amount
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerChargesInnerTiersInner
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractIncentivesInner
 */
export interface EnergyPlanContractIncentivesInner {
  /**
   * The display name of the incentive
   * @type {string}
   * @memberof EnergyPlanContractIncentivesInner
   */
  displayName: string;
  /**
   * The description of the incentive
   * @type {string}
   * @memberof EnergyPlanContractIncentivesInner
   */
  description: string;
  /**
   * The type of the incentive
   * @type {string}
   * @memberof EnergyPlanContractIncentivesInner
   */
  category: EnergyPlanContractIncentivesInnerCategoryEnum;
  /**
   * A display message outlining an eligibility criteria that may apply
   * @type {string}
   * @memberof EnergyPlanContractIncentivesInner
   */
  eligibility?: string;
}

export const EnergyPlanContractIncentivesInnerCategoryEnum = {
  Gift: 'GIFT',
  AccountCredit: 'ACCOUNT_CREDIT',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractIncentivesInnerCategoryEnum =
  typeof EnergyPlanContractIncentivesInnerCategoryEnum[keyof typeof EnergyPlanContractIncentivesInnerCategoryEnum];

/**
 * Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
 * @export
 * @interface EnergyPlanContractIntrinsicGreenPower
 */
export interface EnergyPlanContractIntrinsicGreenPower {
  /**
   * Percentage of green power intrinsically included in the plan
   * @type {string}
   * @memberof EnergyPlanContractIntrinsicGreenPower
   */
  greenPercentage: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractSolarFeedInTariffInner
 */
export interface EnergyPlanContractSolarFeedInTariffInner {
  /**
   * The name of the tariff
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInner
   */
  displayName: string;
  /**
   * A description of the tariff
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInner
   */
  description?: string;
  /**
   * The applicable scheme
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInner
   */
  scheme: EnergyPlanContractSolarFeedInTariffInnerSchemeEnum;
  /**
   * The type of the payer
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInner
   */
  payerType: EnergyPlanContractSolarFeedInTariffInnerPayerTypeEnum;
  /**
   * The type of the payer
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInner
   */
  tariffUType: EnergyPlanContractSolarFeedInTariffInnerTariffUTypeEnum;
  /**
   *
   * @type {EnergyPlanContractSolarFeedInTariffInnerSingleTariff}
   * @memberof EnergyPlanContractSolarFeedInTariffInner
   */
  singleTariff?: EnergyPlanContractSolarFeedInTariffInnerSingleTariff;
  /**
   *
   * @type {EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffs}
   * @memberof EnergyPlanContractSolarFeedInTariffInner
   */
  timeVaryingTariffs?: EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffs;
}

export const EnergyPlanContractSolarFeedInTariffInnerSchemeEnum = {
  Premium: 'PREMIUM',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractSolarFeedInTariffInnerSchemeEnum =
  typeof EnergyPlanContractSolarFeedInTariffInnerSchemeEnum[keyof typeof EnergyPlanContractSolarFeedInTariffInnerSchemeEnum];
export const EnergyPlanContractSolarFeedInTariffInnerPayerTypeEnum = {
  Government: 'GOVERNMENT',
  Retailer: 'RETAILER',
} as const;

export type EnergyPlanContractSolarFeedInTariffInnerPayerTypeEnum =
  typeof EnergyPlanContractSolarFeedInTariffInnerPayerTypeEnum[keyof typeof EnergyPlanContractSolarFeedInTariffInnerPayerTypeEnum];
export const EnergyPlanContractSolarFeedInTariffInnerTariffUTypeEnum = {
  SingleTariff: 'singleTariff',
  TimeVaryingTariffs: 'timeVaryingTariffs',
} as const;

export type EnergyPlanContractSolarFeedInTariffInnerTariffUTypeEnum =
  typeof EnergyPlanContractSolarFeedInTariffInnerTariffUTypeEnum[keyof typeof EnergyPlanContractSolarFeedInTariffInnerTariffUTypeEnum];

/**
 * Represents a constant tariff.  Mandatory if tariffUType is set to singleTariff
 * @export
 * @interface EnergyPlanContractSolarFeedInTariffInnerSingleTariff
 */
export interface EnergyPlanContractSolarFeedInTariffInnerSingleTariff {
  /**
   * The tariff amount
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInnerSingleTariff
   */
  amount: string;
}
/**
 * Represents a tariff based on time.  Mandatory if tariffUType is set to timeVaryingTariffs
 * @export
 * @interface EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffs
 */
export interface EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffs {
  /**
   * The type of the charging time period. If absent applies to all periods
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffs
   */
  type?: EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTypeEnum;
  /**
   * The tariff amount
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffs
   */
  amount: string;
  /**
   * Array of time periods for which this tariff is applicable
   * @type {Array<EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInner>}
   * @memberof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffs
   */
  timeVariations: Array<EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInner>;
}

export const EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTypeEnum = {
  Peak: 'PEAK',
  OffPeak: 'OFF_PEAK',
  Shoulder: 'SHOULDER',
} as const;

export type EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTypeEnum =
  typeof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTypeEnum[keyof typeof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInner
 */
export interface EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInner {
  /**
   * The days that the tariff applies to. At least one entry required
   * @type {Array<string>}
   * @memberof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInner
   */
  days: Array<EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInnerDaysEnum>;
  /**
   * The beginning of the time period per day for which the tariff applies.  If absent assumes start of day (ie. midnight)
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInner
   */
  startTime?: string;
  /**
   * The end of the time period per day for which the tariff applies.  If absent assumes end of day (ie. one second before midnight)
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInner
   */
  endTime?: string;
}

export const EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInnerDaysEnum = {
  Sun: 'SUN',
  Mon: 'MON',
  Tue: 'TUE',
  Wed: 'WED',
  Thu: 'THU',
  Fri: 'FRI',
  Sat: 'SAT',
  PublicHolidays: 'PUBLIC_HOLIDAYS',
} as const;

export type EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInnerDaysEnum =
  typeof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInnerDaysEnum[keyof typeof EnergyPlanContractSolarFeedInTariffInnerTimeVaryingTariffsTimeVariationsInnerDaysEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractTariffPeriodInner
 */
export interface EnergyPlanContractTariffPeriodInner {
  /**
   * Type of charge. Assumed to be other if absent
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  type?: EnergyPlanContractTariffPeriodInnerTypeEnum;
  /**
   * The name of the tariff period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  displayName: string;
  /**
   * The start date of the tariff period in a calendar year.  Formatted in mm-dd format
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  startDate: string;
  /**
   * The end date of the tariff period in a calendar year.  Formatted in mm-dd format
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  endDate: string;
  /**
   * The amount of access charge for the tariff period, in dollars per day exclusive of GST.
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  dailySupplyCharges?: string;
  /**
   * Specifies the charge specific time zone for calculation of the time of use thresholds. If absent, timezone value in EnergyPlanContract is assumed.
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  timeZone?: EnergyPlanContractTariffPeriodInnerTimeZoneEnum;
  /**
   * Specifies the type of rate applicable to this tariff period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  rateBlockUType: EnergyPlanContractTariffPeriodInnerRateBlockUTypeEnum;
  /**
   *
   * @type {EnergyPlanContractTariffPeriodInnerSingleRate}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  singleRate?: EnergyPlanContractTariffPeriodInnerSingleRate;
  /**
   * Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
   * @type {Array<EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner>}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  timeOfUseRates?: Array<EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner>;
  /**
   * Array of demand charges.  Required if rateBlockUType is demandCharges
   * @type {Array<EnergyPlanContractTariffPeriodInnerDemandChargesInner>}
   * @memberof EnergyPlanContractTariffPeriodInner
   */
  demandCharges?: Array<EnergyPlanContractTariffPeriodInnerDemandChargesInner>;
}

export const EnergyPlanContractTariffPeriodInnerTypeEnum = {
  Environmental: 'ENVIRONMENTAL',
  Regulated: 'REGULATED',
  Network: 'NETWORK',
  Metering: 'METERING',
  RetailService: 'RETAIL_SERVICE',
  Rcti: 'RCTI',
  Other: 'OTHER',
} as const;

export type EnergyPlanContractTariffPeriodInnerTypeEnum =
  typeof EnergyPlanContractTariffPeriodInnerTypeEnum[keyof typeof EnergyPlanContractTariffPeriodInnerTypeEnum];
export const EnergyPlanContractTariffPeriodInnerTimeZoneEnum = {
  Local: 'LOCAL',
  Aest: 'AEST',
} as const;

export type EnergyPlanContractTariffPeriodInnerTimeZoneEnum =
  typeof EnergyPlanContractTariffPeriodInnerTimeZoneEnum[keyof typeof EnergyPlanContractTariffPeriodInnerTimeZoneEnum];
export const EnergyPlanContractTariffPeriodInnerRateBlockUTypeEnum = {
  SingleRate: 'singleRate',
  TimeOfUseRates: 'timeOfUseRates',
  DemandCharges: 'demandCharges',
} as const;

export type EnergyPlanContractTariffPeriodInnerRateBlockUTypeEnum =
  typeof EnergyPlanContractTariffPeriodInnerRateBlockUTypeEnum[keyof typeof EnergyPlanContractTariffPeriodInnerRateBlockUTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractTariffPeriodInnerDemandChargesInner
 */
export interface EnergyPlanContractTariffPeriodInnerDemandChargesInner {
  /**
   * Display name of the charge
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  displayName: string;
  /**
   * Description of the charge
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  description?: string;
  /**
   * The charge amount per  measure unit exclusive of GST
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  amount: string;
  /**
   * The measurement unit of charge amount. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  measureUnit?: EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasureUnitEnum;
  /**
   * Start of the period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  startTime: string;
  /**
   * End of the period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  endTime: string;
  /**
   * The days that the demand tariff applies to
   * @type {Array<string>}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  days?: Array<EnergyPlanContractTariffPeriodInnerDemandChargesInnerDaysEnum>;
  /**
   * Minimum demand for this demand tariff in kW.  If absent then 0 is assumed
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  minDemand?: string;
  /**
   * Maximum demand for this demand tariff in kW.  If present, must be higher than the value of the minDemand field
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  maxDemand?: string;
  /**
   * Application period for the demand tariff
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  measurementPeriod: EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasurementPeriodEnum;
  /**
   * Charge period for the demand tariff
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerDemandChargesInner
   */
  chargePeriod: EnergyPlanContractTariffPeriodInnerDemandChargesInnerChargePeriodEnum;
}

export const EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasureUnitEnum = {
  Kwh: 'KWH',
  Kva: 'KVA',
  Kvar: 'KVAR',
  Kvarh: 'KVARH',
  Kw: 'KW',
  Days: 'DAYS',
  Meter: 'METER',
  Month: 'MONTH',
} as const;

export type EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasureUnitEnum =
  typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasureUnitEnum[keyof typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasureUnitEnum];
export const EnergyPlanContractTariffPeriodInnerDemandChargesInnerDaysEnum = {
  Sun: 'SUN',
  Mon: 'MON',
  Tue: 'TUE',
  Wed: 'WED',
  Thu: 'THU',
  Fri: 'FRI',
  Sat: 'SAT',
  PublicHolidays: 'PUBLIC_HOLIDAYS',
} as const;

export type EnergyPlanContractTariffPeriodInnerDemandChargesInnerDaysEnum =
  typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerDaysEnum[keyof typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerDaysEnum];
export const EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasurementPeriodEnum = {
  Day: 'DAY',
  Month: 'MONTH',
  TariffPeriod: 'TARIFF_PERIOD',
} as const;

export type EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasurementPeriodEnum =
  typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasurementPeriodEnum[keyof typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerMeasurementPeriodEnum];
export const EnergyPlanContractTariffPeriodInnerDemandChargesInnerChargePeriodEnum = {
  Day: 'DAY',
  Month: 'MONTH',
  TariffPeriod: 'TARIFF_PERIOD',
} as const;

export type EnergyPlanContractTariffPeriodInnerDemandChargesInnerChargePeriodEnum =
  typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerChargePeriodEnum[keyof typeof EnergyPlanContractTariffPeriodInnerDemandChargesInnerChargePeriodEnum];

/**
 * Object representing a single rate.  Required if rateBlockUType is singleRate
 * @export
 * @interface EnergyPlanContractTariffPeriodInnerSingleRate
 */
export interface EnergyPlanContractTariffPeriodInnerSingleRate {
  /**
   * Display name of the rate
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRate
   */
  displayName: string;
  /**
   * Description of the rate
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRate
   */
  description?: string;
  /**
   * The block rate (unit price) for any usage above the included fixed usage, in dollars per kWh inclusive of GST.  Only required if pricingModel field is QUOTA
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRate
   */
  generalUnitPrice?: string;
  /**
   * Array of controlled load rates in order of usage volume
   * @type {Array<EnergyPlanContractTariffPeriodInnerSingleRateRatesInner>}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRate
   */
  rates: Array<EnergyPlanContractTariffPeriodInnerSingleRateRatesInner>;
  /**
   * Usage period for which the block rate applies. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRate
   */
  period?: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractTariffPeriodInnerSingleRateRatesInner
 */
export interface EnergyPlanContractTariffPeriodInnerSingleRateRatesInner {
  /**
   * Unit price of usage per measure unit (exclusive of GST)
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRateRatesInner
   */
  unitPrice: string;
  /**
   * The measurement unit of rate. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRateRatesInner
   */
  measureUnit?: EnergyPlanContractTariffPeriodInnerSingleRateRatesInnerMeasureUnitEnum;
  /**
   * Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
   * @type {number}
   * @memberof EnergyPlanContractTariffPeriodInnerSingleRateRatesInner
   */
  volume?: number;
}

export const EnergyPlanContractTariffPeriodInnerSingleRateRatesInnerMeasureUnitEnum = {
  Kwh: 'KWH',
  Kva: 'KVA',
  Kvar: 'KVAR',
  Kvarh: 'KVARH',
  Kw: 'KW',
  Days: 'DAYS',
  Meter: 'METER',
  Month: 'MONTH',
} as const;

export type EnergyPlanContractTariffPeriodInnerSingleRateRatesInnerMeasureUnitEnum =
  typeof EnergyPlanContractTariffPeriodInnerSingleRateRatesInnerMeasureUnitEnum[keyof typeof EnergyPlanContractTariffPeriodInnerSingleRateRatesInnerMeasureUnitEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner
 */
export interface EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner {
  /**
   * Display name of the rate
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner
   */
  displayName: string;
  /**
   * Description of the rate
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner
   */
  description?: string;
  /**
   * Array of controlled load rates in order of usage volume
   * @type {Array<EnergyPlanContractControlledLoadInnerSingleRateRatesInner>}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner
   */
  rates: Array<EnergyPlanContractControlledLoadInnerSingleRateRatesInner>;
  /**
   * Array of times of use
   * @type {Array<EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInner>}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner
   */
  timeOfUse: Array<EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInner>;
  /**
   * The type of usage that the rate applies to
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInner
   */
  type: EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTypeEnum;
}

export const EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTypeEnum = {
  Peak: 'PEAK',
  OffPeak: 'OFF_PEAK',
  Shoulder: 'SHOULDER',
  Shoulder1: 'SHOULDER1',
  Shoulder2: 'SHOULDER2',
} as const;

export type EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTypeEnum =
  typeof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTypeEnum[keyof typeof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInner
 */
export interface EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInner {
  /**
   * The days that the rate applies to
   * @type {Array<string>}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  days: Array<EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum>;
  /**
   * Start of the period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  startTime: string;
  /**
   * End of the period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInner
   */
  endTime: string;
}

export const EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum = {
  Sun: 'SUN',
  Mon: 'MON',
  Tue: 'TUE',
  Wed: 'WED',
  Thu: 'THU',
  Fri: 'FRI',
  Sat: 'SAT',
  PublicHolidays: 'PUBLIC_HOLIDAYS',
} as const;

export type EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum =
  typeof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum[keyof typeof EnergyPlanContractTariffPeriodInnerTimeOfUseRatesInnerTimeOfUseInnerDaysEnum];

/**
 *
 * @export
 * @interface EnergyPlanDetail
 */
export interface EnergyPlanDetail {
  /**
   * The ID of the specific plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  planId: string;
  /**
   * The date and time from which this plan is effective (ie. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  effectiveFrom?: string;
  /**
   * The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  effectiveTo?: string;
  /**
   * The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  lastUpdated: string;
  /**
   * The display name of the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  displayName?: string;
  /**
   * A description of the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  description?: string;
  /**
   * The type of the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  type: EnergyPlanDetailTypeEnum;
  /**
   * The fuel types covered by the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  fuelType: EnergyPlanDetailFuelTypeEnum;
  /**
   * The ID of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  brand: string;
  /**
   * The display name of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  brandName: string;
  /**
   * A link to an application web page where this plan can be applied for
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  applicationUri?: string;
  /**
   *
   * @type {EnergyPlanAdditionalInformation}
   * @memberof EnergyPlanDetail
   */
  additionalInformation?: EnergyPlanAdditionalInformation;
  /**
   * The type of customer that the plan is offered to.  If absent then the plan is available to all customers
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  customerType?: EnergyPlanDetailCustomerTypeEnum;
  /**
   *
   * @type {EnergyPlanGeography}
   * @memberof EnergyPlanDetail
   */
  geography?: EnergyPlanGeography;
  /**
   * Charges for metering included in the plan
   * @type {Array<EnergyPlanDetailAllOfMeteringCharges>}
   * @memberof EnergyPlanDetail
   */
  meteringCharges?: Array<EnergyPlanDetailAllOfMeteringCharges>;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetail
   */
  gasContract?: EnergyPlanContractFull;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetail
   */
  electricityContract?: EnergyPlanContractFull;
}

export const EnergyPlanDetailTypeEnum = {
  Standing: 'STANDING',
  Market: 'MARKET',
  Regulated: 'REGULATED',
} as const;

export type EnergyPlanDetailTypeEnum = typeof EnergyPlanDetailTypeEnum[keyof typeof EnergyPlanDetailTypeEnum];
export const EnergyPlanDetailFuelTypeEnum = {
  Electricity: 'ELECTRICITY',
  Gas: 'GAS',
  Dual: 'DUAL',
} as const;

export type EnergyPlanDetailFuelTypeEnum =
  typeof EnergyPlanDetailFuelTypeEnum[keyof typeof EnergyPlanDetailFuelTypeEnum];
export const EnergyPlanDetailCustomerTypeEnum = {
  Residential: 'RESIDENTIAL',
  Business: 'BUSINESS',
} as const;

export type EnergyPlanDetailCustomerTypeEnum =
  typeof EnergyPlanDetailCustomerTypeEnum[keyof typeof EnergyPlanDetailCustomerTypeEnum];

/**
 *
 * @export
 * @interface EnergyPlanDetailAllOf
 */
export interface EnergyPlanDetailAllOf {
  /**
   * Charges for metering included in the plan
   * @type {Array<EnergyPlanDetailAllOfMeteringCharges>}
   * @memberof EnergyPlanDetailAllOf
   */
  meteringCharges?: Array<EnergyPlanDetailAllOfMeteringCharges>;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetailAllOf
   */
  gasContract?: EnergyPlanContractFull;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetailAllOf
   */
  electricityContract?: EnergyPlanContractFull;
}
/**
 *
 * @export
 * @interface EnergyPlanDetailAllOfMeteringCharges
 */
export interface EnergyPlanDetailAllOfMeteringCharges {
  /**
   * Display name of the charge
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  displayName: string;
  /**
   * Description of the charge
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  description?: string;
  /**
   * Minimum value of the charge if the charge is a range or the absolute value of the charge if no range is specified
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  minimumValue: string;
  /**
   * The upper limit of the charge if the charge could occur in a range
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  maximumValue?: string;
  /**
   * The charges that occur on a schedule indicates the frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  period?: string;
}
/**
 * Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
 * @export
 * @interface EnergyPlanGeography
 */
export interface EnergyPlanGeography {
  /**
   * Array of valid Australian post codes that are specifically excluded from the plan.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
   * @type {Array<string>}
   * @memberof EnergyPlanGeography
   */
  excludedPostcodes?: Array<string>;
  /**
   * Array of valid Australian post codes that are included from the plan.  If absent defaults to all non-excluded post codes.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
   * @type {Array<string>}
   * @memberof EnergyPlanGeography
   */
  includedPostcodes?: Array<string>;
  /**
   * Array of distributors for the plan. Must have at least one entry
   * @type {Array<string>}
   * @memberof EnergyPlanGeography
   */
  distributors: Array<string>;
}
/**
 *
 * @export
 * @interface EnergyPlanList
 */
export interface EnergyPlanList {
  /**
   *
   * @type {EnergyPlanListData}
   * @memberof EnergyPlanList
   */
  data: EnergyPlanListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyPlanList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyPlanList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyPlanListData
 */
export interface EnergyPlanListData {
  /**
   * Array of plans
   * @type {Array<EnergyPlanDetail>}
   * @memberof EnergyPlanListData
   */
  plans: Array<EnergyPlanDetail>;
}
/**
 *
 * @export
 * @interface EnergyServicePoint
 */
export interface EnergyServicePoint {
  /**
   * Tokenised ID of the service point to be used for referring to the service point in the CDR API suite. To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyServicePoint
   */
  servicePointId: string;
  /**
   * The independent ID of the service point, known in the industry as the NMI
   * @type {string}
   * @memberof EnergyServicePoint
   */
  nationalMeteringId: string;
  /**
   * The classification of the service point as defined in MSATS procedures
   * @type {string}
   * @memberof EnergyServicePoint
   */
  servicePointClassification: EnergyServicePointServicePointClassificationEnum;
  /**
   * Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
   * @type {string}
   * @memberof EnergyServicePoint
   */
  servicePointStatus: EnergyServicePointServicePointStatusEnum;
  /**
   * Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
   * @type {string}
   * @memberof EnergyServicePoint
   */
  jurisdictionCode: EnergyServicePointJurisdictionCodeEnum;
  /**
   * This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
   * @type {boolean}
   * @memberof EnergyServicePoint
   */
  isGenerator?: boolean;
  /**
   * The latest start date from which the constituent data sets of this service point became valid
   * @type {string}
   * @memberof EnergyServicePoint
   */
  validFromDate: string;
  /**
   * The date and time that the information for this service point was modified
   * @type {string}
   * @memberof EnergyServicePoint
   */
  lastUpdateDateTime: string;
  /**
   *
   * @type {EnergyServicePointConsumerProfile}
   * @memberof EnergyServicePoint
   */
  consumerProfile?: EnergyServicePointConsumerProfile;
}

export const EnergyServicePointServicePointClassificationEnum = {
  ExternalProfile: 'EXTERNAL_PROFILE',
  Generator: 'GENERATOR',
  Large: 'LARGE',
  Small: 'SMALL',
  Wholesale: 'WHOLESALE',
  NonContestUnmeteredLoad: 'NON_CONTEST_UNMETERED_LOAD',
  NonRegisteredEmbeddedGenerator: 'NON_REGISTERED_EMBEDDED_GENERATOR',
  DistributionWholesale: 'DISTRIBUTION_WHOLESALE',
} as const;

export type EnergyServicePointServicePointClassificationEnum =
  typeof EnergyServicePointServicePointClassificationEnum[keyof typeof EnergyServicePointServicePointClassificationEnum];
export const EnergyServicePointServicePointStatusEnum = {
  Active: 'ACTIVE',
  DeEnergised: 'DE_ENERGISED',
  Extinct: 'EXTINCT',
  Greenfield: 'GREENFIELD',
  OffMarket: 'OFF_MARKET',
} as const;

export type EnergyServicePointServicePointStatusEnum =
  typeof EnergyServicePointServicePointStatusEnum[keyof typeof EnergyServicePointServicePointStatusEnum];
export const EnergyServicePointJurisdictionCodeEnum = {
  All: 'ALL',
  Act: 'ACT',
  Nem: 'NEM',
  Nsw: 'NSW',
  Qld: 'QLD',
  Sa: 'SA',
  Tas: 'TAS',
  Vic: 'VIC',
} as const;

export type EnergyServicePointJurisdictionCodeEnum =
  typeof EnergyServicePointJurisdictionCodeEnum[keyof typeof EnergyServicePointJurisdictionCodeEnum];

/**
 *
 * @export
 * @interface EnergyServicePointConsumerProfile
 */
export interface EnergyServicePointConsumerProfile {
  /**
   * A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
   * @type {string}
   * @memberof EnergyServicePointConsumerProfile
   */
  classification?: EnergyServicePointConsumerProfileClassificationEnum;
  /**
   * A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the lower consumption threshold as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the lower consumption threshold, but less than the upper consumption threshold, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the upper consumption threshold as defined in the National Energy Retail Regulations</li></ul>
   * @type {string}
   * @memberof EnergyServicePointConsumerProfile
   */
  threshold?: EnergyServicePointConsumerProfileThresholdEnum;
}

export const EnergyServicePointConsumerProfileClassificationEnum = {
  Business: 'BUSINESS',
  Residential: 'RESIDENTIAL',
} as const;

export type EnergyServicePointConsumerProfileClassificationEnum =
  typeof EnergyServicePointConsumerProfileClassificationEnum[keyof typeof EnergyServicePointConsumerProfileClassificationEnum];
export const EnergyServicePointConsumerProfileThresholdEnum = {
  Low: 'LOW',
  Medium: 'MEDIUM',
  High: 'HIGH',
} as const;

export type EnergyServicePointConsumerProfileThresholdEnum =
  typeof EnergyServicePointConsumerProfileThresholdEnum[keyof typeof EnergyServicePointConsumerProfileThresholdEnum];

/**
 *
 * @export
 * @interface EnergyServicePointDetail
 */
export interface EnergyServicePointDetail {
  /**
   * The tokenised ID of the service point for use in the CDR APIs.  Created according to the CDR rules for ID permanence
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  servicePointId: string;
  /**
   * The independent ID of the service point, known in the industry as the NMI
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  nationalMeteringId: string;
  /**
   * The classification of the service point as defined in MSATS procedures
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  servicePointClassification: EnergyServicePointDetailServicePointClassificationEnum;
  /**
   * Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  servicePointStatus: EnergyServicePointDetailServicePointStatusEnum;
  /**
   * Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  jurisdictionCode: EnergyServicePointDetailJurisdictionCodeEnum;
  /**
   * This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
   * @type {boolean}
   * @memberof EnergyServicePointDetail
   */
  isGenerator?: boolean;
  /**
   * The latest start date from which the constituent data sets of this service point became valid
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  validFromDate: string;
  /**
   * The date and time that the information for this service point was modified
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  lastUpdateDateTime: string;
  /**
   *
   * @type {EnergyServicePointConsumerProfile}
   * @memberof EnergyServicePointDetail
   */
  consumerProfile?: EnergyServicePointConsumerProfile;
  /**
   *
   * @type {EnergyServicePointDetailDistributionLossFactor}
   * @memberof EnergyServicePointDetail
   */
  distributionLossFactor: EnergyServicePointDetailDistributionLossFactor;
  /**
   *
   * @type {Array<EnergyServicePointDetailRelatedParticipants>}
   * @memberof EnergyServicePointDetail
   */
  relatedParticipants: Array<EnergyServicePointDetailRelatedParticipants>;
  /**
   *
   * @type {CommonPhysicalAddress}
   * @memberof EnergyServicePointDetail
   */
  location: CommonPhysicalAddress;
  /**
   * The meters associated with the service point. This may be empty where there are no meters physically installed at the service point
   * @type {Array<EnergyServicePointDetailMeters>}
   * @memberof EnergyServicePointDetail
   */
  meters: Array<EnergyServicePointDetailMeters>;
  /**
   *
   * @type {EnergyDerRecord}
   * @memberof EnergyServicePointDetail
   */
  der?: EnergyDerRecord;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyServicePointDetail
   */
  adatree?: Adatree;
}

export const EnergyServicePointDetailServicePointClassificationEnum = {
  ExternalProfile: 'EXTERNAL_PROFILE',
  Generator: 'GENERATOR',
  Large: 'LARGE',
  Small: 'SMALL',
  Wholesale: 'WHOLESALE',
  NonContestUnmeteredLoad: 'NON_CONTEST_UNMETERED_LOAD',
  NonRegisteredEmbeddedGenerator: 'NON_REGISTERED_EMBEDDED_GENERATOR',
  DistributionWholesale: 'DISTRIBUTION_WHOLESALE',
} as const;

export type EnergyServicePointDetailServicePointClassificationEnum =
  typeof EnergyServicePointDetailServicePointClassificationEnum[keyof typeof EnergyServicePointDetailServicePointClassificationEnum];
export const EnergyServicePointDetailServicePointStatusEnum = {
  Active: 'ACTIVE',
  DeEnergised: 'DE_ENERGISED',
  Extinct: 'EXTINCT',
  Greenfield: 'GREENFIELD',
  OffMarket: 'OFF_MARKET',
} as const;

export type EnergyServicePointDetailServicePointStatusEnum =
  typeof EnergyServicePointDetailServicePointStatusEnum[keyof typeof EnergyServicePointDetailServicePointStatusEnum];
export const EnergyServicePointDetailJurisdictionCodeEnum = {
  All: 'ALL',
  Act: 'ACT',
  Nem: 'NEM',
  Nsw: 'NSW',
  Qld: 'QLD',
  Sa: 'SA',
  Tas: 'TAS',
  Vic: 'VIC',
} as const;

export type EnergyServicePointDetailJurisdictionCodeEnum =
  typeof EnergyServicePointDetailJurisdictionCodeEnum[keyof typeof EnergyServicePointDetailJurisdictionCodeEnum];

/**
 *
 * @export
 * @interface EnergyServicePointDetailDistributionLossFactor
 */
export interface EnergyServicePointDetailDistributionLossFactor {
  /**
   * A code used to identify data loss factor for the service point values.  Refer to AEMO distribution loss factor documents for each financial year to interpret
   * @type {string}
   * @memberof EnergyServicePointDetailDistributionLossFactor
   */
  code: string;
  /**
   * Description of the data loss factor code and value
   * @type {string}
   * @memberof EnergyServicePointDetailDistributionLossFactor
   */
  description: string;
  /**
   * The value associated with the loss factor code
   * @type {string}
   * @memberof EnergyServicePointDetailDistributionLossFactor
   */
  lossValue: string;
}
/**
 *
 * @export
 * @interface EnergyServicePointDetailMeters
 */
export interface EnergyServicePointDetailMeters {
  /**
   * The meter ID uniquely identifies a meter for a given service point.  It is unique in the context of the service point.  It is not globally unique
   * @type {string}
   * @memberof EnergyServicePointDetailMeters
   */
  meterId: string;
  /**
   *
   * @type {EnergyServicePointDetailSpecifications}
   * @memberof EnergyServicePointDetailMeters
   */
  specifications: EnergyServicePointDetailSpecifications;
  /**
   * Usage data registers available from the meter. This may be empty where there are no meters physically installed at the service point
   * @type {Array<EnergyServicePointDetailRegisters>}
   * @memberof EnergyServicePointDetailMeters
   */
  registers?: Array<EnergyServicePointDetailRegisters>;
}
/**
 *
 * @export
 * @interface EnergyServicePointDetailRegisters
 */
export interface EnergyServicePointDetailRegisters {
  /**
   * Unique identifier of the register within this service point.  Is not globally unique
   * @type {string}
   * @memberof EnergyServicePointDetailRegisters
   */
  registerId: string;
  /**
   * Register suffix of the meter register where the meter reads are obtained
   * @type {string}
   * @memberof EnergyServicePointDetailRegisters
   */
  registerSuffix?: string;
  /**
   * The energy delivered through a connection point or metering point over an extended period normalised to a \'per day\' basis (kWh). This value is calculated annually.
   * @type {number}
   * @memberof EnergyServicePointDetailRegisters
   */
  averagedDailyLoad?: number;
  /**
   * Indicates the consumption type of register
   * @type {string}
   * @memberof EnergyServicePointDetailRegisters
   */
  registerConsumptionType: EnergyServicePointDetailRegistersRegisterConsumptionTypeEnum;
  /**
   * The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider
   * @type {string}
   * @memberof EnergyServicePointDetailRegisters
   */
  networkTariffCode?: string;
  /**
   * The unit of measure for data held in this register
   * @type {string}
   * @memberof EnergyServicePointDetailRegisters
   */
  unitOfMeasure?: string;
  /**
   * Code to identify the time validity of register contents
   * @type {string}
   * @memberof EnergyServicePointDetailRegisters
   */
  timeOfDay?: EnergyServicePointDetailRegistersTimeOfDayEnum;
  /**
   * Multiplier required to take a register value and turn it into a value representing billable energy
   * @type {number}
   * @memberof EnergyServicePointDetailRegisters
   */
  multiplier?: number;
  /**
   * Indicates whether the energy recorded by this register is created under a Controlled Load regime
   * @type {boolean}
   * @memberof EnergyServicePointDetailRegisters
   */
  controlledLoad?: boolean;
  /**
   * Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailRegisters
   */
  consumptionType?: EnergyServicePointDetailRegistersConsumptionTypeEnum;
}

export const EnergyServicePointDetailRegistersRegisterConsumptionTypeEnum = {
  Interval: 'INTERVAL',
  Basic: 'BASIC',
  ProfileData: 'PROFILE_DATA',
  ActiveImport: 'ACTIVE_IMPORT',
  Active: 'ACTIVE',
  ReactiveImport: 'REACTIVE_IMPORT',
  Reactive: 'REACTIVE',
} as const;

export type EnergyServicePointDetailRegistersRegisterConsumptionTypeEnum =
  typeof EnergyServicePointDetailRegistersRegisterConsumptionTypeEnum[keyof typeof EnergyServicePointDetailRegistersRegisterConsumptionTypeEnum];
export const EnergyServicePointDetailRegistersTimeOfDayEnum = {
  Allday: 'ALLDAY',
  Interval: 'INTERVAL',
  Peak: 'PEAK',
  Business: 'BUSINESS',
  Shoulder: 'SHOULDER',
  Evening: 'EVENING',
  Offpeak: 'OFFPEAK',
  Controlled: 'CONTROLLED',
  Demand: 'DEMAND',
} as const;

export type EnergyServicePointDetailRegistersTimeOfDayEnum =
  typeof EnergyServicePointDetailRegistersTimeOfDayEnum[keyof typeof EnergyServicePointDetailRegistersTimeOfDayEnum];
export const EnergyServicePointDetailRegistersConsumptionTypeEnum = {
  Actual: 'ACTUAL',
  Cumulative: 'CUMULATIVE',
} as const;

export type EnergyServicePointDetailRegistersConsumptionTypeEnum =
  typeof EnergyServicePointDetailRegistersConsumptionTypeEnum[keyof typeof EnergyServicePointDetailRegistersConsumptionTypeEnum];

/**
 *
 * @export
 * @interface EnergyServicePointDetailRelatedParticipants
 */
export interface EnergyServicePointDetailRelatedParticipants {
  /**
   * The name of the party/orginsation related to this service point
   * @type {string}
   * @memberof EnergyServicePointDetailRelatedParticipants
   */
  party: string;
  /**
   * The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailRelatedParticipants
   */
  role: EnergyServicePointDetailRelatedParticipantsRoleEnum;
}

export const EnergyServicePointDetailRelatedParticipantsRoleEnum = {
  Frmp: 'FRMP',
  Lnsp: 'LNSP',
  Drsp: 'DRSP',
} as const;

export type EnergyServicePointDetailRelatedParticipantsRoleEnum =
  typeof EnergyServicePointDetailRelatedParticipantsRoleEnum[keyof typeof EnergyServicePointDetailRelatedParticipantsRoleEnum];

/**
 * Technical characteristics of the meter
 * @export
 * @interface EnergyServicePointDetailSpecifications
 */
export interface EnergyServicePointDetailSpecifications {
  /**
   * A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailSpecifications
   */
  status: EnergyServicePointDetailSpecificationsStatusEnum;
  /**
   * The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter  Type 6</li><li>**COMMS1** - Interval Meter with communications  Type 1</li><li>**COMMS2** - Interval Meter with communications  Type 2</li><li>**COMMS3** - Interval Meter with communications  Type 3</li><li>**COMMS4** - Interval Meter with communications  Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation  Type 4A</li><li>**MRIM** - Manually Read Interval Meter  Type 5</li><li>**UMCP** - Unmetered Supply  Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailSpecifications
   */
  installationType: EnergyServicePointDetailSpecificationsInstallationTypeEnum;
  /**
   * Free text field to identify the manufacturer of the installed meter
   * @type {string}
   * @memberof EnergyServicePointDetailSpecifications
   */
  manufacturer?: string;
  /**
   * Free text field to identify the meter manufacturers designation for the meter model
   * @type {string}
   * @memberof EnergyServicePointDetailSpecifications
   */
  model?: string;
  /**
   * Code to denote the method and frequency of Meter Reading. The value is formatted as follows: <ul><li>First Character = Remote (R) or Manual (M)</li><li>Second Character = Mode: T = telephone W = wireless P = powerline I = infra-red G = galvanic V = visual </li><li>Third Character = Frequency of Scheduled Meter Readings: 1 = Twelve times per year 2 = Six times per year 3 = Four times per year D = Daily or weekly</li><li>Optional Fourth Character = to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A  5 minute B  15 minute C  30 minute D  Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter</li></ul> For example, <ul><li>MV3 = Manual, Visual, Quarterly</li> <li>MV3M = Manual, Visual, Quarterly, Manually Read Accumulation Meter</li> <li>RWDC = Remote, Wireless, Daily, 30 minutes interval</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailSpecifications
   */
  readType?: string;
  /**
   * This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required
   * @type {string}
   * @memberof EnergyServicePointDetailSpecifications
   */
  nextScheduledReadDate?: string;
}

export const EnergyServicePointDetailSpecificationsStatusEnum = {
  Current: 'CURRENT',
  Disconnected: 'DISCONNECTED',
} as const;

export type EnergyServicePointDetailSpecificationsStatusEnum =
  typeof EnergyServicePointDetailSpecificationsStatusEnum[keyof typeof EnergyServicePointDetailSpecificationsStatusEnum];
export const EnergyServicePointDetailSpecificationsInstallationTypeEnum = {
  Basic: 'BASIC',
  Comms1: 'COMMS1',
  Comms2: 'COMMS2',
  Comms3: 'COMMS3',
  Comms4: 'COMMS4',
  Comms4C: 'COMMS4C',
  Comms4D: 'COMMS4D',
  Mram: 'MRAM',
  Mrim: 'MRIM',
  Prof: 'PROF',
  Sample: 'SAMPLE',
  Umcp: 'UMCP',
  Vicami: 'VICAMI',
  Ncolnuml: 'NCOLNUML',
} as const;

export type EnergyServicePointDetailSpecificationsInstallationTypeEnum =
  typeof EnergyServicePointDetailSpecificationsInstallationTypeEnum[keyof typeof EnergyServicePointDetailSpecificationsInstallationTypeEnum];

/**
 *
 * @export
 * @interface EnergyServicePointList
 */
export interface EnergyServicePointList {
  /**
   *
   * @type {EnergyServicePointListData}
   * @memberof EnergyServicePointList
   */
  data: EnergyServicePointListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyServicePointList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyServicePointList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyServicePointListData
 */
export interface EnergyServicePointListData {
  /**
   *
   * @type {Array<EnergyServicePointDetail>}
   * @memberof EnergyServicePointListData
   */
  servicePoints: Array<EnergyServicePointDetail>;
}
/**
 *
 * @export
 * @interface EnergyUsageList
 */
export interface EnergyUsageList {
  /**
   *
   * @type {EnergyUsageListData}
   * @memberof EnergyUsageList
   */
  data: EnergyUsageListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyUsageList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyUsageList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyUsageListData
 */
export interface EnergyUsageListData {
  /**
   * Array of meter reads sorted by NMI in ascending order followed by readStartDate in descending order
   * @type {Array<EnergyUsageRead>}
   * @memberof EnergyUsageListData
   */
  reads: Array<EnergyUsageRead>;
}
/**
 *
 * @export
 * @interface EnergyUsageRead
 */
export interface EnergyUsageRead {
  /**
   * Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyUsageRead
   */
  servicePointId: string;
  /**
   * Register ID of the meter register where the meter reads are obtained
   * @type {string}
   * @memberof EnergyUsageRead
   */
  registerId?: string;
  /**
   * Register suffix of the meter register where the meter reads are obtained
   * @type {string}
   * @memberof EnergyUsageRead
   */
  registerSuffix: string;
  /**
   * Meter id/serial number as it appears in customers bill. ID permanence rules do not apply.
   * @type {string}
   * @memberof EnergyUsageRead
   */
  meterId?: string;
  /**
   * Indicates whether the energy recorded by this register is created under a Controlled Load regime
   * @type {boolean}
   * @memberof EnergyUsageRead
   */
  controlledLoad?: boolean;
  /**
   * Date when the meter reads start in AEST and assumed to start from 12:00 am AEST.
   * @type {string}
   * @memberof EnergyUsageRead
   */
  readStartDate: string;
  /**
   * Date when the meter reads end in AEST.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate.
   * @type {string}
   * @memberof EnergyUsageRead
   */
  readEndDate?: string;
  /**
   * Unit of measure of the meter reads. Refer to Appendix B of <a href=\'https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la=en&hash=03FCBA0D60E091DE00F2361AE76206EA\'>MDFF Specification NEM12 NEM13 v2.1</a> for a list of possible values.
   * @type {string}
   * @memberof EnergyUsageRead
   */
  unitOfMeasure?: string;
  /**
   * Specify the type of the meter read data
   * @type {string}
   * @memberof EnergyUsageRead
   */
  readUType: EnergyUsageReadReadUTypeEnum;
  /**
   *
   * @type {EnergyUsageReadBasicRead}
   * @memberof EnergyUsageRead
   */
  basicRead?: EnergyUsageReadBasicRead;
  /**
   *
   * @type {EnergyUsageReadIntervalRead}
   * @memberof EnergyUsageRead
   */
  intervalRead?: EnergyUsageReadIntervalRead;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyUsageRead
   */
  adatree: Adatree;
}

export const EnergyUsageReadReadUTypeEnum = {
  BasicRead: 'basicRead',
  IntervalRead: 'intervalRead',
} as const;

export type EnergyUsageReadReadUTypeEnum =
  typeof EnergyUsageReadReadUTypeEnum[keyof typeof EnergyUsageReadReadUTypeEnum];

/**
 * Mandatory if readUType is set to basicRead
 * @export
 * @interface EnergyUsageReadBasicRead
 */
export interface EnergyUsageReadBasicRead {
  /**
   * The quality of the read taken.  If absent then assumed to be ACTUAL
   * @type {string}
   * @memberof EnergyUsageReadBasicRead
   */
  quality?: EnergyUsageReadBasicReadQualityEnum;
  /**
   * Meter read value.  If positive then it means consumption, if negative it means export
   * @type {number}
   * @memberof EnergyUsageReadBasicRead
   */
  value: number;
}

export const EnergyUsageReadBasicReadQualityEnum = {
  Actual: 'ACTUAL',
  Substitute: 'SUBSTITUTE',
  FinalSubstitute: 'FINAL_SUBSTITUTE',
} as const;

export type EnergyUsageReadBasicReadQualityEnum =
  typeof EnergyUsageReadBasicReadQualityEnum[keyof typeof EnergyUsageReadBasicReadQualityEnum];

/**
 * Mandatory if readUType is set to intervalRead
 * @export
 * @interface EnergyUsageReadIntervalRead
 */
export interface EnergyUsageReadIntervalRead {
  /**
   * Read interval length in minutes. Required when interval-reads query parameter equals FULL or MIN_30
   * @type {number}
   * @memberof EnergyUsageReadIntervalRead
   */
  readIntervalLength?: number;
  /**
   * The aggregate sum of the interval read values. If positive then it means net consumption, if negative it means net export
   * @type {number}
   * @memberof EnergyUsageReadIntervalRead
   */
  aggregateValue: number;
  /**
   * Array of Interval read values. If positive then it means consumption, if negative it means export. Required when interval-reads query parameter equals FULL or  MIN_30.<br>Each read value indicates the read for the interval specified by readIntervalLength beginning at midnight of readStartDate (for example 00:00 to 00:30 would be the first reading in a 30 minute Interval)
   * @type {Array<number>}
   * @memberof EnergyUsageReadIntervalRead
   */
  intervalReads?: Array<number>;
  /**
   *  Specifies quality of reads that are not ACTUAL.  For read indices that are not specified, quality is assumed to be ACTUAL. If not present, all quality of all reads are assumed to be actual. Required when interval-reads query parameter equals FULL or MIN_30
   * @type {Array<EnergyUsageReadIntervalReadReadQualities>}
   * @memberof EnergyUsageReadIntervalRead
   */
  readQualities?: Array<EnergyUsageReadIntervalReadReadQualities>;
}
/**
 *
 * @export
 * @interface EnergyUsageReadIntervalReadReadQualities
 */
export interface EnergyUsageReadIntervalReadReadQualities {
  /**
   * Start interval for read quality flag. First read begins at 1
   * @type {number}
   * @memberof EnergyUsageReadIntervalReadReadQualities
   */
  startInterval: number;
  /**
   * End interval for read quality flag
   * @type {number}
   * @memberof EnergyUsageReadIntervalReadReadQualities
   */
  endInterval: number;
  /**
   * The quality of the read taken
   * @type {string}
   * @memberof EnergyUsageReadIntervalReadReadQualities
   */
  quality: EnergyUsageReadIntervalReadReadQualitiesQualityEnum;
}

export const EnergyUsageReadIntervalReadReadQualitiesQualityEnum = {
  Substitute: 'SUBSTITUTE',
  FinalSubstitute: 'FINAL_SUBSTITUTE',
} as const;

export type EnergyUsageReadIntervalReadReadQualitiesQualityEnum =
  typeof EnergyUsageReadIntervalReadReadQualitiesQualityEnum[keyof typeof EnergyUsageReadIntervalReadReadQualitiesQualityEnum];

/**
 *
 * @export
 * @interface ErrorList
 */
export interface ErrorList {
  /**
   *
   * @type {Array<ErrorListErrors>}
   * @memberof ErrorList
   */
  errors: Array<ErrorListErrors>;
}
/**
 *
 * @export
 * @interface ErrorListErrors
 */
export interface ErrorListErrors {
  /**
   * The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
   * @type {string}
   * @memberof ErrorListErrors
   */
  code: string;
  /**
   * A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
   * @type {string}
   * @memberof ErrorListErrors
   */
  title: string;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof ErrorListErrors
   */
  detail: string;
  /**
   *
   * @type {ErrorListMeta}
   * @memberof ErrorListErrors
   */
  meta?: ErrorListMeta;
}
/**
 * Additional data for customised error codes
 * @export
 * @interface ErrorListMeta
 */
export interface ErrorListMeta {
  /**
   * The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
   * @type {string}
   * @memberof ErrorListMeta
   */
  urn?: string;
}
/**
 *
 * @export
 * @interface LinksPaginated
 */
export interface LinksPaginated {
  /**
   * Fully qualified link that generated the current response document. https://self.example.com.au will be converted to https://self.example.com.au?page=1&page-size=25
   * @type {string}
   * @memberof LinksPaginated
   */
  self: string;
  /**
   * URI to the first page of this set. Mandatory if this response is not the first page
   * @type {string}
   * @memberof LinksPaginated
   */
  first?: string;
  /**
   * URI to the previous page of this set. Mandatory if this response is not the first page
   * @type {string}
   * @memberof LinksPaginated
   */
  prev?: string;
  /**
   * URI to the next page of this set. Mandatory if this response is not the last page
   * @type {string}
   * @memberof LinksPaginated
   */
  next?: string;
  /**
   * URI to the last page of this set. Mandatory if this response is not the last page
   * @type {string}
   * @memberof LinksPaginated
   */
  last?: string;
}
/**
 *
 * @export
 * @interface MetaPaginated
 */
export interface MetaPaginated {
  /**
   * The total number of records in the full set. See [pagination](#pagination).
   * @type {number}
   * @memberof MetaPaginated
   */
  totalRecords: number;
  /**
   * The total number of pages in the full set. See [pagination](#pagination).
   * @type {number}
   * @memberof MetaPaginated
   */
  totalPages: number;
}
/**
 *
 * @export
 * @interface ResponseCommonCustomerList
 */
export interface ResponseCommonCustomerList {
  /**
   *
   * @type {ResponseCommonCustomerListData}
   * @memberof ResponseCommonCustomerList
   */
  data: ResponseCommonCustomerListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof ResponseCommonCustomerList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof ResponseCommonCustomerList
   */
  meta?: MetaPaginated;
}
/**
 *
 * @export
 * @interface ResponseCommonCustomerListData
 */
export interface ResponseCommonCustomerListData {
  /**
   * The list of common customers returned returned. If the filter results in an empty set then this array may have no records
   * @type {Array<CommonCustomer>}
   * @memberof ResponseCommonCustomerListData
   */
  customers: Array<CommonCustomer>;
}
/**
 *
 * @export
 * @interface SecuredCdsDataApiError
 */
export interface SecuredCdsDataApiError {
  /**
   * The code of the error encountered.
   * @type {string}
   * @memberof SecuredCdsDataApiError
   */
  code: SecuredCdsDataApiErrorCodeEnum;
  /**
   * A short, human-readable summary of the problem.
   * @type {string}
   * @memberof SecuredCdsDataApiError
   */
  title: string;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof SecuredCdsDataApiError
   */
  detail: string;
  /**
   * \'Retry-After\' value if error code is \'THROTTLED_BY_DATA_HOLDER_ERROR\', which can either be a http-date or delay in seconds, as provided by data holder. Please note this value is not always provided by data holders, in which case this field will be null.
   * @type {string}
   * @memberof SecuredCdsDataApiError
   */
  retryAfter?: string;
}

export const SecuredCdsDataApiErrorCodeEnum = {
  BalanceRefreshError: 'BALANCE_REFRESH_ERROR',
  ConsumerPresentRefreshError: 'CONSUMER_PRESENT_REFRESH_ERROR',
  ThrottledByDataHolderError: 'THROTTLED_BY_DATA_HOLDER_ERROR',
} as const;

export type SecuredCdsDataApiErrorCodeEnum =
  typeof SecuredCdsDataApiErrorCodeEnum[keyof typeof SecuredCdsDataApiErrorCodeEnum];

/**
 * BankingApi - axios parameter creator
 * @export
 */
export const BankingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Obtain the list of banking accounts that consumers have consented to share across all data holders
     * @summary Get Banking Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingAccounts: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      adatreeConsumerAuthDate?: string,
      adatreeConsumerIpAddress?: string,
      adatreeConsumerUserAgent?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (isOwned !== undefined) {
        localVarQueryParameter['isOwned'] = isOwned;
      }

      if (openStatus !== undefined) {
        localVarQueryParameter['openStatus'] = openStatus;
      }

      if (productCategories) {
        localVarQueryParameter['productCategories'] = productCategories;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (adatreeConsumerAuthDate != null) {
        localVarHeaderParameter['Adatree-Consumer-Auth-Date'] = String(adatreeConsumerAuthDate);
      }

      if (adatreeConsumerIpAddress != null) {
        localVarHeaderParameter['Adatree-Consumer-Ip-Address'] = String(adatreeConsumerIpAddress);
      }

      if (adatreeConsumerUserAgent != null) {
        localVarHeaderParameter['Adatree-Consumer-User-Agent'] = String(adatreeConsumerUserAgent);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking direct debits that consumers have consented to share across all data holders
     * @summary Get Banking Direct Debits
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingDirectDebits: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/payments/direct-debits`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (isOwned !== undefined) {
        localVarQueryParameter['isOwned'] = isOwned;
      }

      if (openStatus !== undefined) {
        localVarQueryParameter['openStatus'] = openStatus;
      }

      if (productCategories) {
        localVarQueryParameter['productCategories'] = productCategories;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking payees that consumers have consented to share across all data holders
     * @summary Get Banking Payees
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the payee type field.
     * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingPayees: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      payeeIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/payees`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (types) {
        localVarQueryParameter['types'] = types;
      }

      if (payeeIds) {
        localVarQueryParameter['payeeIds'] = payeeIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking products across all data holders in banking industry
     * @summary Get Banking Products
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {Array<string>} [productIds] IDs of the specific products
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingProducts: async (
      dataHolderBrandIds?: Array<string>,
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      productIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/products`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (productCategories) {
        localVarQueryParameter['productCategories'] = productCategories;
      }

      if (productIds) {
        localVarQueryParameter['productIds'] = productIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking transactions that consumers have consented to share across all data holders
     * @summary Get Banking Transactions
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the type field.
     * @param {number} [minimumAmount] Used to filter results on the amount field
     * @param {number} [maximumAmount] Used to filter results on the amount field
     * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. Format is aligned to DateTimeString common type.
     * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. Format is aligned to DateTimeString common type.
     * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
     * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time. Format is aligned to DateTimeString common type.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingTransactions: async (
      useCaseIds?: Array<string>,
      accountIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      minimumAmount?: number,
      maximumAmount?: number,
      oldestRetrievalTime?: string,
      newestRetrievalTime?: string,
      oldestTime?: string,
      newestTime?: string,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/transactions`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (types) {
        localVarQueryParameter['types'] = types;
      }

      if (minimumAmount !== undefined) {
        localVarQueryParameter['minimumAmount'] = minimumAmount;
      }

      if (maximumAmount !== undefined) {
        localVarQueryParameter['maximumAmount'] = maximumAmount;
      }

      if (oldestRetrievalTime !== undefined) {
        localVarQueryParameter['oldestRetrievalTime'] = oldestRetrievalTime;
      }

      if (newestRetrievalTime !== undefined) {
        localVarQueryParameter['newestRetrievalTime'] = newestRetrievalTime;
      }

      if (oldestTime !== undefined) {
        localVarQueryParameter['oldestTime'] = oldestTime;
      }

      if (newestTime !== undefined) {
        localVarQueryParameter['newestTime'] = newestTime;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking scheduled payments that consumers have consented to share across all data holders
     * @summary Get Scheduled Payments
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledPayments: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/payments/scheduled`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (isOwned !== undefined) {
        localVarQueryParameter['isOwned'] = isOwned;
      }

      if (openStatus !== undefined) {
        localVarQueryParameter['openStatus'] = openStatus;
      }

      if (productCategories) {
        localVarQueryParameter['productCategories'] = productCategories;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BankingApi - functional programming interface
 * @export
 */
export const BankingApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = BankingApiAxiosParamCreator(configuration);
  return {
    /**
     * Obtain the list of banking accounts that consumers have consented to share across all data holders
     * @summary Get Banking Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      adatreeConsumerAuthDate?: string,
      adatreeConsumerIpAddress?: string,
      adatreeConsumerUserAgent?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingAccountList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        adatreeConsumerAuthDate,
        adatreeConsumerIpAddress,
        adatreeConsumerUserAgent,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of banking direct debits that consumers have consented to share across all data holders
     * @summary Get Banking Direct Debits
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingDirectDebits(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingDirectDebitAuthorisationList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingDirectDebits(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        accountIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of banking payees that consumers have consented to share across all data holders
     * @summary Get Banking Payees
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the payee type field.
     * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingPayees(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      payeeIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingPayeeList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingPayees(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        payeeIds,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of banking products across all data holders in banking industry
     * @summary Get Banking Products
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {Array<string>} [productIds] IDs of the specific products
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingProducts(
      dataHolderBrandIds?: Array<string>,
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      productIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingProductList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingProducts(
        dataHolderBrandIds,
        productCategories,
        productIds,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of banking transactions that consumers have consented to share across all data holders
     * @summary Get Banking Transactions
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the type field.
     * @param {number} [minimumAmount] Used to filter results on the amount field
     * @param {number} [maximumAmount] Used to filter results on the amount field
     * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. Format is aligned to DateTimeString common type.
     * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. Format is aligned to DateTimeString common type.
     * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
     * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time. Format is aligned to DateTimeString common type.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingTransactions(
      useCaseIds?: Array<string>,
      accountIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      minimumAmount?: number,
      maximumAmount?: number,
      oldestRetrievalTime?: string,
      newestRetrievalTime?: string,
      oldestTime?: string,
      newestTime?: string,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingTransactionList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getBankingTransactions(
        useCaseIds,
        accountIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        minimumAmount,
        maximumAmount,
        oldestRetrievalTime,
        newestRetrievalTime,
        oldestTime,
        newestTime,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of banking scheduled payments that consumers have consented to share across all data holders
     * @summary Get Scheduled Payments
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getScheduledPayments(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingScheduledPaymentsList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getScheduledPayments(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        accountIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * BankingApi - factory interface
 * @export
 */
export const BankingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = BankingApiFp(configuration);
  return {
    /**
     * Obtain the list of banking accounts that consumers have consented to share across all data holders
     * @summary Get Banking Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      adatreeConsumerAuthDate?: string,
      adatreeConsumerIpAddress?: string,
      adatreeConsumerUserAgent?: string,
      options?: any,
    ): AxiosPromise<BankingAccountList> {
      return localVarFp
        .getBankingAccounts(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          dataHolderBrandIds,
          isOwned,
          openStatus,
          productCategories,
          page,
          pageSize,
          adatreeConsumerAuthDate,
          adatreeConsumerIpAddress,
          adatreeConsumerUserAgent,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking direct debits that consumers have consented to share across all data holders
     * @summary Get Banking Direct Debits
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingDirectDebits(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingDirectDebitAuthorisationList> {
      return localVarFp
        .getBankingDirectDebits(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          accountIds,
          isOwned,
          openStatus,
          productCategories,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking payees that consumers have consented to share across all data holders
     * @summary Get Banking Payees
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the payee type field.
     * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingPayees(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      payeeIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingPayeeList> {
      return localVarFp
        .getBankingPayees(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          types,
          payeeIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking products across all data holders in banking industry
     * @summary Get Banking Products
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {Array<string>} [productIds] IDs of the specific products
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingProducts(
      dataHolderBrandIds?: Array<string>,
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      productIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingProductList> {
      return localVarFp
        .getBankingProducts(dataHolderBrandIds, productCategories, productIds, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking transactions that consumers have consented to share across all data holders
     * @summary Get Banking Transactions
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the type field.
     * @param {number} [minimumAmount] Used to filter results on the amount field
     * @param {number} [maximumAmount] Used to filter results on the amount field
     * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. Format is aligned to DateTimeString common type.
     * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. Format is aligned to DateTimeString common type.
     * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
     * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time. Format is aligned to DateTimeString common type.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingTransactions(
      useCaseIds?: Array<string>,
      accountIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      minimumAmount?: number,
      maximumAmount?: number,
      oldestRetrievalTime?: string,
      newestRetrievalTime?: string,
      oldestTime?: string,
      newestTime?: string,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingTransactionList> {
      return localVarFp
        .getBankingTransactions(
          useCaseIds,
          accountIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          types,
          minimumAmount,
          maximumAmount,
          oldestRetrievalTime,
          newestRetrievalTime,
          oldestTime,
          newestTime,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking scheduled payments that consumers have consented to share across all data holders
     * @summary Get Scheduled Payments
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getScheduledPayments(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingScheduledPaymentsList> {
      return localVarFp
        .getScheduledPayments(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          accountIds,
          isOwned,
          openStatus,
          productCategories,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BankingApi - object-oriented interface
 * @export
 * @class BankingApi
 * @extends {BaseAPI}
 */
export class BankingApi extends BaseAPI {
  /**
   * Obtain the list of banking accounts that consumers have consented to share across all data holders
   * @summary Get Banking Accounts
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
   * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
   * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
   * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
   * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingAccounts(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    isOwned?: boolean,
    openStatus?: 'OPEN' | 'CLOSED',
    productCategories?: Array<
      | 'BUSINESS_LOANS'
      | 'CRED_AND_CHRG_CARDS'
      | 'LEASES'
      | 'MARGIN_LOANS'
      | 'OVERDRAFTS'
      | 'PERS_LOANS'
      | 'REGULATED_TRUST_ACCOUNTS'
      | 'RESIDENTIAL_MORTGAGES'
      | 'TERM_DEPOSITS'
      | 'TRADE_FINANCE'
      | 'TRAVEL_CARDS'
      | 'TRANS_AND_SAVINGS_ACCOUNTS'
    >,
    page?: number,
    pageSize?: number,
    adatreeConsumerAuthDate?: string,
    adatreeConsumerIpAddress?: string,
    adatreeConsumerUserAgent?: string,
    options?: AxiosRequestConfig,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        adatreeConsumerAuthDate,
        adatreeConsumerIpAddress,
        adatreeConsumerUserAgent,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking direct debits that consumers have consented to share across all data holders
   * @summary Get Banking Direct Debits
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
   * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
   * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingDirectDebits(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    accountIds?: Array<string>,
    isOwned?: boolean,
    openStatus?: 'OPEN' | 'CLOSED',
    productCategories?: Array<
      | 'BUSINESS_LOANS'
      | 'CRED_AND_CHRG_CARDS'
      | 'LEASES'
      | 'MARGIN_LOANS'
      | 'OVERDRAFTS'
      | 'PERS_LOANS'
      | 'REGULATED_TRUST_ACCOUNTS'
      | 'RESIDENTIAL_MORTGAGES'
      | 'TERM_DEPOSITS'
      | 'TRADE_FINANCE'
      | 'TRAVEL_CARDS'
      | 'TRANS_AND_SAVINGS_ACCOUNTS'
    >,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingDirectDebits(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        accountIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking payees that consumers have consented to share across all data holders
   * @summary Get Banking Payees
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<string>} [types] Used to filter results on the payee type field.
   * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingPayees(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    types?: Array<string>,
    payeeIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingPayees(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        payeeIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking products across all data holders in banking industry
   * @summary Get Banking Products
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
   * @param {Array<string>} [productIds] IDs of the specific products
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingProducts(
    dataHolderBrandIds?: Array<string>,
    productCategories?: Array<
      | 'BUSINESS_LOANS'
      | 'CRED_AND_CHRG_CARDS'
      | 'LEASES'
      | 'MARGIN_LOANS'
      | 'OVERDRAFTS'
      | 'PERS_LOANS'
      | 'REGULATED_TRUST_ACCOUNTS'
      | 'RESIDENTIAL_MORTGAGES'
      | 'TERM_DEPOSITS'
      | 'TRADE_FINANCE'
      | 'TRAVEL_CARDS'
      | 'TRANS_AND_SAVINGS_ACCOUNTS'
    >,
    productIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingProducts(dataHolderBrandIds, productCategories, productIds, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking transactions that consumers have consented to share across all data holders
   * @summary Get Banking Transactions
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<string>} [types] Used to filter results on the type field.
   * @param {number} [minimumAmount] Used to filter results on the amount field
   * @param {number} [maximumAmount] Used to filter results on the amount field
   * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. Format is aligned to DateTimeString common type.
   * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. Format is aligned to DateTimeString common type.
   * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
   * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time. Format is aligned to DateTimeString common type.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingTransactions(
    useCaseIds?: Array<string>,
    accountIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    types?: Array<string>,
    minimumAmount?: number,
    maximumAmount?: number,
    oldestRetrievalTime?: string,
    newestRetrievalTime?: string,
    oldestTime?: string,
    newestTime?: string,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingTransactions(
        useCaseIds,
        accountIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        minimumAmount,
        maximumAmount,
        oldestRetrievalTime,
        newestRetrievalTime,
        oldestTime,
        newestTime,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking scheduled payments that consumers have consented to share across all data holders
   * @summary Get Scheduled Payments
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
   * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
   * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getScheduledPayments(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    accountIds?: Array<string>,
    isOwned?: boolean,
    openStatus?: 'OPEN' | 'CLOSED',
    productCategories?: Array<
      | 'BUSINESS_LOANS'
      | 'CRED_AND_CHRG_CARDS'
      | 'LEASES'
      | 'MARGIN_LOANS'
      | 'OVERDRAFTS'
      | 'PERS_LOANS'
      | 'REGULATED_TRUST_ACCOUNTS'
      | 'RESIDENTIAL_MORTGAGES'
      | 'TERM_DEPOSITS'
      | 'TRADE_FINANCE'
      | 'TRAVEL_CARDS'
      | 'TRANS_AND_SAVINGS_ACCOUNTS'
    >,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return BankingApiFp(this.configuration)
      .getScheduledPayments(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        accountIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * CommonApi - axios parameter creator
 * @export
 */
export const CommonApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Obtain a list of consumers that have consented to share across all data holders
     * @summary Get Customers
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<'person' | 'organisation'>} [customerUTypes] Used to filter results on the customerUType field applicable to customers. Any one of the valid values for this field can be supplied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomers: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      customerUTypes?: Array<'person' | 'organisation'>,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/common/customers`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (customerUTypes) {
        localVarQueryParameter['customerUTypes'] = customerUTypes;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * CommonApi - functional programming interface
 * @export
 */
export const CommonApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = CommonApiAxiosParamCreator(configuration);
  return {
    /**
     * Obtain a list of consumers that have consented to share across all data holders
     * @summary Get Customers
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<'person' | 'organisation'>} [customerUTypes] Used to filter results on the customerUType field applicable to customers. Any one of the valid values for this field can be supplied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getCustomers(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      customerUTypes?: Array<'person' | 'organisation'>,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ResponseCommonCustomerList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        customerUTypes,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * CommonApi - factory interface
 * @export
 */
export const CommonApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = CommonApiFp(configuration);
  return {
    /**
     * Obtain a list of consumers that have consented to share across all data holders
     * @summary Get Customers
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<'person' | 'organisation'>} [customerUTypes] Used to filter results on the customerUType field applicable to customers. Any one of the valid values for this field can be supplied.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getCustomers(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      customerUTypes?: Array<'person' | 'organisation'>,
      options?: any,
    ): AxiosPromise<ResponseCommonCustomerList> {
      return localVarFp
        .getCustomers(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          customerUTypes,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * CommonApi - object-oriented interface
 * @export
 * @class CommonApi
 * @extends {BaseAPI}
 */
export class CommonApi extends BaseAPI {
  /**
   * Obtain a list of consumers that have consented to share across all data holders
   * @summary Get Customers
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<'person' | 'organisation'>} [customerUTypes] Used to filter results on the customerUType field applicable to customers. Any one of the valid values for this field can be supplied.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof CommonApi
   */
  public getCustomers(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    customerUTypes?: Array<'person' | 'organisation'>,
    options?: AxiosRequestConfig,
  ) {
    return CommonApiFp(this.configuration)
      .getCustomers(useCaseIds, cdrArrangementIds, consentIds, consumerIds, dataHolderBrandIds, customerUTypes, options)
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EnergyApi - axios parameter creator
 * @export
 */
export const EnergyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Obtain the list of energy accounts that consumers have consented to share across all data holders
     * @summary Get Energy Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyAccounts: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/accounts`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy bills that consumers have consented to share across all data holders
     * @summary Get Energy Bills
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyBills: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      billingIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/bills`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (billingIds) {
        localVarQueryParameter['billingIds'] = billingIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy service points that consumers have consented to share across all data holders
     * @summary Get Electricity Service Points
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityServicePoints: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/electricity/servicepoints`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (servicePointIds) {
        localVarQueryParameter['servicePointIds'] = servicePointIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of electricity usage records that consumers have consented to share across all data holders.  Provide Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address, Adatree-Consumer-User-Agent headers and consumerId parameter with exactly one value  to trigger a realtime data update
     * @summary Get Electricity Usage
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {boolean} [refresh] toggle this on to retrieve data synchronously from the data holder. If using a Machine token, add the following headers to perform a consumer present request: Adatree-Consumer-User-Agent, Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address. If no headers are added, an unattended request will be made.
     * @param {string} [oldestDate] Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.
     * @param {string} [newestDate] Constrain the request to records with effective date at or before this date. If absent defaults to current date.
     * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityUsage: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      refresh?: boolean,
      oldestDate?: string,
      newestDate?: string,
      adatreeConsumerAuthDate?: string,
      adatreeConsumerIpAddress?: string,
      adatreeConsumerUserAgent?: string,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/electricity/usage`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (servicePointIds) {
        localVarQueryParameter['servicePointIds'] = servicePointIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      if (refresh !== undefined) {
        localVarQueryParameter['refresh'] = refresh;
      }

      if (oldestDate !== undefined) {
        localVarQueryParameter['oldestDate'] = oldestDate;
      }

      if (newestDate !== undefined) {
        localVarQueryParameter['newestDate'] = newestDate;
      }

      if (adatreeConsumerAuthDate != null) {
        localVarHeaderParameter['Adatree-Consumer-Auth-Date'] = String(adatreeConsumerAuthDate);
      }

      if (adatreeConsumerIpAddress != null) {
        localVarHeaderParameter['Adatree-Consumer-Ip-Address'] = String(adatreeConsumerIpAddress);
      }

      if (adatreeConsumerUserAgent != null) {
        localVarHeaderParameter['Adatree-Consumer-User-Agent'] = String(adatreeConsumerUserAgent);
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy invoices that consumers have consented to share across all data holders
     * @summary Get Energy Invoices
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyInvoices: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      invoiceIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/invoices`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (invoiceIds) {
        localVarQueryParameter['invoiceIds'] = invoiceIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy plans across all data holders
     * @summary Get Energy Plans
     * @param {Array<string>} [planIds] Used to filter results on the planId field.
     * @param {Array<'STANDING' | 'MARKET' | 'REGULATED'>} [planTypes] Used to filter results on the type field.
     * @param {Array<'ELECTRICITY' | 'GAS' | 'DUAL'>} [fuelTypes] Used to filter results on the fuel type field.
     * @param {'CURRENT' | 'FUTURE'} [effective] Used to filter results on the effective field.
     * @param {string} [updatedSince] Used to filter results on the updatedSince field
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyPlans: async (
      planIds?: Array<string>,
      planTypes?: Array<'STANDING' | 'MARKET' | 'REGULATED'>,
      fuelTypes?: Array<'ELECTRICITY' | 'GAS' | 'DUAL'>,
      effective?: 'CURRENT' | 'FUTURE',
      updatedSince?: string,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: AxiosRequestConfig = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/plans`;
      // use dummy base URL string because the URL constructor only accepts absolute URLs.
      const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }

      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      await setBearerAuthToObject(localVarHeaderParameter, configuration);

      if (planIds) {
        localVarQueryParameter['planIds'] = planIds;
      }

      if (planTypes) {
        localVarQueryParameter['planTypes'] = planTypes;
      }

      if (fuelTypes) {
        localVarQueryParameter['fuelTypes'] = fuelTypes;
      }

      if (effective !== undefined) {
        localVarQueryParameter['effective'] = effective;
      }

      if (updatedSince !== undefined) {
        localVarQueryParameter['updatedSince'] = updatedSince;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      setSearchParams(localVarUrlObj, localVarQueryParameter);
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: toPathString(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnergyApi - functional programming interface
 * @export
 */
export const EnergyApiFp = function (configuration?: Configuration) {
  const localVarAxiosParamCreator = EnergyApiAxiosParamCreator(configuration);
  return {
    /**
     * Obtain the list of energy accounts that consumers have consented to share across all data holders
     * @summary Get Energy Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyAccountList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnergyAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of energy bills that consumers have consented to share across all data holders
     * @summary Get Energy Bills
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyBills(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      billingIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyBillingList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnergyBills(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        billingIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of energy service points that consumers have consented to share across all data holders
     * @summary Get Electricity Service Points
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyElectricityServicePoints(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyServicePointList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnergyElectricityServicePoints(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of electricity usage records that consumers have consented to share across all data holders.  Provide Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address, Adatree-Consumer-User-Agent headers and consumerId parameter with exactly one value  to trigger a realtime data update
     * @summary Get Electricity Usage
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {boolean} [refresh] toggle this on to retrieve data synchronously from the data holder. If using a Machine token, add the following headers to perform a consumer present request: Adatree-Consumer-User-Agent, Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address. If no headers are added, an unattended request will be made.
     * @param {string} [oldestDate] Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.
     * @param {string} [newestDate] Constrain the request to records with effective date at or before this date. If absent defaults to current date.
     * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyElectricityUsage(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      refresh?: boolean,
      oldestDate?: string,
      newestDate?: string,
      adatreeConsumerAuthDate?: string,
      adatreeConsumerIpAddress?: string,
      adatreeConsumerUserAgent?: string,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyUsageList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnergyElectricityUsage(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        refresh,
        oldestDate,
        newestDate,
        adatreeConsumerAuthDate,
        adatreeConsumerIpAddress,
        adatreeConsumerUserAgent,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of energy invoices that consumers have consented to share across all data holders
     * @summary Get Energy Invoices
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyInvoices(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      invoiceIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyInvoiceList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnergyInvoices(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        invoiceIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
    /**
     * Obtain the list of energy plans across all data holders
     * @summary Get Energy Plans
     * @param {Array<string>} [planIds] Used to filter results on the planId field.
     * @param {Array<'STANDING' | 'MARKET' | 'REGULATED'>} [planTypes] Used to filter results on the type field.
     * @param {Array<'ELECTRICITY' | 'GAS' | 'DUAL'>} [fuelTypes] Used to filter results on the fuel type field.
     * @param {'CURRENT' | 'FUTURE'} [effective] Used to filter results on the effective field.
     * @param {string} [updatedSince] Used to filter results on the updatedSince field
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyPlans(
      planIds?: Array<string>,
      planTypes?: Array<'STANDING' | 'MARKET' | 'REGULATED'>,
      fuelTypes?: Array<'ELECTRICITY' | 'GAS' | 'DUAL'>,
      effective?: 'CURRENT' | 'FUTURE',
      updatedSince?: string,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: AxiosRequestConfig,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyPlanList>> {
      const localVarAxiosArgs = await localVarAxiosParamCreator.getEnergyPlans(
        planIds,
        planTypes,
        fuelTypes,
        effective,
        updatedSince,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
    },
  };
};

/**
 * EnergyApi - factory interface
 * @export
 */
export const EnergyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  const localVarFp = EnergyApiFp(configuration);
  return {
    /**
     * Obtain the list of energy accounts that consumers have consented to share across all data holders
     * @summary Get Energy Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyAccountList> {
      return localVarFp
        .getEnergyAccounts(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy bills that consumers have consented to share across all data holders
     * @summary Get Energy Bills
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyBills(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      billingIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyBillingList> {
      return localVarFp
        .getEnergyBills(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          billingIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy service points that consumers have consented to share across all data holders
     * @summary Get Electricity Service Points
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityServicePoints(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyServicePointList> {
      return localVarFp
        .getEnergyElectricityServicePoints(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          servicePointIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of electricity usage records that consumers have consented to share across all data holders.  Provide Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address, Adatree-Consumer-User-Agent headers and consumerId parameter with exactly one value  to trigger a realtime data update
     * @summary Get Electricity Usage
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {boolean} [refresh] toggle this on to retrieve data synchronously from the data holder. If using a Machine token, add the following headers to perform a consumer present request: Adatree-Consumer-User-Agent, Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address. If no headers are added, an unattended request will be made.
     * @param {string} [oldestDate] Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.
     * @param {string} [newestDate] Constrain the request to records with effective date at or before this date. If absent defaults to current date.
     * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
     * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityUsage(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      refresh?: boolean,
      oldestDate?: string,
      newestDate?: string,
      adatreeConsumerAuthDate?: string,
      adatreeConsumerIpAddress?: string,
      adatreeConsumerUserAgent?: string,
      options?: any,
    ): AxiosPromise<EnergyUsageList> {
      return localVarFp
        .getEnergyElectricityUsage(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          servicePointIds,
          dataHolderBrandIds,
          page,
          pageSize,
          refresh,
          oldestDate,
          newestDate,
          adatreeConsumerAuthDate,
          adatreeConsumerIpAddress,
          adatreeConsumerUserAgent,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy invoices that consumers have consented to share across all data holders
     * @summary Get Energy Invoices
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyInvoices(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      invoiceIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyInvoiceList> {
      return localVarFp
        .getEnergyInvoices(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          invoiceIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy plans across all data holders
     * @summary Get Energy Plans
     * @param {Array<string>} [planIds] Used to filter results on the planId field.
     * @param {Array<'STANDING' | 'MARKET' | 'REGULATED'>} [planTypes] Used to filter results on the type field.
     * @param {Array<'ELECTRICITY' | 'GAS' | 'DUAL'>} [fuelTypes] Used to filter results on the fuel type field.
     * @param {'CURRENT' | 'FUTURE'} [effective] Used to filter results on the effective field.
     * @param {string} [updatedSince] Used to filter results on the updatedSince field
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyPlans(
      planIds?: Array<string>,
      planTypes?: Array<'STANDING' | 'MARKET' | 'REGULATED'>,
      fuelTypes?: Array<'ELECTRICITY' | 'GAS' | 'DUAL'>,
      effective?: 'CURRENT' | 'FUTURE',
      updatedSince?: string,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyPlanList> {
      return localVarFp
        .getEnergyPlans(
          planIds,
          planTypes,
          fuelTypes,
          effective,
          updatedSince,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EnergyApi - object-oriented interface
 * @export
 * @class EnergyApi
 * @extends {BaseAPI}
 */
export class EnergyApi extends BaseAPI {
  /**
   * Obtain the list of energy accounts that consumers have consented to share across all data holders
   * @summary Get Energy Accounts
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyAccounts(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy bills that consumers have consented to share across all data holders
   * @summary Get Energy Bills
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyBills(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    billingIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyBills(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        billingIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy service points that consumers have consented to share across all data holders
   * @summary Get Electricity Service Points
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyElectricityServicePoints(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    servicePointIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyElectricityServicePoints(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of electricity usage records that consumers have consented to share across all data holders.  Provide Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address, Adatree-Consumer-User-Agent headers and consumerId parameter with exactly one value  to trigger a realtime data update
   * @summary Get Electricity Usage
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {boolean} [refresh] toggle this on to retrieve data synchronously from the data holder. If using a Machine token, add the following headers to perform a consumer present request: Adatree-Consumer-User-Agent, Adatree-Consumer-Auth-Date, Adatree-Consumer-Ip-Address. If no headers are added, an unattended request will be made.
   * @param {string} [oldestDate] Constrain the request to records with effective date at or after this date. If absent defaults to newest-date minus 24 months.
   * @param {string} [newestDate] Constrain the request to records with effective date at or before this date. If absent defaults to current date.
   * @param {string} [adatreeConsumerAuthDate] The time when the customer last logged in. Mandatory for consumer present calls using a Machine token.
   * @param {string} [adatreeConsumerIpAddress] The consumer\&#39;s original IP address. Mandatory for consumer present calls using a Machine token.
   * @param {string} [adatreeConsumerUserAgent] User Agent header of the consumer facing application. Mandatory for consumer present calls using a Machine token.
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyElectricityUsage(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    servicePointIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    refresh?: boolean,
    oldestDate?: string,
    newestDate?: string,
    adatreeConsumerAuthDate?: string,
    adatreeConsumerIpAddress?: string,
    adatreeConsumerUserAgent?: string,
    options?: AxiosRequestConfig,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyElectricityUsage(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        refresh,
        oldestDate,
        newestDate,
        adatreeConsumerAuthDate,
        adatreeConsumerIpAddress,
        adatreeConsumerUserAgent,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy invoices that consumers have consented to share across all data holders
   * @summary Get Energy Invoices
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyInvoices(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    invoiceIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyInvoices(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        invoiceIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy plans across all data holders
   * @summary Get Energy Plans
   * @param {Array<string>} [planIds] Used to filter results on the planId field.
   * @param {Array<'STANDING' | 'MARKET' | 'REGULATED'>} [planTypes] Used to filter results on the type field.
   * @param {Array<'ELECTRICITY' | 'GAS' | 'DUAL'>} [fuelTypes] Used to filter results on the fuel type field.
   * @param {'CURRENT' | 'FUTURE'} [effective] Used to filter results on the effective field.
   * @param {string} [updatedSince] Used to filter results on the updatedSince field
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyPlans(
    planIds?: Array<string>,
    planTypes?: Array<'STANDING' | 'MARKET' | 'REGULATED'>,
    fuelTypes?: Array<'ELECTRICITY' | 'GAS' | 'DUAL'>,
    effective?: 'CURRENT' | 'FUTURE',
    updatedSince?: string,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: AxiosRequestConfig,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyPlans(
        planIds,
        planTypes,
        fuelTypes,
        effective,
        updatedSince,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}
