// @ts-nocheck
// tslint:disable
/**
 * Adatree ADR Platform Data API
 * Adatree\'s Accredited Data Recipient (ADR) Platform Data API definition. Includes Banking and Energy.
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: engineering@adatree.com.au
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

import * as globalImportUrl from 'url';
import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Extra data and metadata provided by Adatree
 * @export
 * @interface Adatree
 */
export interface Adatree {
  /**
   * Consent Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  consentId: string;
  /**
   * Consumer Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  consumerId: string;
  /**
   * CDR Arrangement for related resource
   * @type {string}
   * @memberof Adatree
   */
  cdrArrangementId: string;
  /**
   * Data Holder Brand Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  dataHolderBrandId: string;
  /**
   * Use Case Id for related resource
   * @type {string}
   * @memberof Adatree
   */
  useCaseId: string;
}
/**
 *
 * @export
 * @interface BankingAccount
 */
export interface BankingAccount {
  /**
   * A unique ID of the account adhering to the standards for ID permanence
   * @type {string}
   * @memberof BankingAccount
   */
  accountId: string;
  /**
   * Date that the account was created (if known)
   * @type {string}
   * @memberof BankingAccount
   */
  creationDate?: string;
  /**
   * The display name of the account as defined by the bank. This should not incorporate account numbers or PANs. If it does the values should be masked according to the rules of the MaskedAccountString common type.
   * @type {string}
   * @memberof BankingAccount
   */
  displayName: string;
  /**
   * A customer supplied nickname for the account
   * @type {string}
   * @memberof BankingAccount
   */
  nickname?: string;
  /**
   * Open or closed status for the account. If not present then OPEN is assumed
   * @type {string}
   * @memberof BankingAccount
   */
  openStatus?: BankingAccountOpenStatusEnum;
  /**
   * Flag indicating that the customer associated with the authorisation is an owner of the account. Does not indicate sole ownership, however. If not present then \'true\' is assumed
   * @type {boolean}
   * @memberof BankingAccount
   */
  isOwned?: boolean;
  /**
   * A masked version of the account. Whether BSB/Account Number, Credit Card PAN or another number
   * @type {string}
   * @memberof BankingAccount
   */
  maskedNumber: string;
  /**
   *
   * @type {BankingProductCategory}
   * @memberof BankingAccount
   */
  productCategory: BankingProductCategory;
  /**
   * The unique identifier of the account as defined by the data holder (akin to model number for the account)
   * @type {string}
   * @memberof BankingAccount
   */
  productName: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingAccountOpenStatusEnum {
  OPEN = 'OPEN',
  CLOSED = 'CLOSED',
}

/**
 *
 * @export
 * @interface BankingAccountDetail
 */
export interface BankingAccountDetail {
  /**
   * A unique ID of the account adhering to the standards for ID permanence
   * @type {string}
   * @memberof BankingAccountDetail
   */
  accountId: string;
  /**
   * Date that the account was created (if known)
   * @type {string}
   * @memberof BankingAccountDetail
   */
  creationDate?: string;
  /**
   * The display name of the account as defined by the bank. This should not incorporate account numbers or PANs. If it does the values should be masked according to the rules of the MaskedAccountString common type.
   * @type {string}
   * @memberof BankingAccountDetail
   */
  displayName: string;
  /**
   * A customer supplied nickname for the account
   * @type {string}
   * @memberof BankingAccountDetail
   */
  nickname?: string;
  /**
   * Open or closed status for the account. If not present then OPEN is assumed
   * @type {string}
   * @memberof BankingAccountDetail
   */
  openStatus?: BankingAccountDetailOpenStatusEnum;
  /**
   * Flag indicating that the customer associated with the authorisation is an owner of the account. Does not indicate sole ownership, however. If not present then \'true\' is assumed
   * @type {boolean}
   * @memberof BankingAccountDetail
   */
  isOwned?: boolean;
  /**
   * A masked version of the account. Whether BSB/Account Number, Credit Card PAN or another number
   * @type {string}
   * @memberof BankingAccountDetail
   */
  maskedNumber: string;
  /**
   *
   * @type {BankingProductCategory}
   * @memberof BankingAccountDetail
   */
  productCategory: BankingProductCategory;
  /**
   * The unique identifier of the account as defined by the data holder (akin to model number for the account)
   * @type {string}
   * @memberof BankingAccountDetail
   */
  productName: string;
  /**
   * The unmasked BSB for the account. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetail
   */
  bsb?: string;
  /**
   * The unmasked account number for the account. Should not be supplied if the account number is a PAN requiring PCI compliance. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetail
   */
  accountNumber?: string;
  /**
   *
   * @type {BankingBalance}
   * @memberof BankingAccountDetail
   */
  balance?: BankingBalance;
  /**
   * Optional field to indicate if this account is part of a bundle that is providing additional benefit for to the customer
   * @type {string}
   * @memberof BankingAccountDetail
   */
  bundleName?: string;
  /**
   * The type of structure to present account specific fields.
   * @type {string}
   * @memberof BankingAccountDetail
   */
  specificAccountUType?: BankingAccountDetailSpecificAccountUTypeEnum;
  /**
   *
   * @type {Array<BankingTermDepositAccount>}
   * @memberof BankingAccountDetail
   */
  termDeposit?: Array<BankingTermDepositAccount>;
  /**
   *
   * @type {BankingCreditCardAccount}
   * @memberof BankingAccountDetail
   */
  creditCard?: BankingCreditCardAccount;
  /**
   *
   * @type {BankingLoanAccount}
   * @memberof BankingAccountDetail
   */
  loan?: BankingLoanAccount;
  /**
   * current rate to calculate interest earned being applied to deposit balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetail
   */
  depositRate?: string;
  /**
   * The current rate to calculate interest payable being applied to lending balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetail
   */
  lendingRate?: string;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductDepositRate>}
   * @memberof BankingAccountDetail
   */
  depositRates?: Array<BankingProductDepositRate>;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductLendingRateV2>}
   * @memberof BankingAccountDetail
   */
  lendingRates?: Array<BankingProductLendingRateV2>;
  /**
   * Array of features of the account based on the equivalent structure in Product Reference with the following additional field
   * @type {Array<BankingAccountProductFeature>}
   * @memberof BankingAccountDetail
   */
  features?: Array<BankingAccountProductFeature>;
  /**
   * Fees and charges applicable to the account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductFee>}
   * @memberof BankingAccountDetail
   */
  fees?: Array<BankingProductFee>;
  /**
   * The addresses for the account to be used for correspondence
   * @type {Array<CommonPhysicalAddress>}
   * @memberof BankingAccountDetail
   */
  addresses?: Array<CommonPhysicalAddress>;
  /**
   *
   * @type {Adatree}
   * @memberof BankingAccountDetail
   */
  adatree?: Adatree;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingAccountDetailOpenStatusEnum {
  OPEN = 'OPEN',
  CLOSED = 'CLOSED',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingAccountDetailSpecificAccountUTypeEnum {
  TermDeposit = 'termDeposit',
  CreditCard = 'creditCard',
  Loan = 'loan',
}

/**
 *
 * @export
 * @interface BankingAccountDetailAllOf
 */
export interface BankingAccountDetailAllOf {
  /**
   * The unmasked BSB for the account. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  bsb?: string;
  /**
   * The unmasked account number for the account. Should not be supplied if the account number is a PAN requiring PCI compliance. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  accountNumber?: string;
  /**
   *
   * @type {BankingBalance}
   * @memberof BankingAccountDetailAllOf
   */
  balance?: BankingBalance;
  /**
   * Optional field to indicate if this account is part of a bundle that is providing additional benefit for to the customer
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  bundleName?: string;
  /**
   * The type of structure to present account specific fields.
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  specificAccountUType?: BankingAccountDetailAllOfSpecificAccountUTypeEnum;
  /**
   *
   * @type {Array<BankingTermDepositAccount>}
   * @memberof BankingAccountDetailAllOf
   */
  termDeposit?: Array<BankingTermDepositAccount>;
  /**
   *
   * @type {BankingCreditCardAccount}
   * @memberof BankingAccountDetailAllOf
   */
  creditCard?: BankingCreditCardAccount;
  /**
   *
   * @type {BankingLoanAccount}
   * @memberof BankingAccountDetailAllOf
   */
  loan?: BankingLoanAccount;
  /**
   * current rate to calculate interest earned being applied to deposit balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  depositRate?: string;
  /**
   * The current rate to calculate interest payable being applied to lending balances as it stands at the time of the API call
   * @type {string}
   * @memberof BankingAccountDetailAllOf
   */
  lendingRate?: string;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductDepositRate>}
   * @memberof BankingAccountDetailAllOf
   */
  depositRates?: Array<BankingProductDepositRate>;
  /**
   * Fully described deposit rates for this account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductLendingRateV2>}
   * @memberof BankingAccountDetailAllOf
   */
  lendingRates?: Array<BankingProductLendingRateV2>;
  /**
   * Array of features of the account based on the equivalent structure in Product Reference with the following additional field
   * @type {Array<BankingAccountProductFeature>}
   * @memberof BankingAccountDetailAllOf
   */
  features?: Array<BankingAccountProductFeature>;
  /**
   * Fees and charges applicable to the account based on the equivalent structure in Product Reference
   * @type {Array<BankingProductFee>}
   * @memberof BankingAccountDetailAllOf
   */
  fees?: Array<BankingProductFee>;
  /**
   * The addresses for the account to be used for correspondence
   * @type {Array<CommonPhysicalAddress>}
   * @memberof BankingAccountDetailAllOf
   */
  addresses?: Array<CommonPhysicalAddress>;
  /**
   *
   * @type {Adatree}
   * @memberof BankingAccountDetailAllOf
   */
  adatree?: Adatree;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingAccountDetailAllOfSpecificAccountUTypeEnum {
  TermDeposit = 'termDeposit',
  CreditCard = 'creditCard',
  Loan = 'loan',
}

/**
 *
 * @export
 * @interface BankingAccountList
 */
export interface BankingAccountList {
  /**
   *
   * @type {BankingAccountListData}
   * @memberof BankingAccountList
   */
  data: BankingAccountListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingAccountList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingAccountList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingAccountListData
 */
export interface BankingAccountListData {
  /**
   * The list of accounts returned. If the filter results in an empty set then this array may have no records
   * @type {Array<BankingAccountDetail>}
   * @memberof BankingAccountListData
   */
  accounts: Array<BankingAccountDetail>;
}
/**
 * Array of features of the account based on the equivalent structure in Product Reference with the following additional field
 * @export
 * @interface BankingAccountProductFeature
 */
export interface BankingAccountProductFeature {
  /**
   * The type of feature described
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  featureType: BankingAccountProductFeatureFeatureTypeEnum;
  /**
   * Generic field containing additional information relevant to the [featureType](#tocSproductfeaturetypedoc) specified. Whether mandatory or not is dependent on the value of the [featureType.](#tocSproductfeaturetypedoc)
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the feature. Mandatory if the [feature type](#tocSproductfeaturetypedoc) is set to OTHER
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this feature
   * @type {string}
   * @memberof BankingAccountProductFeature
   */
  additionalInfoUri?: string;
  /**
   * True if the feature is already activated and false if the feature is available for activation. Defaults to true if absent. (note this is an additional field appended to the feature object defined in the Product Reference payload)
   * @type {boolean}
   * @memberof BankingAccountProductFeature
   */
  isActivated?: boolean;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingAccountProductFeatureFeatureTypeEnum {
  ADDITIONALCARDS = 'ADDITIONAL_CARDS',
  BALANCETRANSFERS = 'BALANCE_TRANSFERS',
  BILLPAYMENT = 'BILL_PAYMENT',
  BONUSREWARDS = 'BONUS_REWARDS',
  CARDACCESS = 'CARD_ACCESS',
  COMPLEMENTARYPRODUCTDISCOUNTS = 'COMPLEMENTARY_PRODUCT_DISCOUNTS',
  DIGITALBANKING = 'DIGITAL_BANKING',
  DIGITALWALLET = 'DIGITAL_WALLET',
  DONATEINTEREST = 'DONATE_INTEREST',
  FREETXNS = 'FREE_TXNS',
  FREETXNSALLOWANCE = 'FREE_TXNS_ALLOWANCE',
  INSURANCE = 'INSURANCE',
  INTERESTFREE = 'INTEREST_FREE',
  INTERESTFREETRANSFERS = 'INTEREST_FREE_TRANSFERS',
  LOYALTYPROGRAM = 'LOYALTY_PROGRAM',
  NOTIFICATIONS = 'NOTIFICATIONS',
  NPPENABLED = 'NPP_ENABLED',
  NPPPAYID = 'NPP_PAYID',
  OFFSET = 'OFFSET',
  OVERDRAFT = 'OVERDRAFT',
  REDRAW = 'REDRAW',
  UNLIMITEDTXNS = 'UNLIMITED_TXNS',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface BankingAccountProductFeatureAllOf
 */
export interface BankingAccountProductFeatureAllOf {
  /**
   * True if the feature is already activated and false if the feature is available for activation. Defaults to true if absent. (note this is an additional field appended to the feature object defined in the Product Reference payload)
   * @type {boolean}
   * @memberof BankingAccountProductFeatureAllOf
   */
  isActivated?: boolean;
}
/**
 *
 * @export
 * @interface BankingAuthorisedEntity
 */
export interface BankingAuthorisedEntity {
  /**
   * Description of the authorised entity derived from previously executed direct debits
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  description?: string;
  /**
   * Name of the financial institution through which the direct debit will be executed. Is required unless the payment is made via a credit card scheme
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  financialInstitution?: string;
  /**
   * Australian Business Number for the authorised entity
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  abn?: string;
  /**
   * Australian Company Number for the authorised entity
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  acn?: string;
  /**
   * Australian Registered Body Number for the authorised entity
   * @type {string}
   * @memberof BankingAuthorisedEntity
   */
  arbn?: string;
}
/**
 *
 * @export
 * @interface BankingBalance
 */
export interface BankingBalance {
  /**
   * The balance of the account at this time. Should align to the balance available via other channels such as Internet Banking. Assumed to be negative if the customer has money owing
   * @type {string}
   * @memberof BankingBalance
   */
  currentBalance: string;
  /**
   * Balance representing the amount of funds available for transfer. Assumed to be zero or positive
   * @type {string}
   * @memberof BankingBalance
   */
  availableBalance: string;
  /**
   * Object representing the maximum amount of credit that is available for this account. Assumed to be zero if absent
   * @type {string}
   * @memberof BankingBalance
   */
  creditLimit?: string;
  /**
   * Object representing the available limit amortised according to payment schedule. Assumed to be zero if absent
   * @type {string}
   * @memberof BankingBalance
   */
  amortisedLimit?: string;
  /**
   * The currency for the balance amounts. If absent assumed to be AUD
   * @type {string}
   * @memberof BankingBalance
   */
  currency?: string;
  /**
   * Optional array of balances for the account in other currencies. Included to support accounts that support multi-currency purses such as Travel Cards
   * @type {Array<BankingBalancePurse>}
   * @memberof BankingBalance
   */
  purses?: Array<BankingBalancePurse>;
}
/**
 *
 * @export
 * @interface BankingBalancePurse
 */
export interface BankingBalancePurse {
  /**
   * The balance available for this additional currency purse
   * @type {string}
   * @memberof BankingBalancePurse
   */
  amount: string;
  /**
   * The currency for the purse
   * @type {string}
   * @memberof BankingBalancePurse
   */
  currency?: string;
}
/**
 *
 * @export
 * @interface BankingBillerPayee
 */
export interface BankingBillerPayee {
  /**
   * BPAY Biller Code of the Biller
   * @type {string}
   * @memberof BankingBillerPayee
   */
  billerCode: string;
  /**
   * BPAY CRN of the Biller (if available).<br/>Where the CRN contains sensitive information, it should be masked in line with how the Data Holder currently displays account identifiers in their existing online banking channels. If the contents of the CRN match the format of a Credit Card PAN they should be masked according to the rules applicable for MaskedPANString. If the contents are otherwise sensitive, then it should be masked using the rules applicable for the MaskedAccountString common type.
   * @type {string}
   * @memberof BankingBillerPayee
   */
  crn?: string;
  /**
   * Name of the Biller
   * @type {string}
   * @memberof BankingBillerPayee
   */
  billerName: string;
}
/**
 *
 * @export
 * @interface BankingCreditCardAccount
 */
export interface BankingCreditCardAccount {
  /**
   * The minimum payment amount due for the next card payment
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  minPaymentAmount: string;
  /**
   * The amount due for the next card payment
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  paymentDueAmount: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  paymentCurrency?: string;
  /**
   * Date that the next payment for the card is due
   * @type {string}
   * @memberof BankingCreditCardAccount
   */
  paymentDueDate: string;
}
/**
 *
 * @export
 * @interface BankingDirectDebit
 */
export interface BankingDirectDebit {
  /**
   * A unique ID of the account adhering to the standards for ID permanence.
   * @type {string}
   * @memberof BankingDirectDebit
   */
  accountId: string;
  /**
   *
   * @type {BankingAuthorisedEntity}
   * @memberof BankingDirectDebit
   */
  authorisedEntity: BankingAuthorisedEntity;
  /**
   * The date and time of the last debit executed under this authorisation
   * @type {string}
   * @memberof BankingDirectDebit
   */
  lastDebitDateTime?: string;
  /**
   * The amount of the last debit executed under this authorisation
   * @type {string}
   * @memberof BankingDirectDebit
   */
  lastDebitAmount?: string;
  /**
   *
   * @type {Adatree}
   * @memberof BankingDirectDebit
   */
  adatree?: Adatree;
}
/**
 *
 * @export
 * @interface BankingDirectDebitAuthorisationList
 */
export interface BankingDirectDebitAuthorisationList {
  /**
   *
   * @type {BankingDirectDebitAuthorisationListData}
   * @memberof BankingDirectDebitAuthorisationList
   */
  data: BankingDirectDebitAuthorisationListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingDirectDebitAuthorisationList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingDirectDebitAuthorisationList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingDirectDebitAuthorisationListData
 */
export interface BankingDirectDebitAuthorisationListData {
  /**
   * The list of authorisations returned
   * @type {Array<BankingDirectDebit>}
   * @memberof BankingDirectDebitAuthorisationListData
   */
  directDebitAuthorisations: Array<BankingDirectDebit>;
}
/**
 *
 * @export
 * @interface BankingDomesticPayee
 */
export interface BankingDomesticPayee {
  /**
   * Type of account object included. Valid values are: **account** A standard Australian account defined by BSB/Account Number. **card** A credit or charge card to pay to (note that PANs are masked). **payId** A PayID recognised by NPP
   * @type {string}
   * @memberof BankingDomesticPayee
   */
  payeeAccountUType: BankingDomesticPayeePayeeAccountUTypeEnum;
  /**
   *
   * @type {BankingDomesticPayeeAccount}
   * @memberof BankingDomesticPayee
   */
  account?: BankingDomesticPayeeAccount;
  /**
   *
   * @type {BankingDomesticPayeeCard}
   * @memberof BankingDomesticPayee
   */
  card?: BankingDomesticPayeeCard;
  /**
   *
   * @type {BankingDomesticPayeePayId}
   * @memberof BankingDomesticPayee
   */
  payId?: BankingDomesticPayeePayId;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingDomesticPayeePayeeAccountUTypeEnum {
  Account = 'account',
  Card = 'card',
  PayId = 'payId',
}

/**
 *
 * @export
 * @interface BankingDomesticPayeeAccount
 */
export interface BankingDomesticPayeeAccount {
  /**
   * Name of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeAccount
   */
  accountName?: string;
  /**
   * BSB of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeAccount
   */
  bsb: string;
  /**
   * Number of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeAccount
   */
  accountNumber: string;
}
/**
 *
 * @export
 * @interface BankingDomesticPayeeCard
 */
export interface BankingDomesticPayeeCard {
  /**
   * Name of the account to pay to
   * @type {string}
   * @memberof BankingDomesticPayeeCard
   */
  cardNumber: string;
}
/**
 *
 * @export
 * @interface BankingDomesticPayeePayId
 */
export interface BankingDomesticPayeePayId {
  /**
   * The name assigned to the PayID by the owner of the PayID
   * @type {string}
   * @memberof BankingDomesticPayeePayId
   */
  name?: string;
  /**
   * The identifier of the PayID (dependent on type)
   * @type {string}
   * @memberof BankingDomesticPayeePayId
   */
  identifier: string;
  /**
   * The type of the PayID
   * @type {string}
   * @memberof BankingDomesticPayeePayId
   */
  type: BankingDomesticPayeePayIdTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingDomesticPayeePayIdTypeEnum {
  ABN = 'ABN',
  EMAIL = 'EMAIL',
  ORGIDENTIFIER = 'ORG_IDENTIFIER',
  TELEPHONE = 'TELEPHONE',
}

/**
 *
 * @export
 * @interface BankingInternationalPayee
 */
export interface BankingInternationalPayee {
  /**
   *
   * @type {BankingInternationalPayeeBeneficiaryDetails}
   * @memberof BankingInternationalPayee
   */
  beneficiaryDetails: BankingInternationalPayeeBeneficiaryDetails;
  /**
   *
   * @type {BankingInternationalPayeeBankDetails}
   * @memberof BankingInternationalPayee
   */
  bankDetails: BankingInternationalPayeeBankDetails;
}
/**
 *
 * @export
 * @interface BankingInternationalPayeeBankDetails
 */
export interface BankingInternationalPayeeBankDetails {
  /**
   * Country of the recipient institution. A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  country: string;
  /**
   * Account Targeted for payment
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  accountNumber: string;
  /**
   *
   * @type {BankingInternationalPayeeBankDetailsBankAddress}
   * @memberof BankingInternationalPayeeBankDetails
   */
  bankAddress?: BankingInternationalPayeeBankDetailsBankAddress;
  /**
   * Swift bank code.  Aligns with standard [ISO 9362](https://www.iso.org/standard/60390.html)
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  beneficiaryBankBIC?: string;
  /**
   * Number for Fedwire payment (Federal Reserve Wire Network)
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  fedWireNumber?: string;
  /**
   * Sort code used for account identification in some jurisdictions
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  sortCode?: string;
  /**
   * Number for the Clearing House Interbank Payments System
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  chipNumber?: string;
  /**
   * International bank routing number
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  routingNumber?: string;
  /**
   * The legal entity identifier (LEI) for the beneficiary.  Aligns with [ISO 17442](https://www.iso.org/standard/59771.html)
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetails
   */
  legalEntityIdentifier?: string;
}
/**
 *
 * @export
 * @interface BankingInternationalPayeeBankDetailsBankAddress
 */
export interface BankingInternationalPayeeBankDetailsBankAddress {
  /**
   * Name of the recipient Bank
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetailsBankAddress
   */
  name: string;
  /**
   * Address of the recipient Bank
   * @type {string}
   * @memberof BankingInternationalPayeeBankDetailsBankAddress
   */
  address: string;
}
/**
 *
 * @export
 * @interface BankingInternationalPayeeBeneficiaryDetails
 */
export interface BankingInternationalPayeeBeneficiaryDetails {
  /**
   * Name of the beneficiary
   * @type {string}
   * @memberof BankingInternationalPayeeBeneficiaryDetails
   */
  name?: string;
  /**
   * Country where the beneficiary resides. A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code
   * @type {string}
   * @memberof BankingInternationalPayeeBeneficiaryDetails
   */
  country: string;
  /**
   * Response message for the payment
   * @type {string}
   * @memberof BankingInternationalPayeeBeneficiaryDetails
   */
  message?: string;
}
/**
 *
 * @export
 * @interface BankingLoanAccount
 */
export interface BankingLoanAccount {
  /**
   * Optional original start date for the loan
   * @type {string}
   * @memberof BankingLoanAccount
   */
  originalStartDate?: string;
  /**
   * Optional original loan value
   * @type {string}
   * @memberof BankingLoanAccount
   */
  originalLoanAmount?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  originalLoanCurrency?: string;
  /**
   * Date that the loan is due to be repaid in full
   * @type {string}
   * @memberof BankingLoanAccount
   */
  loanEndDate: string;
  /**
   * Next date that an instalment is required
   * @type {string}
   * @memberof BankingLoanAccount
   */
  nextInstalmentDate: string;
  /**
   * Minimum amount of next instalment
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minInstalmentAmount?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minInstalmentCurrency?: string;
  /**
   * Maximum amount of funds that can be redrawn. If not present redraw is not available even if the feature exists for the account
   * @type {string}
   * @memberof BankingLoanAccount
   */
  maxRedraw?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  maxRedrawCurrency?: string;
  /**
   * Minimum redraw amount
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minRedraw?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingLoanAccount
   */
  minRedrawCurrency?: string;
  /**
   * Set to true if one or more offset accounts are configured for this loan account
   * @type {boolean}
   * @memberof BankingLoanAccount
   */
  offsetAccountEnabled?: boolean;
  /**
   * The accountIDs of the configured offset accounts attached to this loan. Only offset accounts that can be accessed under the current authorisation should be included. It is expected behaviour that offsetAccountEnabled is set to true but the offsetAccountIds field is absent or empty. This represents a situation where an offset account exists but details can not be accessed under the current authorisation
   * @type {Array<string>}
   * @memberof BankingLoanAccount
   */
  offsetAccountIds?: Array<string>;
  /**
   * Options in place for repayments. If absent defaults to PRINCIPAL_AND_INTEREST
   * @type {string}
   * @memberof BankingLoanAccount
   */
  repaymentType?: BankingLoanAccountRepaymentTypeEnum;
  /**
   * The expected or required repayment frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingLoanAccount
   */
  repaymentFrequency: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingLoanAccountRepaymentTypeEnum {
  INTERESTONLY = 'INTEREST_ONLY',
  PRINCIPALANDINTEREST = 'PRINCIPAL_AND_INTEREST',
}

/**
 *
 * @export
 * @interface BankingPayee
 */
export interface BankingPayee {
  /**
   * ID of the payee adhering to the rules of ID permanence
   * @type {string}
   * @memberof BankingPayee
   */
  payeeId: string;
  /**
   * The short display name of the payee as provided by the customer. Where a customer has not provided a nickname, a display name derived by the bank for the payee consistent with existing digital banking channels
   * @type {string}
   * @memberof BankingPayee
   */
  nickname: string;
  /**
   * A description of the payee provided by the customer
   * @type {string}
   * @memberof BankingPayee
   */
  description?: string;
  /**
   * The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. wallet
   * @type {string}
   * @memberof BankingPayee
   */
  type: BankingPayeeTypeEnum;
  /**
   * The date the payee was created by the customer
   * @type {string}
   * @memberof BankingPayee
   */
  creationDate?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingPayeeTypeEnum {
  BILLER = 'BILLER',
  DOMESTIC = 'DOMESTIC',
  INTERNATIONAL = 'INTERNATIONAL',
}

/**
 *
 * @export
 * @interface BankingPayeeDetail
 */
export interface BankingPayeeDetail {
  /**
   * ID of the payee adhering to the rules of ID permanence
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  payeeId: string;
  /**
   * The short display name of the payee as provided by the customer. Where a customer has not provided a nickname, a display name derived by the bank for the payee consistent with existing digital banking channels
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  nickname: string;
  /**
   * A description of the payee provided by the customer
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  description?: string;
  /**
   * The type of payee.<br/>DOMESTIC means a registered payee for domestic payments including NPP. <br/>INTERNATIONAL means a registered payee for international payments. <br/>BILLER means a registered payee for BPAY. wallet
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  type: BankingPayeeDetailTypeEnum;
  /**
   * The date the payee was created by the customer
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  creationDate?: string;
  /**
   * Type of object included that describes the payee in detail
   * @type {string}
   * @memberof BankingPayeeDetail
   */
  payeeUType: BankingPayeeDetailPayeeUTypeEnum;
  /**
   *
   * @type {BankingBillerPayee}
   * @memberof BankingPayeeDetail
   */
  biller?: BankingBillerPayee;
  /**
   *
   * @type {BankingDomesticPayee}
   * @memberof BankingPayeeDetail
   */
  domestic?: BankingDomesticPayee;
  /**
   *
   * @type {BankingInternationalPayee}
   * @memberof BankingPayeeDetail
   */
  international?: BankingInternationalPayee;
  /**
   *
   * @type {Adatree}
   * @memberof BankingPayeeDetail
   */
  adatree?: Adatree;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingPayeeDetailTypeEnum {
  BILLER = 'BILLER',
  DOMESTIC = 'DOMESTIC',
  INTERNATIONAL = 'INTERNATIONAL',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingPayeeDetailPayeeUTypeEnum {
  Biller = 'biller',
  Domestic = 'domestic',
  International = 'international',
}

/**
 *
 * @export
 * @interface BankingPayeeDetailAllOf
 */
export interface BankingPayeeDetailAllOf {
  /**
   * Type of object included that describes the payee in detail
   * @type {string}
   * @memberof BankingPayeeDetailAllOf
   */
  payeeUType: BankingPayeeDetailAllOfPayeeUTypeEnum;
  /**
   *
   * @type {BankingBillerPayee}
   * @memberof BankingPayeeDetailAllOf
   */
  biller?: BankingBillerPayee;
  /**
   *
   * @type {BankingDomesticPayee}
   * @memberof BankingPayeeDetailAllOf
   */
  domestic?: BankingDomesticPayee;
  /**
   *
   * @type {BankingInternationalPayee}
   * @memberof BankingPayeeDetailAllOf
   */
  international?: BankingInternationalPayee;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingPayeeDetailAllOfPayeeUTypeEnum {
  Biller = 'biller',
  Domestic = 'domestic',
  International = 'international',
}

/**
 *
 * @export
 * @interface BankingPayeeDetailAllOf1
 */
export interface BankingPayeeDetailAllOf1 {
  /**
   *
   * @type {Adatree}
   * @memberof BankingPayeeDetailAllOf1
   */
  adatree?: Adatree;
}
/**
 *
 * @export
 * @interface BankingPayeeList
 */
export interface BankingPayeeList {
  /**
   *
   * @type {BankingPayeeListData}
   * @memberof BankingPayeeList
   */
  data: BankingPayeeListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingPayeeList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingPayeeList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingPayeeListData
 */
export interface BankingPayeeListData {
  /**
   *
   * @type {Array<BankingPayeeDetail>}
   * @memberof BankingPayeeListData
   */
  payees: Array<BankingPayeeDetail>;
}
/**
 * The category to which a product or account belongs. See [here](#product-categories) for more details
 * @export
 * @enum {string}
 */
export enum BankingProductCategory {
  BUSINESSLOANS = 'BUSINESS_LOANS',
  CREDANDCHRGCARDS = 'CRED_AND_CHRG_CARDS',
  LEASES = 'LEASES',
  MARGINLOANS = 'MARGIN_LOANS',
  OVERDRAFTS = 'OVERDRAFTS',
  PERSLOANS = 'PERS_LOANS',
  REGULATEDTRUSTACCOUNTS = 'REGULATED_TRUST_ACCOUNTS',
  RESIDENTIALMORTGAGES = 'RESIDENTIAL_MORTGAGES',
  TERMDEPOSITS = 'TERM_DEPOSITS',
  TRADEFINANCE = 'TRADE_FINANCE',
  TRAVELCARDS = 'TRAVEL_CARDS',
  TRANSANDSAVINGSACCOUNTS = 'TRANS_AND_SAVINGS_ACCOUNTS',
}

/**
 *
 * @export
 * @interface BankingProductDepositRate
 */
export interface BankingProductDepositRate {
  /**
   * The type of rate (base, bonus, etc). See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  depositRateType: BankingProductDepositRateDepositRateTypeEnum;
  /**
   * The rate to be applied
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  rate: string;
  /**
   * The period after which the rate is applied to the balance to calculate the amount due for the period. Calculation of the amount is often daily (as balances may change) but accumulated until the total amount is \'applied\' to the account (see applicationFrequency). Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  calculationFrequency?: string;
  /**
   * The period after which the calculated amount(s) (see calculationFrequency) are \'applied\' (i.e. debited or credited) to the account. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  applicationFrequency?: string;
  /**
   * Rate tiers applicable for this rate
   * @type {Array<BankingProductRateTierV3>}
   * @memberof BankingProductDepositRate
   */
  tiers?: Array<BankingProductRateTierV3>;
  /**
   * Generic field containing additional information relevant to the [depositRateType](#tocSproductdepositratetypedoc) specified. Whether mandatory or not is dependent on the value of [depositRateType](#tocSproductdepositratetypedoc)
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the rate
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this rate
   * @type {string}
   * @memberof BankingProductDepositRate
   */
  additionalInfoUri?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingProductDepositRateDepositRateTypeEnum {
  BONUS = 'BONUS',
  BUNDLEBONUS = 'BUNDLE_BONUS',
  FIXED = 'FIXED',
  FLOATING = 'FLOATING',
  INTRODUCTORY = 'INTRODUCTORY',
  MARKETLINKED = 'MARKET_LINKED',
  VARIABLE = 'VARIABLE',
}

/**
 *
 * @export
 * @interface BankingProductDiscount
 */
export interface BankingProductDiscount {
  /**
   * Description of the discount
   * @type {string}
   * @memberof BankingProductDiscount
   */
  description: string;
  /**
   * The type of discount. See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductDiscount
   */
  discountType: BankingProductDiscountDiscountTypeEnum;
  /**
   * Dollar value of the discount. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory.
   * @type {string}
   * @memberof BankingProductDiscount
   */
  amount?: string;
  /**
   * A discount rate calculated based on a proportion of the balance. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
   * @type {string}
   * @memberof BankingProductDiscount
   */
  balanceRate?: string;
  /**
   * A discount rate calculated based on a proportion of a transaction. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory
   * @type {string}
   * @memberof BankingProductDiscount
   */
  transactionRate?: string;
  /**
   * A discount rate calculated based on a proportion of the calculated interest accrued on the account. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
   * @type {string}
   * @memberof BankingProductDiscount
   */
  accruedRate?: string;
  /**
   * A discount rate calculated based on a proportion of the fee to which this discount is attached. Note that the currency of the fee discount is expected to be the same as the currency of the fee itself. One of amount, balanceRate, transactionRate, accruedRate and feeRate is mandatory. Unless noted in additionalInfo, assumes the application and calculation frequency are the same as the corresponding fee
   * @type {string}
   * @memberof BankingProductDiscount
   */
  feeRate?: string;
  /**
   * Generic field containing additional information relevant to the [discountType](#tocSproductdiscounttypedoc) specified. Whether mandatory or not is dependent on the value of [discountType](#tocSproductdiscounttypedoc)
   * @type {string}
   * @memberof BankingProductDiscount
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the discount
   * @type {string}
   * @memberof BankingProductDiscount
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this discount
   * @type {string}
   * @memberof BankingProductDiscount
   */
  additionalInfoUri?: string;
  /**
   * Eligibility constraints that apply to this discount. Mandatory if ``discountType`` is ``ELIGIBILITY_ONLY``.
   * @type {Array<BankingProductDiscountEligibility>}
   * @memberof BankingProductDiscount
   */
  eligibility?: Array<BankingProductDiscountEligibility>;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingProductDiscountDiscountTypeEnum {
  BALANCE = 'BALANCE',
  DEPOSITS = 'DEPOSITS',
  ELIGIBILITYONLY = 'ELIGIBILITY_ONLY',
  FEECAP = 'FEE_CAP',
  PAYMENTS = 'PAYMENTS',
}

/**
 *
 * @export
 * @interface BankingProductDiscountEligibility
 */
export interface BankingProductDiscountEligibility {
  /**
   * The type of the specific eligibility constraint for a discount
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  discountEligibilityType: BankingProductDiscountEligibilityDiscountEligibilityTypeEnum;
  /**
   * Generic field containing additional information relevant to the [discountEligibilityType](#tocSproductdiscounteligibilitydoc) specified. Whether mandatory or not is dependent on the value of [discountEligibilityType](#tocSproductdiscounteligibilitydoc)
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  additionalValue?: string;
  /**
   * Display text providing more information on this eligibility constraint. Whether mandatory or not is dependent on the value of [discountEligibilityType](#tocSproductdiscounteligibilitydoc)
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this eligibility constraint
   * @type {string}
   * @memberof BankingProductDiscountEligibility
   */
  additionalInfoUri?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingProductDiscountEligibilityDiscountEligibilityTypeEnum {
  BUSINESS = 'BUSINESS',
  EMPLOYMENTSTATUS = 'EMPLOYMENT_STATUS',
  INTRODUCTORY = 'INTRODUCTORY',
  MAXAGE = 'MAX_AGE',
  MINAGE = 'MIN_AGE',
  MININCOME = 'MIN_INCOME',
  MINTURNOVER = 'MIN_TURNOVER',
  NATURALPERSON = 'NATURAL_PERSON',
  PENSIONRECIPIENT = 'PENSION_RECIPIENT',
  RESIDENCYSTATUS = 'RESIDENCY_STATUS',
  STAFF = 'STAFF',
  STUDENT = 'STUDENT',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface BankingProductFeature
 */
export interface BankingProductFeature {
  /**
   * The type of feature described
   * @type {string}
   * @memberof BankingProductFeature
   */
  featureType: BankingProductFeatureFeatureTypeEnum;
  /**
   * Generic field containing additional information relevant to the [featureType](#tocSproductfeaturetypedoc) specified. Whether mandatory or not is dependent on the value of the [featureType.](#tocSproductfeaturetypedoc)
   * @type {string}
   * @memberof BankingProductFeature
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the feature. Mandatory if the [feature type](#tocSproductfeaturetypedoc) is set to OTHER
   * @type {string}
   * @memberof BankingProductFeature
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this feature
   * @type {string}
   * @memberof BankingProductFeature
   */
  additionalInfoUri?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingProductFeatureFeatureTypeEnum {
  ADDITIONALCARDS = 'ADDITIONAL_CARDS',
  BALANCETRANSFERS = 'BALANCE_TRANSFERS',
  BILLPAYMENT = 'BILL_PAYMENT',
  BONUSREWARDS = 'BONUS_REWARDS',
  CARDACCESS = 'CARD_ACCESS',
  COMPLEMENTARYPRODUCTDISCOUNTS = 'COMPLEMENTARY_PRODUCT_DISCOUNTS',
  DIGITALBANKING = 'DIGITAL_BANKING',
  DIGITALWALLET = 'DIGITAL_WALLET',
  DONATEINTEREST = 'DONATE_INTEREST',
  FREETXNS = 'FREE_TXNS',
  FREETXNSALLOWANCE = 'FREE_TXNS_ALLOWANCE',
  INSURANCE = 'INSURANCE',
  INTERESTFREE = 'INTEREST_FREE',
  INTERESTFREETRANSFERS = 'INTEREST_FREE_TRANSFERS',
  LOYALTYPROGRAM = 'LOYALTY_PROGRAM',
  NOTIFICATIONS = 'NOTIFICATIONS',
  NPPENABLED = 'NPP_ENABLED',
  NPPPAYID = 'NPP_PAYID',
  OFFSET = 'OFFSET',
  OVERDRAFT = 'OVERDRAFT',
  REDRAW = 'REDRAW',
  UNLIMITEDTXNS = 'UNLIMITED_TXNS',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface BankingProductFee
 */
export interface BankingProductFee {
  /**
   * Name of the fee
   * @type {string}
   * @memberof BankingProductFee
   */
  name: string;
  /**
   * The type of fee
   * @type {string}
   * @memberof BankingProductFee
   */
  feeType: BankingProductFeeFeeTypeEnum;
  /**
   * The amount charged for the fee. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied
   * @type {string}
   * @memberof BankingProductFee
   */
  amount?: string;
  /**
   * A fee rate calculated based on a proportion of the balance. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied.
   * @type {string}
   * @memberof BankingProductFee
   */
  balanceRate?: string;
  /**
   * A fee rate calculated based on a proportion of a transaction. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied
   * @type {string}
   * @memberof BankingProductFee
   */
  transactionRate?: string;
  /**
   * A fee rate calculated based on a proportion of the calculated interest accrued on the account. One of amount, balanceRate, transactionRate and accruedRate is mandatory unless the *feeType* \"VARIABLE\" is supplied
   * @type {string}
   * @memberof BankingProductFee
   */
  accruedRate?: string;
  /**
   * The indicative frequency with which the fee is calculated on the account. Only applies if balanceRate or accruedRate is also present. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductFee
   */
  accrualFrequency?: string;
  /**
   * The currency the fee will be charged in. Assumes AUD if absent
   * @type {string}
   * @memberof BankingProductFee
   */
  currency?: string;
  /**
   * Generic field containing additional information relevant to the [feeType](#tocSproductfeetypedoc) specified. Whether mandatory or not is dependent on the value of [feeType](#tocSproductfeetypedoc)
   * @type {string}
   * @memberof BankingProductFee
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the fee
   * @type {string}
   * @memberof BankingProductFee
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this fee
   * @type {string}
   * @memberof BankingProductFee
   */
  additionalInfoUri?: string;
  /**
   * An optional list of discounts to this fee that may be available
   * @type {Array<BankingProductDiscount>}
   * @memberof BankingProductFee
   */
  discounts?: Array<BankingProductDiscount>;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingProductFeeFeeTypeEnum {
  DEPOSIT = 'DEPOSIT',
  EVENT = 'EVENT',
  EXIT = 'EXIT',
  PAYMENT = 'PAYMENT',
  PERIODIC = 'PERIODIC',
  PURCHASE = 'PURCHASE',
  TRANSACTION = 'TRANSACTION',
  UPFRONT = 'UPFRONT',
  VARIABLE = 'VARIABLE',
  WITHDRAWAL = 'WITHDRAWAL',
}

/**
 *
 * @export
 * @interface BankingProductLendingRateV2
 */
export interface BankingProductLendingRateV2 {
  /**
   * The type of rate (fixed, variable, etc). See the next section for an overview of valid values and their meaning
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  lendingRateType: BankingProductLendingRateV2LendingRateTypeEnum;
  /**
   * The rate to be applied
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  rate: string;
  /**
   * A comparison rate equivalent for this rate
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  comparisonRate?: string;
  /**
   * The period after which the rate is applied to the balance to calculate the amount due for the period. Calculation of the amount is often daily (as balances may change) but accumulated until the total amount is \'applied\' to the account (see applicationFrequency). Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  calculationFrequency?: string;
  /**
   * The period after which the calculated amount(s) (see calculationFrequency) are \'applied\' (i.e. debited or credited) to the account. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  applicationFrequency?: string;
  /**
   * When loan payments are due to be paid within each period. The investment benefit of earlier payments affect the rate that can be offered
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  interestPaymentDue?: BankingProductLendingRateV2InterestPaymentDueEnum;
  /**
   * Options in place for repayments. If absent, the lending rate is applicable to all repayment types
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  repaymentType?: BankingProductLendingRateV2RepaymentTypeEnum;
  /**
   * The reason for taking out the loan. If absent, the lending rate is applicable to all loan purposes
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  loanPurpose?: BankingProductLendingRateV2LoanPurposeEnum;
  /**
   * Rate tiers applicable for this rate
   * @type {Array<BankingProductRateTierV3>}
   * @memberof BankingProductLendingRateV2
   */
  tiers?: Array<BankingProductRateTierV3>;
  /**
   * Generic field containing additional information relevant to the [lendingRateType](#tocSproductlendingratetypedoc) specified. Whether mandatory or not is dependent on the value of [lendingRateType](#tocSproductlendingratetypedoc)
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  additionalValue?: string;
  /**
   * Display text providing more information on the rate.
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this rate
   * @type {string}
   * @memberof BankingProductLendingRateV2
   */
  additionalInfoUri?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingProductLendingRateV2LendingRateTypeEnum {
  BUNDLEDISCOUNTFIXED = 'BUNDLE_DISCOUNT_FIXED',
  BUNDLEDISCOUNTVARIABLE = 'BUNDLE_DISCOUNT_VARIABLE',
  CASHADVANCE = 'CASH_ADVANCE',
  DISCOUNT = 'DISCOUNT',
  FLOATING = 'FLOATING',
  INTRODUCTORY = 'INTRODUCTORY',
  MARKETLINKED = 'MARKET_LINKED',
  PENALTY = 'PENALTY',
  PURCHASE = 'PURCHASE',
  VARIABLE = 'VARIABLE',
  FIXED = 'FIXED',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingProductLendingRateV2InterestPaymentDueEnum {
  ADVANCE = 'IN_ADVANCE',
  ARREARS = 'IN_ARREARS',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingProductLendingRateV2RepaymentTypeEnum {
  INTERESTONLY = 'INTEREST_ONLY',
  PRINCIPALANDINTEREST = 'PRINCIPAL_AND_INTEREST',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingProductLendingRateV2LoanPurposeEnum {
  OWNEROCCUPIED = 'OWNER_OCCUPIED',
  INVESTMENT = 'INVESTMENT',
}

/**
 * Defines a condition for the applicability of a tiered rate
 * @export
 * @interface BankingProductRateCondition
 */
export interface BankingProductRateCondition {
  /**
   * Display text providing more information on the condition
   * @type {string}
   * @memberof BankingProductRateCondition
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this condition
   * @type {string}
   * @memberof BankingProductRateCondition
   */
  additionalInfoUri?: string;
}
/**
 * Defines the criteria and conditions for which a rate applies
 * @export
 * @interface BankingProductRateTierV3
 */
export interface BankingProductRateTierV3 {
  /**
   * A display name for the tier
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  name: string;
  /**
   * The unit of measure that applies to the tierValueMinimum and tierValueMaximum values e.g. a **DOLLAR** amount. **PERCENT** (in the case of loan-to-value ratio or LVR). Tier term period representing a discrete number of **MONTH**\'s or **DAY**\'s (in the case of term deposit tiers)
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  unitOfMeasure: BankingProductRateTierV3UnitOfMeasureEnum;
  /**
   * The number of tierUnitOfMeasure units that form the lower bound of the tier. The tier should be inclusive of this value
   * @type {number}
   * @memberof BankingProductRateTierV3
   */
  minimumValue: number;
  /**
   * The number of tierUnitOfMeasure units that form the upper bound of the tier or band. For a tier with a discrete value (as opposed to a range of values e.g. 1 month) this must be the same as tierValueMinimum. Where this is the same as the tierValueMinimum value of the next-higher tier the referenced tier should be exclusive of this value. For example a term deposit of 2 months falls into the upper tier of the following tiers: (1 - 2 months, 2 - 3 months). If absent the tier\'s range has no upper bound.
   * @type {number}
   * @memberof BankingProductRateTierV3
   */
  maximumValue?: number;
  /**
   * The method used to calculate the amount to be applied using one or more tiers. A single rate may be applied to the entire balance or each applicable tier rate is applied to the portion of the balance that falls into that tier (referred to as \'bands\' or \'steps\')
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  rateApplicationMethod?: BankingProductRateTierV3RateApplicationMethodEnum;
  /**
   *
   * @type {BankingProductRateCondition}
   * @memberof BankingProductRateTierV3
   */
  applicabilityConditions?: BankingProductRateCondition;
  /**
   * Display text providing more information on the rate tier.
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  additionalInfo?: string;
  /**
   * Link to a web page with more information on this rate tier
   * @type {string}
   * @memberof BankingProductRateTierV3
   */
  additionalInfoUri?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingProductRateTierV3UnitOfMeasureEnum {
  DOLLAR = 'DOLLAR',
  PERCENT = 'PERCENT',
  DAY = 'DAY',
  MONTH = 'MONTH',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingProductRateTierV3RateApplicationMethodEnum {
  PERTIER = 'PER_TIER',
  WHOLEBALANCE = 'WHOLE_BALANCE',
}

/**
 *
 * @export
 * @interface BankingTermDepositAccount
 */
export interface BankingTermDepositAccount {
  /**
   * The lodgement date of the original deposit
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  lodgementDate: string;
  /**
   * Maturity date for the term deposit
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityDate: string;
  /**
   * Amount to be paid upon maturity. If absent it implies the amount to paid is variable and cannot currently be calculated
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityAmount?: string;
  /**
   * If absent assumes AUD
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityCurrency?: string;
  /**
   * Current instructions on action to be taken at maturity. This includes default actions that may be specified in the terms and conditions for the product e.g. roll-over to the same term and frequency of interest payments
   * @type {string}
   * @memberof BankingTermDepositAccount
   */
  maturityInstructions: BankingTermDepositAccountMaturityInstructionsEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingTermDepositAccountMaturityInstructionsEnum {
  ROLLEDOVER = 'ROLLED_OVER',
  PAIDOUTATMATURITY = 'PAID_OUT_AT_MATURITY',
  HOLDONMATURITY = 'HOLD_ON_MATURITY',
}

/**
 *
 * @export
 * @interface BankingTransaction
 */
export interface BankingTransaction {
  /**
   * ID of the account for which transactions are provided
   * @type {string}
   * @memberof BankingTransaction
   */
  accountId: string;
  /**
   * A unique ID of the transaction adhering to the standards for ID permanence.  This is mandatory (through hashing if necessary) unless there are specific and justifiable technical reasons why a transaction cannot be uniquely identified for a particular account type
   * @type {string}
   * @memberof BankingTransaction
   */
  transactionId?: string;
  /**
   * True if extended information is available using the transaction detail end point. False if extended data is not available
   * @type {boolean}
   * @memberof BankingTransaction
   */
  isDetailAvailable: boolean;
  /**
   * The type of the transaction
   * @type {string}
   * @memberof BankingTransaction
   */
  type: BankingTransactionTypeEnum;
  /**
   * Status of the transaction whether pending or posted. Note that there is currently no provision in the standards to guarantee the ability to correlate a pending transaction with an associated posted transaction
   * @type {string}
   * @memberof BankingTransaction
   */
  status: BankingTransactionStatusEnum;
  /**
   * The transaction description as applied by the financial institution
   * @type {string}
   * @memberof BankingTransaction
   */
  description: string;
  /**
   * The time the transaction was posted. This field is Mandatory if the transaction has status POSTED.  This is the time that appears on a standard statement. DateTimeString can be found at https://consumerdatastandardsaustralia.github.io/standards/#common-field-types
   * @type {string}
   * @memberof BankingTransaction
   */
  postingDateTime?: string;
  /**
   * Date and time at which assets become available to the account owner in case of a credit entry, or cease to be available to the account owner in case of a debit transaction entry
   * @type {string}
   * @memberof BankingTransaction
   */
  valueDateTime?: string;
  /**
   * The time the transaction was executed by the originating customer, if available
   * @type {string}
   * @memberof BankingTransaction
   */
  executionDateTime?: string;
  /**
   * The value of the transaction. Negative values mean money was outgoing from the account
   * @type {string}
   * @memberof BankingTransaction
   */
  amount: string;
  /**
   * The currency for the transaction amount. AUD assumed if not present
   * @type {string}
   * @memberof BankingTransaction
   */
  currency?: string;
  /**
   * The reference for the transaction provided by the originating institution. Empty string if no data provided
   * @type {string}
   * @memberof BankingTransaction
   */
  reference: string;
  /**
   * Name of the merchant for an outgoing payment to a merchant
   * @type {string}
   * @memberof BankingTransaction
   */
  merchantName?: string;
  /**
   * The merchant category code (or MCC) for an outgoing payment to a merchant
   * @type {string}
   * @memberof BankingTransaction
   */
  merchantCategoryCode?: string;
  /**
   * BPAY Biller Code for the transaction (if available)
   * @type {string}
   * @memberof BankingTransaction
   */
  billerCode?: string;
  /**
   * Name of the BPAY biller for the transaction (if available)
   * @type {string}
   * @memberof BankingTransaction
   */
  billerName?: string;
  /**
   * BPAY CRN for the transaction (if available)
   * @type {string}
   * @memberof BankingTransaction
   */
  crn?: string;
  /**
   * 6 Digit APCA number for the initiating institution. The field is fixed-width and padded with leading zeros if applicable.
   * @type {string}
   * @memberof BankingTransaction
   */
  apcaNumber?: string;
  /**
   *
   * @type {BankingTransactionExtendedData}
   * @memberof BankingTransaction
   */
  extendedData?: BankingTransactionExtendedData;
  /**
   *
   * @type {BankingTransactionAdatree}
   * @memberof BankingTransaction
   */
  adatree?: BankingTransactionAdatree;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingTransactionTypeEnum {
  DIRECTDEBIT = 'DIRECT_DEBIT',
  FEE = 'FEE',
  INTERESTCHARGED = 'INTEREST_CHARGED',
  INTERESTPAID = 'INTEREST_PAID',
  PAYMENT = 'PAYMENT',
  TRANSFEROUTGOING = 'TRANSFER_OUTGOING',
  TRANSFERINCOMING = 'TRANSFER_INCOMING',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingTransactionStatusEnum {
  PENDING = 'PENDING',
  POSTED = 'POSTED',
}

/**
 * Extra data and metadata provided by Adatree for transactions
 * @export
 * @interface BankingTransactionAdatree
 */
export interface BankingTransactionAdatree {
  /**
   * Consent Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  consentId: string;
  /**
   * Consumer Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  consumerId: string;
  /**
   * CDR Arrangement for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  cdrArrangementId: string;
  /**
   * Data Holder Brand Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  dataHolderBrandId: string;
  /**
   * Use Case Id for related resource
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  useCaseId: string;
  /**
   * resource ID generated by Adatree; the ADHs do not always provide a transaction Id so we generate an id to uniquely identify a transaction
   * @type {string}
   * @memberof BankingTransactionAdatree
   */
  resourceId: string;
  /**
   *
   * @type {BankingTransactionAdatreeCategorisation}
   * @memberof BankingTransactionAdatree
   */
  categorisation?: BankingTransactionAdatreeCategorisation;
}
/**
 *
 * @export
 * @interface BankingTransactionAdatreeAllOf
 */
export interface BankingTransactionAdatreeAllOf {
  /**
   * resource ID generated by Adatree; the ADHs do not always provide a transaction Id so we generate an id to uniquely identify a transaction
   * @type {string}
   * @memberof BankingTransactionAdatreeAllOf
   */
  resourceId?: string;
  /**
   *
   * @type {BankingTransactionAdatreeCategorisation}
   * @memberof BankingTransactionAdatreeAllOf
   */
  categorisation?: BankingTransactionAdatreeCategorisation;
}
/**
 *
 * @export
 * @interface BankingTransactionAdatreeCategorisation
 */
export interface BankingTransactionAdatreeCategorisation {
  /**
   *
   * @type {BankingTransactionAdatreePersonetics}
   * @memberof BankingTransactionAdatreeCategorisation
   */
  personetics?: BankingTransactionAdatreePersonetics;
}
/**
 * Personetics is Adatree\'s transaction categorisation partner
 * @export
 * @interface BankingTransactionAdatreePersonetics
 */
export interface BankingTransactionAdatreePersonetics {
  /**
   *
   * @type {string}
   * @memberof BankingTransactionAdatreePersonetics
   */
  categoryName: BankingTransactionAdatreePersoneticsCategoryNameEnum;
  /**
   *
   * @type {string}
   * @memberof BankingTransactionAdatreePersonetics
   */
  subCategoryName?: BankingTransactionAdatreePersoneticsSubCategoryNameEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingTransactionAdatreePersoneticsCategoryNameEnum {
  CashDeposit = 'Cash Deposit',
  CashWithdrawal = 'Cash Withdrawal',
  CheckDeposit = 'Check Deposit',
  ChecksPosted = 'Checks Posted',
  CreditCardPayments = 'Credit Card Payments',
  DigitalWallet = 'Digital Wallet',
  Dining = 'Dining',
  DirectDebitStandingOrder = 'Direct Debit & Standing Order',
  DirectDeposit = 'Direct Deposit',
  Donations = 'Donations',
  Education = 'Education',
  Entertainment = 'Entertainment',
  FeesOtherCharges = 'Fees & Other charges',
  Groceries = 'Groceries',
  HealthFitness = 'Health & Fitness',
  Household = 'Household',
  Insurance = 'Insurance',
  InterestDividends = 'Interest & Dividends',
  KidsFamily = 'Kids & Family',
  LoanMortgage = 'Loan & Mortgage',
  OfficeExpenses = 'Office expenses',
  PaycheckPensionsAnnuity = 'Paycheck, Pensions & Annuity',
  PersonalCare = 'Personal Care',
  SavingsInvestments = 'Savings & Investments',
  Shopping = 'Shopping',
  TaxesAuthorities = 'Taxes & Authorities',
  TransfersBetweenOwnAccounts = 'Transfers Between Own Accounts',
  Transportation = 'Transportation',
  Travel = 'Travel',
  Utilities = 'Utilities',
  OtherDeposits = 'Other Deposits',
  OtherTransfers = 'Other transfers',
  Other = 'Other',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingTransactionAdatreePersoneticsSubCategoryNameEnum {
  ActivitiesAttractions = 'Activities & Attractions',
  Airlines = 'Airlines',
  Annuities = 'Annuities',
  ApparelClothingShoesAccessories = 'Apparel - Clothing, Shoes & Accessories',
  ArtGalleriesAntiques = 'Art Galleries & Antiques',
  ATMFees = 'ATM Fees',
  Attractions = 'Attractions',
  Bakeries = 'Bakeries',
  BarsPubs = 'Bars & Pubs',
  BeautyProducts = 'Beauty Products',
  BooksNewspapers = 'Books & Newspapers',
  CarFinance = 'Car Finance',
  CarInsurance = 'Car Insurance',
  CarRentals = 'Car Rentals',
  CashDeposit = 'Cash Deposit',
  CashWithdrawal = 'Cash Withdrawal',
  CheckDeposit = 'Check Deposit',
  ChecksPosted = 'Checks Posted',
  ChildCare = 'Child Care',
  ChildrensClothingsStores = "Children's Clothings Stores",
  Cleaning = 'Cleaning',
  Construction = 'Construction',
  ConversionFees = 'Conversion Fees',
  CreditCardPayments = 'Credit Card Payments',
  CurrencyExchange = 'Currency Exchange',
  Deli = 'Deli',
  DepartmentDiscountStores = 'Department & Discount Stores',
  DigitalEntertainment = 'Digital Entertainment',
  DigitalWallet = 'Digital Wallet',
  Dining = 'Dining',
  DirectDebitStandingOrder = 'Direct Debit & Standing Order',
  DirectDeposit = 'Direct Deposit',
  Dividends = 'Dividends',
  Donations = 'Donations',
  DrugsPharmacy = 'Drugs & Pharmacy',
  Education = 'Education',
  ElectricityWaterGas = 'Electricity, Water, Gas',
  ElectronicsComputers = 'Electronics & Computers',
  Electronics = 'Electronics',
  ElementarySecondarySchool = 'Elementary & Secondary School',
  Entertainment = 'Entertainment',
  EquipmentFinance = 'Equipment Finance',
  FastFood = 'Fast Food',
  FitnessLeisure = 'Fitness & Leisure',
  Furniture = 'Furniture',
  Games = 'Games',
  Gardening = 'Gardening',
  GasStation = 'Gas Station',
  GeneralOfficeExpenses = 'General Office Expenses',
  GovernmentServices = 'Government Services',
  HairNailsBeautyShops = 'Hair, Nails & Beauty Shops',
  HardwareAppliances = 'Hardware & Appliances',
  HealthFitness = 'Health & fitness',
  HealthcareFinance = 'Healthcare Finance',
  HeatingPlumbingElectricity = 'Heating, Plumbing, Electricity',
  HigherEducation = 'Higher Education',
  HobbiesGifts = 'Hobbies & Gifts',
  HotelsResortsLodgings = 'Hotels, Resorts & Lodgings',
  HouseholdServices = 'Household Services',
  Household = 'Household',
  Insurance = 'Insurance',
  InterestDeposit = 'Interest deposit',
  InvestmentDeposit = 'Investment deposit',
  Investments = 'Investments',
  Jewelry = 'Jewelry',
  KidsFamily = 'Kids & Family',
  LaundryDryCleaning = 'Laundry & Dry Cleaning',
  LifeInsurance = 'Life Insurance',
  LineOfCredit = 'Line of Credit',
  LiquorStores = 'Liquor Stores',
  Loans = 'Loans',
  MedicalHealthcare = 'Medical & Healthcare',
  MedicalInsurance = 'Medical Insurance',
  Mortgage = 'Mortgage',
  MoviesMusicShows = 'Movies, Music & Shows',
  OfficeExpenses = 'Office expenses',
  OfficeSupplies = 'Office Supplies',
  OtherDeposits = 'Other Deposits',
  OtherFeesAndCharges = 'Other Fees and Charges',
  OtherInsurance = 'Other Insurance',
  OtherLoans = 'Other Loans',
  OtherSavingsInvestments = 'Other Savings & Investments',
  OtherTransfers = 'Other Transfers',
  Other = 'Other',
  OverdraftFees = 'Overdraft Fees',
  P2P = 'P2P',
  ParkingTolls = 'Parking & Tolls',
  Paycheck = 'Paycheck',
  PaydayPawnTitleLoans = 'Payday & Pawn & Title Loans',
  Pension = 'Pension',
  PersonalCare = 'Personal Care',
  PersonalLoan = 'Personal Loan',
  PetCareSupplies = 'Pet Care & Supplies',
  PetInsurance = 'Pet Insurance',
  PhoneInternet = 'Phone & Internet',
  PhotographyPublishingPrinting = 'Photography, Publishing & Printing',
  ProfessionalServices = 'Professional Services',
  PropertyCasualtyInsurance = 'Property & Casualty Insurance',
  PublicTransportation = 'Public Transportation',
  RealEstate = 'Real Estate',
  Restaurants = 'Restaurants',
  Savings = 'Savings',
  ServiceFees = 'Service Fees',
  ShippingDeliveries = 'Shipping & Deliveries',
  Shopping = 'Shopping',
  SportEntertainment = 'Sport Entertainment',
  StudentLoan = 'Student Loan',
  SupermarketGroceryConvenienceStores = 'Supermarket, Grocery & Convenience Stores',
  TaxesAuthorities = 'Taxes & Authorities',
  TaxesFinesBailBonds = 'Taxes, Fines & Bail Bonds',
  Taxi = 'Taxi',
  TransfersBetweenOwnAccounts = 'Transfers between own accounts',
  Transportation = 'Transportation',
  Travel = 'Travel',
  Utilities = 'Utilities',
  VehicleDealers = 'Vehicle Dealers',
  VehicleOperatingExpenses = 'Vehicle Operating Expenses',
  VocationalSchools = 'Vocational Schools',
}

/**
 *
 * @export
 * @interface BankingTransactionExtendedData
 */
export interface BankingTransactionExtendedData {
  /**
   * Label of the originating payer. Mandatory for inbound payment
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  payer?: string;
  /**
   * Label of the target PayID.  Mandatory for an outbound payment. The name assigned to the BSB/Account Number or PayID (by the owner of the PayID)
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  payee?: string;
  /**
   * Optional extended data provided specific to transaction originated via NPP
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  extensionUType?: BankingTransactionExtendedDataExtensionUTypeEnum;
  /**
   *
   * @type {BankingTransactionExtendedDataX2p101Payload}
   * @memberof BankingTransactionExtendedData
   */
  x2p101Payload?: BankingTransactionExtendedDataX2p101Payload;
  /**
   * Identifier of the applicable overlay service. Valid values are: X2P1.01
   * @type {string}
   * @memberof BankingTransactionExtendedData
   */
  service: BankingTransactionExtendedDataServiceEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum BankingTransactionExtendedDataExtensionUTypeEnum {
  X2p101Payload = 'x2p101Payload',
}
/**
 * @export
 * @enum {string}
 */
export enum BankingTransactionExtendedDataServiceEnum {
  X2P101 = 'X2P1.01',
}

/**
 *
 * @export
 * @interface BankingTransactionExtendedDataX2p101Payload
 */
export interface BankingTransactionExtendedDataX2p101Payload {
  /**
   * An extended string description. Only present if specified by the extensionUType field
   * @type {string}
   * @memberof BankingTransactionExtendedDataX2p101Payload
   */
  extendedDescription: string;
  /**
   * An end to end ID for the payment created at initiation
   * @type {string}
   * @memberof BankingTransactionExtendedDataX2p101Payload
   */
  endToEndId?: string;
  /**
   * Purpose of the payment.  Format is defined by NPP standards for the x2p1.01 overlay service
   * @type {string}
   * @memberof BankingTransactionExtendedDataX2p101Payload
   */
  purposeCode?: string;
}
/**
 *
 * @export
 * @interface BankingTransactionList
 */
export interface BankingTransactionList {
  /**
   *
   * @type {BankingTransactionListData}
   * @memberof BankingTransactionList
   */
  data: BankingTransactionListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof BankingTransactionList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof BankingTransactionList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface BankingTransactionListData
 */
export interface BankingTransactionListData {
  /**
   *
   * @type {Array<BankingTransaction>}
   * @memberof BankingTransactionListData
   */
  transactions: Array<BankingTransaction>;
}
/**
 * Australian address formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
 * @export
 * @interface CommonPAFAddress
 */
export interface CommonPAFAddress {
  /**
   * Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
   * @type {string}
   * @memberof CommonPAFAddress
   */
  dpid?: string;
  /**
   * Thoroughfare number for a property (first number in a property ranged address)
   * @type {number}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber1?: number;
  /**
   * Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
   * @type {string}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber1Suffix?: string;
  /**
   * Second thoroughfare number (only used if the property has a ranged address eg 23-25)
   * @type {number}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber2?: number;
  /**
   * Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
   * @type {string}
   * @memberof CommonPAFAddress
   */
  thoroughfareNumber2Suffix?: string;
  /**
   * Type of flat or unit for the address
   * @type {string}
   * @memberof CommonPAFAddress
   */
  flatUnitType?: string;
  /**
   * Unit number (including suffix, if applicable)
   * @type {string}
   * @memberof CommonPAFAddress
   */
  flatUnitNumber?: string;
  /**
   * Type of floor or level for the address
   * @type {string}
   * @memberof CommonPAFAddress
   */
  floorLevelType?: string;
  /**
   * Floor or level number (including alpha characters)
   * @type {string}
   * @memberof CommonPAFAddress
   */
  floorLevelNumber?: string;
  /**
   * Allotment number for the address
   * @type {string}
   * @memberof CommonPAFAddress
   */
  lotNumber?: string;
  /**
   * Building/Property name 1
   * @type {string}
   * @memberof CommonPAFAddress
   */
  buildingName1?: string;
  /**
   * Building/Property name 2
   * @type {string}
   * @memberof CommonPAFAddress
   */
  buildingName2?: string;
  /**
   * The name of the street
   * @type {string}
   * @memberof CommonPAFAddress
   */
  streetName?: string;
  /**
   * The street type. Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof CommonPAFAddress
   */
  streetType?: string;
  /**
   * The street type suffix. Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof CommonPAFAddress
   */
  streetSuffix?: string;
  /**
   * Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postalDeliveryType?: string;
  /**
   * Postal delivery number if the address is a postal delivery type
   * @type {number}
   * @memberof CommonPAFAddress
   */
  postalDeliveryNumber?: number;
  /**
   * Postal delivery number prefix related to the postal delivery number
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postalDeliveryNumberPrefix?: string;
  /**
   * Postal delivery number suffix related to the postal delivery number
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postalDeliveryNumberSuffix?: string;
  /**
   * Full name of locality
   * @type {string}
   * @memberof CommonPAFAddress
   */
  localityName: string;
  /**
   * Postcode for the locality
   * @type {string}
   * @memberof CommonPAFAddress
   */
  postcode: string;
  /**
   * State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
   * @type {string}
   * @memberof CommonPAFAddress
   */
  state: string;
}
/**
 *
 * @export
 * @interface CommonPhysicalAddress
 */
export interface CommonPhysicalAddress {
  /**
   * The type of address object present
   * @type {string}
   * @memberof CommonPhysicalAddress
   */
  addressUType: CommonPhysicalAddressAddressUTypeEnum;
  /**
   *
   * @type {CommonSimpleAddress}
   * @memberof CommonPhysicalAddress
   */
  simple?: CommonSimpleAddress;
  /**
   *
   * @type {CommonPAFAddress}
   * @memberof CommonPhysicalAddress
   */
  paf?: CommonPAFAddress;
}

/**
 * @export
 * @enum {string}
 */
export enum CommonPhysicalAddressAddressUTypeEnum {
  Simple = 'simple',
  Paf = 'paf',
}

/**
 *
 * @export
 * @interface CommonSimpleAddress
 */
export interface CommonSimpleAddress {
  /**
   * Name of the individual or business formatted for inclusion in an address used for physical mail
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  mailingName?: string;
  /**
   * First line of the standard address object
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  addressLine1: string;
  /**
   * Second line of the standard address object
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  addressLine2?: string;
  /**
   * Third line of the standard address object
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  addressLine3?: string;
  /**
   * Mandatory for Australian addresses
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  postcode?: string;
  /**
   * Name of the city or locality
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  city: string;
  /**
   * Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  state: string;
  /**
   * A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
   * @type {string}
   * @memberof CommonSimpleAddress
   */
  country?: string;
}
/**
 *
 * @export
 * @interface EnergyAccountDetail
 */
export interface EnergyAccountDetail {
  /**
   * The ID of the account.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyAccountDetail
   */
  accountId: string;
  /**
   * Optional identifier of the account as defined by the data holder.  This must be the value presented on physical statements (if it exists) and must not be used for the value of accountId
   * @type {string}
   * @memberof EnergyAccountDetail
   */
  accountNumber?: string;
  /**
   * An optional display name for the account if one exists or can be derived.  The content of this field is at the discretion of the data holder
   * @type {string}
   * @memberof EnergyAccountDetail
   */
  displayName?: string;
  /**
   * The date that the account was created or opened
   * @type {string}
   * @memberof EnergyAccountDetail
   */
  creationDate: string;
  /**
   * The current balance of the account.  A positive value indicates that amount is owing to be paid.  A negative value indicates that the account is in credit
   * @type {string}
   * @memberof EnergyAccountDetail
   */
  balance?: string;
  /**
   * The array of plans containing service points and associated plan details
   * @type {Array<EnergyAccountDetailPlan>}
   * @memberof EnergyAccountDetail
   */
  plans: Array<EnergyAccountDetailPlan>;
  /**
   *
   * @type {EnergyPaymentSchedule}
   * @memberof EnergyAccountDetail
   */
  paymentSchedule?: EnergyPaymentSchedule;
  /**
   * Array may be empty if no concessions exist
   * @type {Array<EnergyConcession>}
   * @memberof EnergyAccountDetail
   */
  concessions?: Array<EnergyConcession>;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyAccountDetail
   */
  adatree: Adatree;
}
/**
 *
 * @export
 * @interface EnergyAccountDetailAuthorisedContacts
 */
export interface EnergyAccountDetailAuthorisedContacts {
  /**
   * For people with single names this field need not be present. The single name should be in the lastName field
   * @type {string}
   * @memberof EnergyAccountDetailAuthorisedContacts
   */
  firstName?: string;
  /**
   * For people with single names the single name should be in this field
   * @type {string}
   * @memberof EnergyAccountDetailAuthorisedContacts
   */
  lastName: string;
  /**
   * Field is mandatory but array may be empty
   * @type {Array<string>}
   * @memberof EnergyAccountDetailAuthorisedContacts
   */
  middleNames?: Array<string>;
  /**
   * Also known as title or salutation. The prefix to the name (e.g. Mr, Mrs, Ms, Miss, Sir, etc)
   * @type {string}
   * @memberof EnergyAccountDetailAuthorisedContacts
   */
  prefix?: string;
  /**
   * Used for a trailing suffix to the name (e.g. Jr)
   * @type {string}
   * @memberof EnergyAccountDetailAuthorisedContacts
   */
  suffix?: string;
}
/**
 *
 * @export
 * @interface EnergyAccountDetailPlan
 */
export interface EnergyAccountDetailPlan {
  /**
   * Optional display name for the plan provided by the customer to help differentiate multiple plans
   * @type {string}
   * @memberof EnergyAccountDetailPlan
   */
  nickname?: string;
  /**
   * An array of servicePointIds, representing NMIs, that this account is linked to
   * @type {Array<string>}
   * @memberof EnergyAccountDetailPlan
   */
  servicePointIds: Array<string>;
  /**
   *
   * @type {EnergyAccountPlanOverview}
   * @memberof EnergyAccountDetailPlan
   */
  planOverview: EnergyAccountPlanOverview;
  /**
   *
   * @type {EnergyAccountDetailPlanDetail}
   * @memberof EnergyAccountDetailPlan
   */
  planDetail: EnergyAccountDetailPlanDetail;
  /**
   * An array of additional contacts that are authorised to act on this account
   * @type {Array<EnergyAccountDetailAuthorisedContacts>}
   * @memberof EnergyAccountDetailPlan
   */
  authorisedContacts?: Array<EnergyAccountDetailAuthorisedContacts>;
}
/**
 * Detail on the plan applicable to this account
 * @export
 * @interface EnergyAccountDetailPlanDetail
 */
export interface EnergyAccountDetailPlanDetail {
  /**
   * The fuel types covered by the plan
   * @type {string}
   * @memberof EnergyAccountDetailPlanDetail
   */
  fuelType: EnergyAccountDetailPlanDetailFuelTypeEnum;
  /**
   * Flag that indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up). Has no meaning if the plan has a fuelType of DUAL. If absent the value is assumed to be false
   * @type {boolean}
   * @memberof EnergyAccountDetailPlanDetail
   */
  isContingentPlan?: boolean;
  /**
   * Charges for metering included in the plan
   * @type {Array<EnergyPlanDetailAllOfMeteringCharges>}
   * @memberof EnergyAccountDetailPlanDetail
   */
  meteringCharges?: Array<EnergyPlanDetailAllOfMeteringCharges>;
  /**
   *
   * @type {EnergyPlanContract}
   * @memberof EnergyAccountDetailPlanDetail
   */
  gasContract?: EnergyPlanContract;
  /**
   *
   * @type {EnergyPlanContract}
   * @memberof EnergyAccountDetailPlanDetail
   */
  electricityContract?: EnergyPlanContract;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyAccountDetailPlanDetailFuelTypeEnum {
  ELECTRICITY = 'ELECTRICITY',
  GAS = 'GAS',
  DUAL = 'DUAL',
}

/**
 *
 * @export
 * @interface EnergyAccountList
 */
export interface EnergyAccountList {
  /**
   *
   * @type {EnergyAccountListData}
   * @memberof EnergyAccountList
   */
  data: EnergyAccountListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyAccountList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyAccountList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyAccountListData
 */
export interface EnergyAccountListData {
  /**
   * The list of energy accounts returned. If the filter results in an empty set then this array may have no records
   * @type {Array<EnergyAccountDetail>}
   * @memberof EnergyAccountListData
   */
  accounts: Array<EnergyAccountDetail>;
}
/**
 *
 * @export
 * @interface EnergyAccountPlanOverview
 */
export interface EnergyAccountPlanOverview {
  /**
   * The name of the plan if one exists
   * @type {string}
   * @memberof EnergyAccountPlanOverview
   */
  displayName?: string;
  /**
   * The start date of the applicability of this plan
   * @type {string}
   * @memberof EnergyAccountPlanOverview
   */
  startDate: string;
  /**
   * The end date of the applicability of this plan
   * @type {string}
   * @memberof EnergyAccountPlanOverview
   */
  endDate?: string;
}
/**
 *
 * @export
 * @interface EnergyBillingDemandTransaction
 */
export interface EnergyBillingDemandTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  invoiceNumber?: string;
  /**
   * The time of use type that the transaction applies to
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  timeOfUseType: EnergyBillingDemandTransactionTimeOfUseTypeEnum;
  /**
   * Optional description of the transaction that can be used for display purposes
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  description?: string;
  /**
   * Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
   * @type {boolean}
   * @memberof EnergyBillingDemandTransaction
   */
  isEstimate?: boolean;
  /**
   * Date and time when the demand period starts
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  startDate: string;
  /**
   * Date and time when the demand period ends
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  endDate: string;
  /**
   * The rate for the demand charge in kVA.  A negative value indicates power generated
   * @type {number}
   * @memberof EnergyBillingDemandTransaction
   */
  rate: number;
  /**
   * The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
   * @type {string}
   * @memberof EnergyBillingDemandTransaction
   */
  amount: string;
  /**
   * Additional calculation factors that inform the transaction
   * @type {Array<EnergyBillingUsageTransactionCalculationFactors>}
   * @memberof EnergyBillingDemandTransaction
   */
  calculationFactors?: Array<EnergyBillingUsageTransactionCalculationFactors>;
  /**
   * Optional array of adjustments arising for this transaction
   * @type {Array<EnergyBillingUsageTransactionAdjustments>}
   * @memberof EnergyBillingDemandTransaction
   */
  adjustments?: Array<EnergyBillingUsageTransactionAdjustments>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyBillingDemandTransactionTimeOfUseTypeEnum {
  PEAK = 'PEAK',
  OFFPEAK = 'OFF_PEAK',
  OFFPEAKDEMANDCHARGE = 'OFF_PEAK_DEMAND_CHARGE',
  SHOULDER = 'SHOULDER',
  SHOULDER1 = 'SHOULDER1',
  SHOULDER2 = 'SHOULDER2',
  CONTROLLEDLOAD = 'CONTROLLED_LOAD',
  SOLAR = 'SOLAR',
  AGGREGATE = 'AGGREGATE',
}

/**
 *
 * @export
 * @interface EnergyBillingList
 */
export interface EnergyBillingList {
  /**
   *
   * @type {EnergyBillingListData}
   * @memberof EnergyBillingList
   */
  data: EnergyBillingListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyBillingList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyBillingList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyBillingListData
 */
export interface EnergyBillingListData {
  /**
   * Array of transactions sorted by date and time in descending order
   * @type {Array<EnergyBillingTransaction>}
   * @memberof EnergyBillingListData
   */
  transactions: Array<EnergyBillingTransaction>;
}
/**
 *
 * @export
 * @interface EnergyBillingOnceOffTransaction
 */
export interface EnergyBillingOnceOffTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  invoiceNumber?: string;
  /**
   * The amount of the charge or credit.  A positive value indicates a charge and a negative value indicates a credit
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  amount: string;
  /**
   * A free text description of the item
   * @type {string}
   * @memberof EnergyBillingOnceOffTransaction
   */
  description: string;
}
/**
 *
 * @export
 * @interface EnergyBillingOtherTransaction
 */
export interface EnergyBillingOtherTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  invoiceNumber?: string;
  /**
   * Optional start date for the application of the charge
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  startDate?: string;
  /**
   * Optional end date for the application of the charge
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  endDate?: string;
  /**
   * Type of charge. Assumed to be other if absent
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  type?: EnergyBillingOtherTransactionTypeEnum;
  /**
   * The amount of the charge
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  amount: string;
  /**
   * A free text description of the item
   * @type {string}
   * @memberof EnergyBillingOtherTransaction
   */
  description: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyBillingOtherTransactionTypeEnum {
  ENVIRONMENTAL = 'ENVIRONMENTAL',
  REGULATED = 'REGULATED',
  NETWORK = 'NETWORK',
  METERING = 'METERING',
  RETAILSERVICE = 'RETAIL_SERVICE',
  RCTI = 'RCTI',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface EnergyBillingPaymentTransaction
 */
export interface EnergyBillingPaymentTransaction {
  /**
   * The amount paid
   * @type {string}
   * @memberof EnergyBillingPaymentTransaction
   */
  amount: string;
  /**
   * The method of payment
   * @type {string}
   * @memberof EnergyBillingPaymentTransaction
   */
  method: EnergyBillingPaymentTransactionMethodEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyBillingPaymentTransactionMethodEnum {
  DIRECTDEBIT = 'DIRECT_DEBIT',
  CARD = 'CARD',
  TRANSFER = 'TRANSFER',
  BPAY = 'BPAY',
  CASH = 'CASH',
  CHEQUE = 'CHEQUE',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface EnergyBillingTransaction
 */
export interface EnergyBillingTransaction {
  /**
   * The ID of the account for which transaction applies
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  accountId: string;
  /**
   * The date and time that the transaction occurred
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  executionDateTime: string;
  /**
   * The GST incurred in the transaction.  Should not be included for credits or payments.  If absent zero is assumed
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  gst?: string;
  /**
   * Indicator of the type of transaction object present in this record
   * @type {string}
   * @memberof EnergyBillingTransaction
   */
  transactionUType: EnergyBillingTransactionTransactionUTypeEnum;
  /**
   *
   * @type {EnergyBillingUsageTransaction}
   * @memberof EnergyBillingTransaction
   */
  usage?: EnergyBillingUsageTransaction;
  /**
   *
   * @type {EnergyBillingDemandTransaction}
   * @memberof EnergyBillingTransaction
   */
  demand?: EnergyBillingDemandTransaction;
  /**
   *
   * @type {EnergyBillingOnceOffTransaction}
   * @memberof EnergyBillingTransaction
   */
  onceOff?: EnergyBillingOnceOffTransaction;
  /**
   *
   * @type {EnergyBillingOtherTransaction}
   * @memberof EnergyBillingTransaction
   */
  otherCharges?: EnergyBillingOtherTransaction;
  /**
   *
   * @type {EnergyBillingPaymentTransaction}
   * @memberof EnergyBillingTransaction
   */
  payment?: EnergyBillingPaymentTransaction;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyBillingTransaction
   */
  adatree: Adatree;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyBillingTransactionTransactionUTypeEnum {
  Usage = 'usage',
  Demand = 'demand',
  OnceOff = 'onceOff',
  OtherCharges = 'otherCharges',
  Payment = 'payment',
}

/**
 *
 * @export
 * @interface EnergyBillingUsageTransaction
 */
export interface EnergyBillingUsageTransaction {
  /**
   * The ID of the service point to which this transaction applies if any
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  servicePointId?: string;
  /**
   * The number of the invoice in which this transaction is included if it has been issued
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  invoiceNumber?: string;
  /**
   * The time of use type that the transaction applies to
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  timeOfUseType: EnergyBillingUsageTransactionTimeOfUseTypeEnum;
  /**
   * Optional description of the transaction that can be used for display purposes
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  description?: string;
  /**
   * Flag indicating if the usage is estimated or actual.  True indicates estimate.  False or absent indicates actual
   * @type {boolean}
   * @memberof EnergyBillingUsageTransaction
   */
  isEstimate?: boolean;
  /**
   * Date and time when the usage period starts
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  startDate: string;
  /**
   * Date and time when the usage period ends
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  endDate: string;
  /**
   * The measurement unit of rate. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  measureUnit?: EnergyBillingUsageTransactionMeasureUnitEnum;
  /**
   * The usage for the period in measure unit.  A negative value indicates power generated
   * @type {number}
   * @memberof EnergyBillingUsageTransaction
   */
  usage: number;
  /**
   * The amount charged or credited for this transaction prior to any adjustments being applied.  A negative value indicates a credit
   * @type {string}
   * @memberof EnergyBillingUsageTransaction
   */
  amount: string;
  /**
   * Additional calculation factors that inform the transaction
   * @type {Array<EnergyBillingUsageTransactionCalculationFactors>}
   * @memberof EnergyBillingUsageTransaction
   */
  calculationFactors?: Array<EnergyBillingUsageTransactionCalculationFactors>;
  /**
   * Optional array of adjustments arising for this transaction
   * @type {Array<EnergyBillingUsageTransactionAdjustments>}
   * @memberof EnergyBillingUsageTransaction
   */
  adjustments?: Array<EnergyBillingUsageTransactionAdjustments>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyBillingUsageTransactionTimeOfUseTypeEnum {
  PEAK = 'PEAK',
  OFFPEAK = 'OFF_PEAK',
  OFFPEAKDEMANDCHARGE = 'OFF_PEAK_DEMAND_CHARGE',
  SHOULDER = 'SHOULDER',
  SHOULDER1 = 'SHOULDER1',
  SHOULDER2 = 'SHOULDER2',
  CONTROLLEDLOAD = 'CONTROLLED_LOAD',
  SOLAR = 'SOLAR',
  AGGREGATE = 'AGGREGATE',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyBillingUsageTransactionMeasureUnitEnum {
  KWH = 'KWH',
  KVA = 'KVA',
  KVAR = 'KVAR',
  KVARH = 'KVARH',
  KW = 'KW',
  DAYS = 'DAYS',
  METER = 'METER',
  MONTH = 'MONTH',
}

/**
 *
 * @export
 * @interface EnergyBillingUsageTransactionAdjustments
 */
export interface EnergyBillingUsageTransactionAdjustments {
  /**
   * The amount of the adjustment
   * @type {string}
   * @memberof EnergyBillingUsageTransactionAdjustments
   */
  amount: string;
  /**
   * A free text description of the adjustment
   * @type {string}
   * @memberof EnergyBillingUsageTransactionAdjustments
   */
  description: string;
}
/**
 *
 * @export
 * @interface EnergyBillingUsageTransactionCalculationFactors
 */
export interface EnergyBillingUsageTransactionCalculationFactors {
  /**
   * The value of the calculation factor
   * @type {number}
   * @memberof EnergyBillingUsageTransactionCalculationFactors
   */
  value: number;
  /**
   * The type of the calculation factor
   * @type {string}
   * @memberof EnergyBillingUsageTransactionCalculationFactors
   */
  type: EnergyBillingUsageTransactionCalculationFactorsTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyBillingUsageTransactionCalculationFactorsTypeEnum {
  DLF = 'DLF',
  MLF = 'MLF',
}

/**
 *
 * @export
 * @interface EnergyConcession
 */
export interface EnergyConcession {
  /**
   * The display name of the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  displayName: string;
  /**
   * Display text providing more information on the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  additionalInfo?: string;
  /**
   * Optional link to additional information regarding the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  additionalInfoUri?: string;
  /**
   * Optional start date for the application of the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  startDate?: string;
  /**
   * Optional end date for the application of the concession
   * @type {string}
   * @memberof EnergyConcession
   */
  endDate?: string;
  /**
   * Daily discount value due to the concession.  At least one dailyDiscount, monthlyDiscount, yearlyDiscount and percentageDiscount must be provided
   * @type {string}
   * @memberof EnergyConcession
   */
  dailyDiscount?: string;
  /**
   * Monthly discount value due to the concession.  At least one dailyDiscount, monthlyDiscount, yearlyDiscount and percentageDiscount must be provided
   * @type {string}
   * @memberof EnergyConcession
   */
  monthlyDiscount?: string;
  /**
   * Annual discount value due to the concession.  At least one dailyDiscount, monthlyDiscount, yearlyDiscount and percentageDiscount must be provided
   * @type {string}
   * @memberof EnergyConcession
   */
  yearlyDiscount?: string;
  /**
   * Percentage of each invoice to be discounted due to the concession.  At least one dailyDiscount, monthlyDiscount, yearlyDiscount and percentageDiscount must be provided
   * @type {string}
   * @memberof EnergyConcession
   */
  percentageDiscount?: string;
}
/**
 *
 * @export
 * @interface EnergyDerRecord
 */
export interface EnergyDerRecord {
  /**
   * Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyDerRecord
   */
  servicePointId: string;
  /**
   * Approved small generating unit capacity as agreed with NSP in the connection agreement, expressed in kVA
   * @type {number}
   * @memberof EnergyDerRecord
   */
  approvedCapacity: number;
  /**
   * The number of phases available for the installation of DER
   * @type {number}
   * @memberof EnergyDerRecord
   */
  availablePhasesCount: number;
  /**
   * The number of phases that DER is connected to
   * @type {number}
   * @memberof EnergyDerRecord
   */
  installedPhasesCount: number;
  /**
   * For identification of small generating units designed with the ability to operate in an islanded mode
   * @type {string}
   * @memberof EnergyDerRecord
   */
  islandableInstallation: string;
  /**
   * For DER installations where NSPs specify the need for additional forms of protection above those inbuilt in an inverter.  If absent then assumed to be false
   * @type {boolean}
   * @memberof EnergyDerRecord
   */
  hasCentralProtectionControl?: boolean;
  /**
   *
   * @type {EnergyDerRecordProtectionMode}
   * @memberof EnergyDerRecord
   */
  protectionMode?: EnergyDerRecordProtectionMode;
  /**
   *
   * @type {Array<EnergyDerRecordAcConnections>}
   * @memberof EnergyDerRecord
   */
  acConnections: Array<EnergyDerRecordAcConnections>;
}
/**
 *
 * @export
 * @interface EnergyDerRecordAcConnections
 */
export interface EnergyDerRecordAcConnections {
  /**
   * AC Connection ID as defined in the DER register.  Does not align with CDR ID permanence standards
   * @type {number}
   * @memberof EnergyDerRecordAcConnections
   */
  connectionIdentifier: number;
  /**
   * Number of AC Connections in the group. For the suite of AC Connections to be considered as a group, all of the AC Connections included must have the same attributes
   * @type {number}
   * @memberof EnergyDerRecordAcConnections
   */
  count: number;
  /**
   * Indicates whether the DER device is connected via an inverter (and what category of inverter it is) or not (e.g. rotating machine). If absent, assume equipment type to be OTHER.
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  equipmentType?: EnergyDerRecordAcConnectionsEquipmentTypeEnum;
  /**
   * The name of the inverter manufacturer. Mandatory if equipmentType is INVERTER
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  manufacturerName?: string;
  /**
   * The inverter series. Mandatory if equipmentType is INVERTER
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  inverterSeries?: string;
  /**
   * The inverter model number. Mandatory if equipmentType is INVERTER
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  inverterModelNumber?: string;
  /**
   * The date that the DER installation is commissioned
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  commissioningDate: string;
  /**
   * Code used to indicate the status of the Inverter. This will be used to identify if an inverter is active or inactive or decommissioned
   * @type {string}
   * @memberof EnergyDerRecordAcConnections
   */
  status: EnergyDerRecordAcConnectionsStatusEnum;
  /**
   * The rated AC output power that is listed in the product specified by the manufacturer. Mandatory if equipmentType is INVERTER
   * @type {number}
   * @memberof EnergyDerRecordAcConnections
   */
  inverterDeviceCapacity?: number;
  /**
   *
   * @type {Array<EnergyDerRecordDerDevices>}
   * @memberof EnergyDerRecordAcConnections
   */
  derDevices: Array<EnergyDerRecordDerDevices>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyDerRecordAcConnectionsEquipmentTypeEnum {
  INVERTER = 'INVERTER',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyDerRecordAcConnectionsStatusEnum {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  DECOMMISSIONED = 'DECOMMISSIONED',
}

/**
 *
 * @export
 * @interface EnergyDerRecordDerDevices
 */
export interface EnergyDerRecordDerDevices {
  /**
   * Unique identifier for a single DER device or a group of DER devices with the same attributes. Does not align with CDR ID permanence standards
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  deviceIdentifier: number;
  /**
   * Number of devices in the group of DER devices
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  count: number;
  /**
   * The name of the device manufacturer. If absent then assumed to be unknown
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  manufacturer?: string;
  /**
   * The model number of the device. If absent then assumed to be unknown
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  modelNumber?: string;
  /**
   * Code used to indicate the status of the device. This will be used to identify if an inverter is active or inactive or decommissioned
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  status?: EnergyDerRecordDerDevicesStatusEnum;
  /**
   * Used to indicate the primary technology used in the DER device
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  type: EnergyDerRecordDerDevicesTypeEnum;
  /**
   * Used to indicate the primary technology used in the DER device. This field is also used to record for example the battery chemistry, or the type of PV panel. It is also used to record if a battery is contained in an electric vehicle connected in a vehicle-to-grid arrangement. If absent then assumed to be other
   * @type {string}
   * @memberof EnergyDerRecordDerDevices
   */
  subtype?: string;
  /**
   * Maximum output in kVA that is listed in the product specification by the manufacturer. This refers to the capacity of each unit within the device group
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  nominalRatedCapacity: number;
  /**
   * Maximum storage capacity in kVAh. This refers to the capacity of each storage module within the device group. Mandatory if type is equal to STORAGE
   * @type {number}
   * @memberof EnergyDerRecordDerDevices
   */
  nominalStorageCapacity?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyDerRecordDerDevicesStatusEnum {
  ACTIVE = 'ACTIVE',
  INACTIVE = 'INACTIVE',
  DECOMMISSIONED = 'DECOMMISSIONED',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyDerRecordDerDevicesTypeEnum {
  FOSSIL = 'FOSSIL',
  HYDRO = 'HYDRO',
  WIND = 'WIND',
  SOLARPV = 'SOLAR_PV',
  RENEWABLE = 'RENEWABLE',
  GEOTHERMAL = 'GEOTHERMAL',
  STORAGE = 'STORAGE',
  OTHER = 'OTHER',
}

/**
 * Required only when the hasCentralProtectionAndControl flag is set to true.  One or more of the object fields will be provided to describe the protection modes in place
 * @export
 * @interface EnergyDerRecordProtectionMode
 */
export interface EnergyDerRecordProtectionMode {
  /**
   * Maximum amount of power (kVA) that may be exported from a connection point to the grid, as monitored by a control / relay function. An absent value indicates no limit
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  exportLimitkva?: number;
  /**
   * Protective function limit in Hz.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underFrequencyProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underFrequencyProtectionDelay?: number;
  /**
   * Protective function limit in Hz.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overFrequencyProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overFrequencyProtectionDelay?: number;
  /**
   * Protective function limit in V.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underVoltageProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  underVoltageProtectionDelay?: number;
  /**
   * Protective function limit in V.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overVoltageProtection?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  overVoltageProtectionDelay?: number;
  /**
   * Sustained over voltage.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  sustainedOverVoltage?: number;
  /**
   * Trip delay time in seconds.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  sustainedOverVoltageDelay?: number;
  /**
   * Rate of change of frequency trip point (Hz/s).
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  frequencyRateOfChange?: number;
  /**
   * Trip angle in degrees.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  voltageVectorShift?: number;
  /**
   * Description of the form of inter-trip (e.g. \'from local substation\').
   * @type {string}
   * @memberof EnergyDerRecordProtectionMode
   */
  interTripScheme?: string;
  /**
   * Trip voltage.
   * @type {number}
   * @memberof EnergyDerRecordProtectionMode
   */
  neutralVoltageDisplacement?: number;
}
/**
 *
 * @export
 * @interface EnergyInvoice
 */
export interface EnergyInvoice {
  /**
   * The ID of the account for which the invoice was issued
   * @type {string}
   * @memberof EnergyInvoice
   */
  accountId: string;
  /**
   * The number assigned to this invoice by the energy Retailer
   * @type {string}
   * @memberof EnergyInvoice
   */
  invoiceNumber: string;
  /**
   * The date that the invoice was actually issued (as opposed to generated or calculated)
   * @type {string}
   * @memberof EnergyInvoice
   */
  issueDate: string;
  /**
   * The date that the invoice is due to be paid
   * @type {string}
   * @memberof EnergyInvoice
   */
  dueDate?: string;
  /**
   *
   * @type {EnergyInvoicePeriod}
   * @memberof EnergyInvoice
   */
  period?: EnergyInvoicePeriod;
  /**
   * The net amount due for this invoice regardless of previous balance
   * @type {string}
   * @memberof EnergyInvoice
   */
  invoiceAmount?: string;
  /**
   * The total GST amount for this invoice.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoice
   */
  gstAmount?: string;
  /**
   *
   * @type {EnergyInvoicePayOnTimeDiscount}
   * @memberof EnergyInvoice
   */
  payOnTimeDiscount?: EnergyInvoicePayOnTimeDiscount;
  /**
   * The account balance at the time the invoice was issued
   * @type {string}
   * @memberof EnergyInvoice
   */
  balanceAtIssue: string;
  /**
   * Array of service point IDs to which this invoice applies. May be empty if the invoice contains no electricity usage related charges
   * @type {Array<string>}
   * @memberof EnergyInvoice
   */
  servicePoints: Array<string>;
  /**
   *
   * @type {EnergyInvoiceGasUsageCharges}
   * @memberof EnergyInvoice
   */
  gas?: EnergyInvoiceGasUsageCharges;
  /**
   *
   * @type {EnergyInvoiceElectricityUsageCharges}
   * @memberof EnergyInvoice
   */
  electricity?: EnergyInvoiceElectricityUsageCharges;
  /**
   *
   * @type {EnergyInvoiceAccountCharges}
   * @memberof EnergyInvoice
   */
  accountCharges?: EnergyInvoiceAccountCharges;
  /**
   * Indicator of the payment status for the invoice
   * @type {string}
   * @memberof EnergyInvoice
   */
  paymentStatus: EnergyInvoicePaymentStatusEnum;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyInvoice
   */
  adatree: Adatree;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyInvoicePaymentStatusEnum {
  PAID = 'PAID',
  PARTIALLYPAID = 'PARTIALLY_PAID',
  NOTPAID = 'NOT_PAID',
}

/**
 * Object contain charges and credits related to electricity usage
 * @export
 * @interface EnergyInvoiceAccountCharges
 */
export interface EnergyInvoiceAccountCharges {
  /**
   * The aggregate total of account level charges for the period covered by the invoice
   * @type {string}
   * @memberof EnergyInvoiceAccountCharges
   */
  totalCharges: string;
  /**
   * The aggregate total of account level discounts or credits for the period covered by the invoice
   * @type {string}
   * @memberof EnergyInvoiceAccountCharges
   */
  totalDiscounts: string;
  /**
   * The total GST for all account level charges.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoiceAccountCharges
   */
  totalGst?: string;
}
/**
 *
 * @export
 * @interface EnergyInvoiceElectricityUsageCharges
 */
export interface EnergyInvoiceElectricityUsageCharges {
  /**
   * The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalUsageCharges: string;
  /**
   * The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalGenerationCredits: string;
  /**
   * The aggregate total of any once-off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalOnceOffCharges: string;
  /**
   * The aggregate total of any once-off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalOnceOffDiscounts: string;
  /**
   * Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
   * @type {Array<EnergyInvoiceGasUsageChargesOtherCharges>}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  otherCharges?: Array<EnergyInvoiceGasUsageChargesOtherCharges>;
  /**
   * The total GST for all electricity usage charges.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoiceElectricityUsageCharges
   */
  totalGst?: string;
}
/**
 *
 * @export
 * @interface EnergyInvoiceGasUsageCharges
 */
export interface EnergyInvoiceGasUsageCharges {
  /**
   * The aggregate total of usage charges for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalUsageCharges: string;
  /**
   * The aggregate total of generation credits for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalGenerationCredits: string;
  /**
   * The aggregate total of any once-off charges arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalOnceOffCharges: string;
  /**
   * The aggregate total of any once-off discounts or credits arising from electricity usage for the period covered by the invoice (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalOnceOffDiscounts: string;
  /**
   * Optional array of charges that may be part of the invoice (for e.g. environmental charges for C&I consumers) (exclusive of GST)
   * @type {Array<EnergyInvoiceGasUsageChargesOtherCharges>}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  otherCharges?: Array<EnergyInvoiceGasUsageChargesOtherCharges>;
  /**
   * The total GST for all electricity usage charges.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoiceGasUsageCharges
   */
  totalGst?: string;
}
/**
 *
 * @export
 * @interface EnergyInvoiceGasUsageChargesOtherCharges
 */
export interface EnergyInvoiceGasUsageChargesOtherCharges {
  /**
   * Type of charge. Assumed to be other if absent
   * @type {string}
   * @memberof EnergyInvoiceGasUsageChargesOtherCharges
   */
  type?: EnergyInvoiceGasUsageChargesOtherChargesTypeEnum;
  /**
   * The aggregate total of charges for this item (exclusive of GST)
   * @type {string}
   * @memberof EnergyInvoiceGasUsageChargesOtherCharges
   */
  amount: string;
  /**
   * A free text description of the type of charge
   * @type {string}
   * @memberof EnergyInvoiceGasUsageChargesOtherCharges
   */
  description: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyInvoiceGasUsageChargesOtherChargesTypeEnum {
  ENVIRONMENTAL = 'ENVIRONMENTAL',
  REGULATED = 'REGULATED',
  NETWORK = 'NETWORK',
  METERING = 'METERING',
  RETAILSERVICE = 'RETAIL_SERVICE',
  RCTI = 'RCTI',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface EnergyInvoiceList
 */
export interface EnergyInvoiceList {
  /**
   *
   * @type {EnergyInvoiceListData}
   * @memberof EnergyInvoiceList
   */
  data: EnergyInvoiceListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyInvoiceList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyInvoiceList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyInvoiceListData
 */
export interface EnergyInvoiceListData {
  /**
   * Array of invoices sorted by date in descending order
   * @type {Array<EnergyInvoice>}
   * @memberof EnergyInvoiceListData
   */
  invoices: Array<EnergyInvoice>;
}
/**
 * A discount for on time payment
 * @export
 * @interface EnergyInvoicePayOnTimeDiscount
 */
export interface EnergyInvoicePayOnTimeDiscount {
  /**
   * The amount that will be discounted if the invoice is paid by the date specified
   * @type {string}
   * @memberof EnergyInvoicePayOnTimeDiscount
   */
  discountAmount: string;
  /**
   * The GST amount that will be discounted if the invoice is paid by the date specified.  If absent then zero is assumed
   * @type {string}
   * @memberof EnergyInvoicePayOnTimeDiscount
   */
  gstAmount?: string;
  /**
   * The date by which the invoice must be paid to receive the pay on time discount
   * @type {string}
   * @memberof EnergyInvoicePayOnTimeDiscount
   */
  date: string;
}
/**
 * Object containing the start and end date for the period covered by the invoice.  Mandatory if any usage or demand based charges are included in the invoice
 * @export
 * @interface EnergyInvoicePeriod
 */
export interface EnergyInvoicePeriod {
  /**
   * The start date of the period covered by this invoice
   * @type {string}
   * @memberof EnergyInvoicePeriod
   */
  startDate: string;
  /**
   * The end date of the period covered by this invoice
   * @type {string}
   * @memberof EnergyInvoicePeriod
   */
  endDate: string;
}
/**
 *
 * @export
 * @interface EnergyPaymentSchedule
 */
export interface EnergyPaymentSchedule {
  /**
   * Optional payment amount indicating that a constant payment amount is scheduled to be paid (used in bill smooting scenarios)
   * @type {string}
   * @memberof EnergyPaymentSchedule
   */
  amount?: string;
  /**
   * The type of object present in this response
   * @type {string}
   * @memberof EnergyPaymentSchedule
   */
  paymentScheduleUType: EnergyPaymentSchedulePaymentScheduleUTypeEnum;
  /**
   *
   * @type {EnergyPaymentScheduleCardDebit}
   * @memberof EnergyPaymentSchedule
   */
  cardDebit?: EnergyPaymentScheduleCardDebit;
  /**
   *
   * @type {EnergyPaymentScheduleDirectDebit}
   * @memberof EnergyPaymentSchedule
   */
  directDebit?: EnergyPaymentScheduleDirectDebit;
  /**
   *
   * @type {EnergyPaymentScheduleManualPayment}
   * @memberof EnergyPaymentSchedule
   */
  manualPayment?: EnergyPaymentScheduleManualPayment;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPaymentSchedulePaymentScheduleUTypeEnum {
  CardDebit = 'cardDebit',
  DirectDebit = 'directDebit',
  ManualPayment = 'manualPayment',
}

/**
 * Represents a regular credit card payment schedule. Mandatory if paymentScheduleUType is set to cardDebit
 * @export
 * @interface EnergyPaymentScheduleCardDebit
 */
export interface EnergyPaymentScheduleCardDebit {
  /**
   * The type of credit card held on file
   * @type {string}
   * @memberof EnergyPaymentScheduleCardDebit
   */
  cardScheme: EnergyPaymentScheduleCardDebitCardSchemeEnum;
  /**
   * The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPaymentScheduleCardDebit
   */
  paymentFrequency: string;
  /**
   * The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
   * @type {string}
   * @memberof EnergyPaymentScheduleCardDebit
   */
  calculationType: EnergyPaymentScheduleCardDebitCalculationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPaymentScheduleCardDebitCardSchemeEnum {
  VISA = 'VISA',
  MASTERCARD = 'MASTERCARD',
  AMEX = 'AMEX',
  DINERS = 'DINERS',
  OTHER = 'OTHER',
  UNKNOWN = 'UNKNOWN',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPaymentScheduleCardDebitCalculationTypeEnum {
  STATIC = 'STATIC',
  BALANCE = 'BALANCE',
  CALCULATED = 'CALCULATED',
}

/**
 * Represents a regular direct debit from a specified bank account. Mandatory if paymentScheduleUType is set to directDebit
 * @export
 * @interface EnergyPaymentScheduleDirectDebit
 */
export interface EnergyPaymentScheduleDirectDebit {
  /**
   * Flag indicating that the account details are tokenised and cannot be shared.  False if absent.  If false then bsb and accountNumber should not be expected to be included
   * @type {boolean}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  isTokenised?: boolean;
  /**
   * The unmasked BSB for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  bsb?: string;
  /**
   * The unmasked account number for the account to be debited. Is expected to be formatted as digits only with leading zeros included and no punctuation or spaces.  Is required if isTokenised is absent or false
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  accountNumber?: string;
  /**
   * The frequency that payments will occur.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  paymentFrequency: string;
  /**
   * The mechanism by which the payment amount is calculated.  Explanation of values are as follows:<br/><ul><li>**STATIC** - Indicates a consistent, static amount, per payment</li><li>**BALANCE** - Indicates that the outstanding balance for the account is paid per period</li><li>**CALCULATED** - Indicates that the payment amount is variable and calculated using a pre-defined algorithm</li></ul>
   * @type {string}
   * @memberof EnergyPaymentScheduleDirectDebit
   */
  calculationType: EnergyPaymentScheduleDirectDebitCalculationTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPaymentScheduleDirectDebitCalculationTypeEnum {
  STATIC = 'STATIC',
  BALANCE = 'BALANCE',
  CALCULATED = 'CALCULATED',
}

/**
 * Represents a manual payment schedule where the customer pays in response to a delivered statement. Mandatory if paymentScheduleUType is set to manualPayment
 * @export
 * @interface EnergyPaymentScheduleManualPayment
 */
export interface EnergyPaymentScheduleManualPayment {
  /**
   * The frequency with which a bill will be issued.  Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPaymentScheduleManualPayment
   */
  billFrequency: string;
}
/**
 *
 * @export
 * @interface EnergyPlan
 */
export interface EnergyPlan {
  /**
   * The ID of the specific plan
   * @type {string}
   * @memberof EnergyPlan
   */
  planId: string;
  /**
   * The date and time from which this plan is effective (i.e. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
   * @type {string}
   * @memberof EnergyPlan
   */
  effectiveFrom?: string;
  /**
   * The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
   * @type {string}
   * @memberof EnergyPlan
   */
  effectiveTo?: string;
  /**
   * The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
   * @type {string}
   * @memberof EnergyPlan
   */
  lastUpdated: string;
  /**
   * The display name of the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  displayName?: string;
  /**
   * A description of the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  description?: string;
  /**
   * The type of the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  type: EnergyPlanTypeEnum;
  /**
   * The fuel types covered by the plan
   * @type {string}
   * @memberof EnergyPlan
   */
  fuelType: EnergyPlanFuelTypeEnum;
  /**
   * The ID of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlan
   */
  brand: string;
  /**
   * The display name of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlan
   */
  brandName: string;
  /**
   * A link to an application web page where this plan can be applied for
   * @type {string}
   * @memberof EnergyPlan
   */
  applicationUri?: string;
  /**
   *
   * @type {EnergyPlanAdditionalInformation}
   * @memberof EnergyPlan
   */
  additionalInformation?: EnergyPlanAdditionalInformation;
  /**
   * The type of customer that the plan is offered to.  If absent then the plan is available to all customers
   * @type {string}
   * @memberof EnergyPlan
   */
  customerType?: EnergyPlanCustomerTypeEnum;
  /**
   *
   * @type {EnergyPlanGeography}
   * @memberof EnergyPlan
   */
  geography?: EnergyPlanGeography;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanTypeEnum {
  STANDING = 'STANDING',
  MARKET = 'MARKET',
  REGULATED = 'REGULATED',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanFuelTypeEnum {
  ELECTRICITY = 'ELECTRICITY',
  GAS = 'GAS',
  DUAL = 'DUAL',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanCustomerTypeEnum {
  RESIDENTIAL = 'RESIDENTIAL',
  BUSINESS = 'BUSINESS',
}

/**
 * Object that contains links to additional information on specific topics
 * @export
 * @interface EnergyPlanAdditionalInformation
 */
export interface EnergyPlanAdditionalInformation {
  /**
   * A link to a general overview of the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  overviewUri?: string;
  /**
   * A link to terms and conditions for the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  termsUri?: string;
  /**
   * A link to detail on eligibility criteria for the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  eligibilityUri?: string;
  /**
   * A link to detail on pricing for the plan
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  pricingUri?: string;
  /**
   * A link to detail on bundles that this plan can be a part of
   * @type {string}
   * @memberof EnergyPlanAdditionalInformation
   */
  bundleUri?: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContract
 */
export interface EnergyPlanContract {
  /**
   * Free text field containing additional information of the fees for this contract
   * @type {string}
   * @memberof EnergyPlanContract
   */
  additionalFeeInformation?: string;
  /**
   * The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE**  usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE**  usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
   * @type {string}
   * @memberof EnergyPlanContract
   */
  pricingModel: EnergyPlanContractPricingModelEnum;
  /**
   * Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds
   * @type {string}
   * @memberof EnergyPlanContract
   */
  timeZone?: EnergyPlanContractTimeZoneEnum;
  /**
   * Flag indicating whether prices are fixed or variable
   * @type {boolean}
   * @memberof EnergyPlanContract
   */
  isFixed: boolean;
  /**
   * Free text description of price variation policy and conditions for the contract.  Mandatory if isFixed is true
   * @type {string}
   * @memberof EnergyPlanContract
   */
  variation?: string;
  /**
   * Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
   * @type {string}
   * @memberof EnergyPlanContract
   */
  onExpiryDescription?: string;
  /**
   * Payment options for this contract
   * @type {Array<string>}
   * @memberof EnergyPlanContract
   */
  paymentOption: Array<EnergyPlanContractPaymentOptionEnum>;
  /**
   *
   * @type {EnergyPlanContractIntrinsicGreenPower}
   * @memberof EnergyPlanContract
   */
  intrinsicGreenPower?: EnergyPlanContractIntrinsicGreenPower;
  /**
   *
   * @type {EnergyPlanControlledLoad}
   * @memberof EnergyPlanContract
   */
  controlledLoad?: EnergyPlanControlledLoad;
  /**
   * Optional list of incentives available for the contract
   * @type {Array<EnergyPlanContractIncentives>}
   * @memberof EnergyPlanContract
   */
  incentives?: Array<EnergyPlanContractIncentives>;
  /**
   * Optional list of discounts available for the contract
   * @type {Array<EnergyPlanContractDiscounts>}
   * @memberof EnergyPlanContract
   */
  discounts?: Array<EnergyPlanContractDiscounts>;
  /**
   * Optional list of charges applicable to green power
   * @type {Array<EnergyPlanContractGreenPowerCharges>}
   * @memberof EnergyPlanContract
   */
  greenPowerCharges?: Array<EnergyPlanContractGreenPowerCharges>;
  /**
   * Eligibility restrictions or requirements
   * @type {Array<EnergyPlanContractEligibility>}
   * @memberof EnergyPlanContract
   */
  eligibility?: Array<EnergyPlanContractEligibility>;
  /**
   * An array of fees applicable to the plan
   * @type {Array<EnergyPlanContractFees>}
   * @memberof EnergyPlanContract
   */
  fees?: Array<EnergyPlanContractFees>;
  /**
   * Array of feed in tariffs for solar power
   * @type {Array<EnergyPlanContractSolarFeedInTariff>}
   * @memberof EnergyPlanContract
   */
  solarFeedInTariff?: Array<EnergyPlanContractSolarFeedInTariff>;
  /**
   * Array of tariff periods
   * @type {Array<EnergyPlanContractTariffPeriod>}
   * @memberof EnergyPlanContract
   */
  tariffPeriod: Array<EnergyPlanContractTariffPeriod>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractPricingModelEnum {
  SINGLERATE = 'SINGLE_RATE',
  SINGLERATECONTLOAD = 'SINGLE_RATE_CONT_LOAD',
  TIMEOFUSE = 'TIME_OF_USE',
  TIMEOFUSECONTLOAD = 'TIME_OF_USE_CONT_LOAD',
  FLEXIBLE = 'FLEXIBLE',
  FLEXIBLECONTLOAD = 'FLEXIBLE_CONT_LOAD',
  QUOTA = 'QUOTA',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractTimeZoneEnum {
  LOCAL = 'LOCAL',
  AEST = 'AEST',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractPaymentOptionEnum {
  PAPERBILL = 'PAPER_BILL',
  CREDITCARD = 'CREDIT_CARD',
  DIRECTDEBIT = 'DIRECT_DEBIT',
  BPAY = 'BPAY',
  OTHER = 'OTHER',
}

/**
 * Object containing demand tariff by day of week
 * @export
 * @interface EnergyPlanContractDays
 */
export interface EnergyPlanContractDays {
  /**
   * Indicates the demand tariff is applicable on weekdays
   * @type {boolean}
   * @memberof EnergyPlanContractDays
   */
  weekdays: boolean;
  /**
   * Indicates the demand tariff is applicable on Saturdays
   * @type {boolean}
   * @memberof EnergyPlanContractDays
   */
  saturday: boolean;
  /**
   * Indicates the demand tariff is applicable on Sundays
   * @type {boolean}
   * @memberof EnergyPlanContractDays
   */
  sunday: boolean;
}
/**
 *
 * @export
 * @interface EnergyPlanContractDemandCharges
 */
export interface EnergyPlanContractDemandCharges {
  /**
   * Display name of the charge
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  displayName: string;
  /**
   * Description of the charge
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  description?: string;
  /**
   * The charge amount per  measure unit exclusive of GST
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  amount: string;
  /**
   * The measurement unit of charge amount. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  measureUnit?: EnergyPlanContractDemandChargesMeasureUnitEnum;
  /**
   * Start of the period in HHMM format using 24 hour clock format
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  startTime: string;
  /**
   * End of the period in HHMM format using 24 hour clock format
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  endTime: string;
  /**
   *
   * @type {EnergyPlanContractDays}
   * @memberof EnergyPlanContractDemandCharges
   */
  days?: EnergyPlanContractDays;
  /**
   * Minimum demand for this demand tariff in kW.  If absent then 0 is assumed
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  minDemand?: string;
  /**
   * Maximum demand for this demand tariff in kW.  If present, must be higher than the value of the minDemand field
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  maxDemand?: string;
  /**
   * Application period for the demand tariff
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  measurementPeriod: EnergyPlanContractDemandChargesMeasurementPeriodEnum;
  /**
   * Charge period for the demand tariff
   * @type {string}
   * @memberof EnergyPlanContractDemandCharges
   */
  chargePeriod: EnergyPlanContractDemandChargesChargePeriodEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractDemandChargesMeasureUnitEnum {
  KWH = 'KWH',
  KVA = 'KVA',
  KVAR = 'KVAR',
  KVARH = 'KVARH',
  KW = 'KW',
  DAYS = 'DAYS',
  METER = 'METER',
  MONTH = 'MONTH',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractDemandChargesMeasurementPeriodEnum {
  DAY = 'DAY',
  MONTH = 'MONTH',
  TARIFFPERIOD = 'TARIFF_PERIOD',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractDemandChargesChargePeriodEnum {
  DAY = 'DAY',
  MONTH = 'MONTH',
  TARIFFPERIOD = 'TARIFF_PERIOD',
}

/**
 *
 * @export
 * @interface EnergyPlanContractDiscounts
 */
export interface EnergyPlanContractDiscounts {
  /**
   * The display name of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscounts
   */
  displayName: string;
  /**
   * The description of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscounts
   */
  description?: string;
  /**
   * The type of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscounts
   */
  type: EnergyPlanContractDiscountsTypeEnum;
  /**
   * The type of the discount.  Mandatory if the discount type is CONDITIONAL
   * @type {string}
   * @memberof EnergyPlanContractDiscounts
   */
  category?: EnergyPlanContractDiscountsCategoryEnum;
  /**
   * Optional end date for the discount after which the discount is no longer available
   * @type {string}
   * @memberof EnergyPlanContractDiscounts
   */
  endDate?: string;
  /**
   * The method of calculation of the discount
   * @type {string}
   * @memberof EnergyPlanContractDiscounts
   */
  methodUType: EnergyPlanContractDiscountsMethodUTypeEnum;
  /**
   *
   * @type {EnergyPlanContractPercentOfBill}
   * @memberof EnergyPlanContractDiscounts
   */
  percentOfBill?: EnergyPlanContractPercentOfBill;
  /**
   *
   * @type {EnergyPlanContractPercentOfUse}
   * @memberof EnergyPlanContractDiscounts
   */
  percentOfUse?: EnergyPlanContractPercentOfUse;
  /**
   *
   * @type {EnergyPlanContractFixedAmount}
   * @memberof EnergyPlanContractDiscounts
   */
  fixedAmount?: EnergyPlanContractFixedAmount;
  /**
   *
   * @type {EnergyPlanContractPercentOverThreshold}
   * @memberof EnergyPlanContractDiscounts
   */
  percentOverThreshold?: EnergyPlanContractPercentOverThreshold;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractDiscountsTypeEnum {
  CONDITIONAL = 'CONDITIONAL',
  GUARANTEED = 'GUARANTEED',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractDiscountsCategoryEnum {
  PAYONTIME = 'PAY_ON_TIME',
  DIRECTDEBIT = 'DIRECT_DEBIT',
  GUARANTEEDDISCOUNT = 'GUARANTEED_DISCOUNT',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractDiscountsMethodUTypeEnum {
  PercentOfBill = 'percentOfBill',
  PercentOfUse = 'percentOfUse',
  FixedAmount = 'fixedAmount',
  PercentOverThreshold = 'percentOverThreshold',
}

/**
 *
 * @export
 * @interface EnergyPlanContractEligibility
 */
export interface EnergyPlanContractEligibility {
  /**
   * The type of the eligibility restriction.<br/>The CONTINGENT_PLAN value indicates that the plan is contingent on the customer taking up an alternate fuel plan from the same retailer (for instance, if the fuelType is ELECTRICITY then a GAS plan from the same retailer must be taken up)
   * @type {string}
   * @memberof EnergyPlanContractEligibility
   */
  type: EnergyPlanContractEligibilityTypeEnum;
  /**
   * Information of the eligibility restriction specific to the type of the restriction
   * @type {string}
   * @memberof EnergyPlanContractEligibility
   */
  information: string;
  /**
   * A description of the eligibility restriction
   * @type {string}
   * @memberof EnergyPlanContractEligibility
   */
  description?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractEligibilityTypeEnum {
  EXISTINGCUST = 'EXISTING_CUST',
  EXISTINGPOOL = 'EXISTING_POOL',
  EXISTINGSOLAR = 'EXISTING_SOLAR',
  EXISTINGBATTERY = 'EXISTING_BATTERY',
  EXISTINGSMARTMETER = 'EXISTING_SMART_METER',
  EXISTINGBASICMETER = 'EXISTING_BASIC_METER',
  SENIORCARD = 'SENIOR_CARD',
  SMALLBUSINESS = 'SMALL_BUSINESS',
  NOSOLARFIT = 'NO_SOLAR_FIT',
  NEWCUSTOMER = 'NEW_CUSTOMER',
  ONLINEONLY = 'ONLINE_ONLY',
  REQEQUIPSUPPLIER = 'REQ_EQUIP_SUPPLIER',
  THIRDPARTYONLY = 'THIRD_PARTY_ONLY',
  SPORTCLUBMEMBER = 'SPORT_CLUB_MEMBER',
  ORGMEMBER = 'ORG_MEMBER',
  SPECIFICLOCATION = 'SPECIFIC_LOCATION',
  MINIMUMUSAGE = 'MINIMUM_USAGE',
  LOYALTYMEMBER = 'LOYALTY_MEMBER',
  GROUPBUYMEMBER = 'GROUP_BUY_MEMBER',
  CONTINGENTPLAN = 'CONTINGENT_PLAN',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface EnergyPlanContractFees
 */
export interface EnergyPlanContractFees {
  /**
   * The type of the fee
   * @type {string}
   * @memberof EnergyPlanContractFees
   */
  type: EnergyPlanContractFeesTypeEnum;
  /**
   * The term of the fee
   * @type {string}
   * @memberof EnergyPlanContractFees
   */
  term: EnergyPlanContractFeesTermEnum;
  /**
   * The fee amount. Required if term is not PERCENT_OF_BILL
   * @type {string}
   * @memberof EnergyPlanContractFees
   */
  amount?: string;
  /**
   * The fee rate. Required if term is PERCENT_OF_BILL
   * @type {string}
   * @memberof EnergyPlanContractFees
   */
  rate?: string;
  /**
   * A description of the fee
   * @type {string}
   * @memberof EnergyPlanContractFees
   */
  description?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractFeesTypeEnum {
  EXIT = 'EXIT',
  ESTABLISHMENT = 'ESTABLISHMENT',
  LATEPAYMENT = 'LATE_PAYMENT',
  DISCONNECTION = 'DISCONNECTION',
  DISCONNECTMOVEOUT = 'DISCONNECT_MOVE_OUT',
  DISCONNECTNONPAY = 'DISCONNECT_NON_PAY',
  RECONNECTION = 'RECONNECTION',
  CONNECTION = 'CONNECTION',
  PAYMENTPROCESSING = 'PAYMENT_PROCESSING',
  CCPROCESSING = 'CC_PROCESSING',
  CHEQUEDISHONOUR = 'CHEQUE_DISHONOUR',
  DDDISHONOUR = 'DD_DISHONOUR',
  MEMBERSHIP = 'MEMBERSHIP',
  CONTRIBUTION = 'CONTRIBUTION',
  PAPERBILL = 'PAPER_BILL',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractFeesTermEnum {
  FIXED = 'FIXED',
  _1YEAR = '1_YEAR',
  _2YEAR = '2_YEAR',
  _3YEAR = '3_YEAR',
  _4YEAR = '4_YEAR',
  _5YEAR = '5_YEAR',
  PERCENTOFBILL = 'PERCENT_OF_BILL',
  ANNUAL = 'ANNUAL',
  DAILY = 'DAILY',
  WEEKLY = 'WEEKLY',
  MONTHLY = 'MONTHLY',
  BIANNUAL = 'BIANNUAL',
  VARIABLE = 'VARIABLE',
}

/**
 * Required if methodUType is fixedAmount
 * @export
 * @interface EnergyPlanContractFixedAmount
 */
export interface EnergyPlanContractFixedAmount {
  /**
   * The amount of the discount
   * @type {string}
   * @memberof EnergyPlanContractFixedAmount
   */
  amount: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractFull
 */
export interface EnergyPlanContractFull {
  /**
   * Free text field containing additional information of the fees for this contract
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  additionalFeeInformation?: string;
  /**
   * The pricing model for the contract.  Contracts for gas must use SINGLE_RATE.  Note that the detail for the enumeration values are:<ul><li>**SINGLE_RATE** - all energy usage is charged at a single unit rate no matter when it is consumed. Multiple unit rates may exist that correspond to varying volumes of usage i.e. a block or step tariff (first 50kWh @ X cents, next 50kWh at Y cents etc.</li><li>**SINGLE_RATE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**TIME_OF_USE**  usage is charged at unit rates that vary dependent on time of day and day of week that the energy is consumed</li><li>**TIME_OF_USE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**FLEXIBLE**  usage is charged at unit rates that vary based on external factors</li><li>**FLEXIBLE_CONT_LOAD** - as above, but with an additional, separate unit rate charged for all energy usage from a controlled load i.e. separately metered appliance like hot water service, pool pump etc.</li><li>**QUOTA** - all energy usage is charged at a single fixed rate, up to a specified usage quota/allowance. All excess usage beyond the allowance is then charged at a single unit rate (may not be the best way to explain it but it is essentially a subscription or telco style product i.e. $50/month for up to 150kWh included usage</li></ul>
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  pricingModel: EnergyPlanContractFullPricingModelEnum;
  /**
   * Required if pricingModel is set to TIME_OF_USE.  Defines the time zone to use for calculation of the time of use thresholds
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  timeZone?: EnergyPlanContractFullTimeZoneEnum;
  /**
   * Flag indicating whether prices are fixed or variable
   * @type {boolean}
   * @memberof EnergyPlanContractFull
   */
  isFixed: boolean;
  /**
   * Free text description of price variation policy and conditions for the contract.  Mandatory if isFixed is true
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  variation?: string;
  /**
   * Free text field that describes what will occur on or prior to expiry of the fixed contract term or benefit period
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  onExpiryDescription?: string;
  /**
   * Payment options for this contract
   * @type {Array<string>}
   * @memberof EnergyPlanContractFull
   */
  paymentOption: Array<EnergyPlanContractFullPaymentOptionEnum>;
  /**
   *
   * @type {EnergyPlanContractIntrinsicGreenPower}
   * @memberof EnergyPlanContractFull
   */
  intrinsicGreenPower?: EnergyPlanContractIntrinsicGreenPower;
  /**
   *
   * @type {EnergyPlanControlledLoad}
   * @memberof EnergyPlanContractFull
   */
  controlledLoad?: EnergyPlanControlledLoad;
  /**
   * Optional list of incentives available for the contract
   * @type {Array<EnergyPlanContractIncentives>}
   * @memberof EnergyPlanContractFull
   */
  incentives?: Array<EnergyPlanContractIncentives>;
  /**
   * Optional list of discounts available for the contract
   * @type {Array<EnergyPlanContractDiscounts>}
   * @memberof EnergyPlanContractFull
   */
  discounts?: Array<EnergyPlanContractDiscounts>;
  /**
   * Optional list of charges applicable to green power
   * @type {Array<EnergyPlanContractGreenPowerCharges>}
   * @memberof EnergyPlanContractFull
   */
  greenPowerCharges?: Array<EnergyPlanContractGreenPowerCharges>;
  /**
   * Eligibility restrictions or requirements
   * @type {Array<EnergyPlanContractEligibility>}
   * @memberof EnergyPlanContractFull
   */
  eligibility?: Array<EnergyPlanContractEligibility>;
  /**
   * An array of fees applicable to the plan
   * @type {Array<EnergyPlanContractFees>}
   * @memberof EnergyPlanContractFull
   */
  fees?: Array<EnergyPlanContractFees>;
  /**
   * Array of feed in tariffs for solar power
   * @type {Array<EnergyPlanContractSolarFeedInTariff>}
   * @memberof EnergyPlanContractFull
   */
  solarFeedInTariff?: Array<EnergyPlanContractSolarFeedInTariff>;
  /**
   * Array of tariff periods
   * @type {Array<EnergyPlanContractTariffPeriod>}
   * @memberof EnergyPlanContractFull
   */
  tariffPeriod: Array<EnergyPlanContractTariffPeriod>;
  /**
   * The term for the contract.  If absent assumes no specified term
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  termType?: EnergyPlanContractFullTermTypeEnum;
  /**
   * Description of the benefit period.  Should only be present if termType has the value ONGOING
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  benefitPeriod?: string;
  /**
   * Free text description of the terms for the contract
   * @type {string}
   * @memberof EnergyPlanContractFull
   */
  terms?: string;
  /**
   * An array of the meter types that this contract is available for
   * @type {Array<string>}
   * @memberof EnergyPlanContractFull
   */
  meterTypes?: Array<string>;
  /**
   * Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
   * @type {number}
   * @memberof EnergyPlanContractFull
   */
  coolingOffDays?: number;
  /**
   * An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {Array<string>}
   * @memberof EnergyPlanContractFull
   */
  billFrequency: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractFullPricingModelEnum {
  SINGLERATE = 'SINGLE_RATE',
  SINGLERATECONTLOAD = 'SINGLE_RATE_CONT_LOAD',
  TIMEOFUSE = 'TIME_OF_USE',
  TIMEOFUSECONTLOAD = 'TIME_OF_USE_CONT_LOAD',
  FLEXIBLE = 'FLEXIBLE',
  FLEXIBLECONTLOAD = 'FLEXIBLE_CONT_LOAD',
  QUOTA = 'QUOTA',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractFullTimeZoneEnum {
  LOCAL = 'LOCAL',
  AEST = 'AEST',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractFullPaymentOptionEnum {
  PAPERBILL = 'PAPER_BILL',
  CREDITCARD = 'CREDIT_CARD',
  DIRECTDEBIT = 'DIRECT_DEBIT',
  BPAY = 'BPAY',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractFullTermTypeEnum {
  _1YEAR = '1_YEAR',
  _2YEAR = '2_YEAR',
  _3YEAR = '3_YEAR',
  _4YEAR = '4_YEAR',
  _5YEAR = '5_YEAR',
  ONGOING = 'ONGOING',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface EnergyPlanContractFullAllOf
 */
export interface EnergyPlanContractFullAllOf {
  /**
   * The term for the contract.  If absent assumes no specified term
   * @type {string}
   * @memberof EnergyPlanContractFullAllOf
   */
  termType?: EnergyPlanContractFullAllOfTermTypeEnum;
  /**
   * Description of the benefit period.  Should only be present if termType has the value ONGOING
   * @type {string}
   * @memberof EnergyPlanContractFullAllOf
   */
  benefitPeriod?: string;
  /**
   * Free text description of the terms for the contract
   * @type {string}
   * @memberof EnergyPlanContractFullAllOf
   */
  terms?: string;
  /**
   * An array of the meter types that this contract is available for
   * @type {Array<string>}
   * @memberof EnergyPlanContractFullAllOf
   */
  meterTypes?: Array<string>;
  /**
   * Number of days in the cooling off period for the contract.  Mandatory for plans with type of MARKET
   * @type {number}
   * @memberof EnergyPlanContractFullAllOf
   */
  coolingOffDays?: number;
  /**
   * An array of the available billing schedules for this contract. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {Array<string>}
   * @memberof EnergyPlanContractFullAllOf
   */
  billFrequency: Array<string>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractFullAllOfTermTypeEnum {
  _1YEAR = '1_YEAR',
  _2YEAR = '2_YEAR',
  _3YEAR = '3_YEAR',
  _4YEAR = '4_YEAR',
  _5YEAR = '5_YEAR',
  ONGOING = 'ONGOING',
  OTHER = 'OTHER',
}

/**
 *
 * @export
 * @interface EnergyPlanContractGreenPowerCharges
 */
export interface EnergyPlanContractGreenPowerCharges {
  /**
   * The display name of the charge
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerCharges
   */
  displayName: string;
  /**
   * The description of the charge
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerCharges
   */
  description?: string;
  /**
   * The applicable green power scheme
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerCharges
   */
  scheme: EnergyPlanContractGreenPowerChargesSchemeEnum;
  /**
   * The type of charge
   * @type {string}
   * @memberof EnergyPlanContractGreenPowerCharges
   */
  type: EnergyPlanContractGreenPowerChargesTypeEnum;
  /**
   * Array of charge tiers based on the percentage of green power used for the period implied by the type.  Array is in order of increasing percentage of green power
   * @type {Array<EnergyPlanContractTiers>}
   * @memberof EnergyPlanContractGreenPowerCharges
   */
  tiers: Array<EnergyPlanContractTiers>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractGreenPowerChargesSchemeEnum {
  GREENPOWER = 'GREENPOWER',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractGreenPowerChargesTypeEnum {
  FIXEDPERDAY = 'FIXED_PER_DAY',
  FIXEDPERWEEK = 'FIXED_PER_WEEK',
  FIXEDPERMONTH = 'FIXED_PER_MONTH',
  FIXEDPERUNIT = 'FIXED_PER_UNIT',
  PERCENTOFUSE = 'PERCENT_OF_USE',
  PERCENTOFBILL = 'PERCENT_OF_BILL',
}

/**
 *
 * @export
 * @interface EnergyPlanContractIncentives
 */
export interface EnergyPlanContractIncentives {
  /**
   * The display name of the incentive
   * @type {string}
   * @memberof EnergyPlanContractIncentives
   */
  displayName: string;
  /**
   * The description of the incentive
   * @type {string}
   * @memberof EnergyPlanContractIncentives
   */
  description: string;
  /**
   * The type of the incentive
   * @type {string}
   * @memberof EnergyPlanContractIncentives
   */
  category: EnergyPlanContractIncentivesCategoryEnum;
  /**
   * A display message outlining an eligibility criteria that may apply
   * @type {string}
   * @memberof EnergyPlanContractIncentives
   */
  eligibility?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractIncentivesCategoryEnum {
  GIFT = 'GIFT',
  ACCOUNTCREDIT = 'ACCOUNT_CREDIT',
  OTHER = 'OTHER',
}

/**
 * Describes intrinsic green power for the plan.  If present then the plan includes a percentage of green power in the base plan. Should not be present for gas contracts
 * @export
 * @interface EnergyPlanContractIntrinsicGreenPower
 */
export interface EnergyPlanContractIntrinsicGreenPower {
  /**
   * Percentage of green power intrinsically included in the plan
   * @type {string}
   * @memberof EnergyPlanContractIntrinsicGreenPower
   */
  greenPercentage: string;
}
/**
 * Required if methodUType is percentOfBill
 * @export
 * @interface EnergyPlanContractPercentOfBill
 */
export interface EnergyPlanContractPercentOfBill {
  /**
   * The rate of the discount applied to the bill amount
   * @type {string}
   * @memberof EnergyPlanContractPercentOfBill
   */
  rate: string;
}
/**
 * Required if methodUType is percentOfUse
 * @export
 * @interface EnergyPlanContractPercentOfUse
 */
export interface EnergyPlanContractPercentOfUse {
  /**
   * The rate of the discount applied to the usageamount
   * @type {string}
   * @memberof EnergyPlanContractPercentOfUse
   */
  rate: string;
}
/**
 * Required if methodUType is percentOverThreshold
 * @export
 * @interface EnergyPlanContractPercentOverThreshold
 */
export interface EnergyPlanContractPercentOverThreshold {
  /**
   * The rate of the discount over the usage amount
   * @type {string}
   * @memberof EnergyPlanContractPercentOverThreshold
   */
  rate: string;
  /**
   * The usage amount threshold above which the discount applies
   * @type {string}
   * @memberof EnergyPlanContractPercentOverThreshold
   */
  usageAmount: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractRates
 */
export interface EnergyPlanContractRates {
  /**
   * Unit price of usage per  measure unit (exclusive of GST)
   * @type {string}
   * @memberof EnergyPlanContractRates
   */
  unitPrice: string;
  /**
   * The measurement unit of rate. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyPlanContractRates
   */
  measureUnit?: EnergyPlanContractRatesMeasureUnitEnum;
  /**
   * Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
   * @type {number}
   * @memberof EnergyPlanContractRates
   */
  volume?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractRatesMeasureUnitEnum {
  KWH = 'KWH',
  KVA = 'KVA',
  KVAR = 'KVAR',
  KVARH = 'KVARH',
  KW = 'KW',
  DAYS = 'DAYS',
  METER = 'METER',
  MONTH = 'MONTH',
}

/**
 * Object representing a single rate.  Required if rateBlockUType is singleRate
 * @export
 * @interface EnergyPlanContractSingleRate
 */
export interface EnergyPlanContractSingleRate {
  /**
   * Display name of the rate
   * @type {string}
   * @memberof EnergyPlanContractSingleRate
   */
  displayName: string;
  /**
   * Description of the rate
   * @type {string}
   * @memberof EnergyPlanContractSingleRate
   */
  description?: string;
  /**
   * The block rate (unit price) for any usage above the included fixed usage, in dollars per kWh inclusive of GST.  Only required if pricingModel field is QUOTA
   * @type {string}
   * @memberof EnergyPlanContractSingleRate
   */
  generalUnitPrice?: string;
  /**
   * Array of controlled load rates in order of usage volume
   * @type {Array<EnergyPlanContractSingleRateRates>}
   * @memberof EnergyPlanContractSingleRate
   */
  rates: Array<EnergyPlanContractSingleRateRates>;
  /**
   * Usage period for which the block rate applies. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPlanContractSingleRate
   */
  period?: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractSingleRateRates
 */
export interface EnergyPlanContractSingleRateRates {
  /**
   * Unit price of usage per measure unit (exclusive of GST)
   * @type {string}
   * @memberof EnergyPlanContractSingleRateRates
   */
  unitPrice: string;
  /**
   * The measurement unit of rate. Assumed to be KWH if absent
   * @type {string}
   * @memberof EnergyPlanContractSingleRateRates
   */
  measureUnit?: EnergyPlanContractSingleRateRatesMeasureUnitEnum;
  /**
   * Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
   * @type {number}
   * @memberof EnergyPlanContractSingleRateRates
   */
  volume?: number;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractSingleRateRatesMeasureUnitEnum {
  KWH = 'KWH',
  KVA = 'KVA',
  KVAR = 'KVAR',
  KVARH = 'KVARH',
  KW = 'KW',
  DAYS = 'DAYS',
  METER = 'METER',
  MONTH = 'MONTH',
}

/**
 * Represents a constant tariff.  Mandatory if tariffUType is set to singleTariff
 * @export
 * @interface EnergyPlanContractSingleTariff
 */
export interface EnergyPlanContractSingleTariff {
  /**
   * The tariff amount
   * @type {string}
   * @memberof EnergyPlanContractSingleTariff
   */
  amount: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractSolarFeedInTariff
 */
export interface EnergyPlanContractSolarFeedInTariff {
  /**
   * The name of the tariff
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariff
   */
  displayName: string;
  /**
   * A description of the tariff
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariff
   */
  description?: string;
  /**
   * The applicable scheme
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariff
   */
  scheme: EnergyPlanContractSolarFeedInTariffSchemeEnum;
  /**
   * The type of the payer
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariff
   */
  payerType: EnergyPlanContractSolarFeedInTariffPayerTypeEnum;
  /**
   * The type of the payer
   * @type {string}
   * @memberof EnergyPlanContractSolarFeedInTariff
   */
  tariffUType: EnergyPlanContractSolarFeedInTariffTariffUTypeEnum;
  /**
   *
   * @type {EnergyPlanContractSingleTariff}
   * @memberof EnergyPlanContractSolarFeedInTariff
   */
  singleTariff?: EnergyPlanContractSingleTariff;
  /**
   *
   * @type {EnergyPlanContractTimeVaryingTariffs}
   * @memberof EnergyPlanContractSolarFeedInTariff
   */
  timeVaryingTariffs?: EnergyPlanContractTimeVaryingTariffs;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractSolarFeedInTariffSchemeEnum {
  PREMIUM = 'PREMIUM',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractSolarFeedInTariffPayerTypeEnum {
  GOVERNMENT = 'GOVERNMENT',
  RETAILER = 'RETAILER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractSolarFeedInTariffTariffUTypeEnum {
  SingleTariff = 'singleTariff',
  TimeVaryingTariffs = 'timeVaryingTariffs',
}

/**
 *
 * @export
 * @interface EnergyPlanContractTariffPeriod
 */
export interface EnergyPlanContractTariffPeriod {
  /**
   * Type of charge. Assumed to be other if absent
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriod
   */
  type?: EnergyPlanContractTariffPeriodTypeEnum;
  /**
   * The name of the tariff period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriod
   */
  displayName: string;
  /**
   * The start date of the tariff period in a calendar year.  Formatted in mm-dd format
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriod
   */
  startDate: string;
  /**
   * The end date of the tariff period in a calendar year.  Formatted in mm-dd format
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriod
   */
  endDate: string;
  /**
   * The amount of access charge for the tariff period, in dollars per day exclusive of GST.
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriod
   */
  dailySupplyCharges?: string;
  /**
   * Specifies the type of rate applicable to this tariff period
   * @type {string}
   * @memberof EnergyPlanContractTariffPeriod
   */
  rateBlockUType: EnergyPlanContractTariffPeriodRateBlockUTypeEnum;
  /**
   *
   * @type {EnergyPlanContractSingleRate}
   * @memberof EnergyPlanContractTariffPeriod
   */
  singleRate?: EnergyPlanContractSingleRate;
  /**
   * Array of objects representing time of use rates.  Required if rateBlockUType is timeOfUseRates
   * @type {Array<EnergyPlanContractTimeOfUseRates>}
   * @memberof EnergyPlanContractTariffPeriod
   */
  timeOfUseRates?: Array<EnergyPlanContractTimeOfUseRates>;
  /**
   * Array of demand charges.  Required if rateBlockUType is demandCharges
   * @type {Array<EnergyPlanContractDemandCharges>}
   * @memberof EnergyPlanContractTariffPeriod
   */
  demandCharges?: Array<EnergyPlanContractDemandCharges>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractTariffPeriodTypeEnum {
  ENVIRONMENTAL = 'ENVIRONMENTAL',
  REGULATED = 'REGULATED',
  NETWORK = 'NETWORK',
  METERING = 'METERING',
  RETAILSERVICE = 'RETAIL_SERVICE',
  RCTI = 'RCTI',
  OTHER = 'OTHER',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractTariffPeriodRateBlockUTypeEnum {
  SingleRate = 'singleRate',
  TimeOfUseRates = 'timeOfUseRates',
  DemandCharges = 'demandCharges',
}

/**
 *
 * @export
 * @interface EnergyPlanContractTiers
 */
export interface EnergyPlanContractTiers {
  /**
   * The upper percentage of green power used applicable for this tier
   * @type {string}
   * @memberof EnergyPlanContractTiers
   */
  percentGreen: string;
  /**
   * The rate of the charge if the type implies the application of a rate
   * @type {string}
   * @memberof EnergyPlanContractTiers
   */
  rate?: string;
  /**
   * The amount of the charge if the type implies the application of a fixed amount
   * @type {string}
   * @memberof EnergyPlanContractTiers
   */
  amount?: string;
}
/**
 *
 * @export
 * @interface EnergyPlanContractTimeOfUse
 */
export interface EnergyPlanContractTimeOfUse {
  /**
   * The days that the rate applies to
   * @type {Array<string>}
   * @memberof EnergyPlanContractTimeOfUse
   */
  days: Array<EnergyPlanContractTimeOfUseDaysEnum>;
  /**
   * Start of the period in HHMM format using 24 hour clock format
   * @type {string}
   * @memberof EnergyPlanContractTimeOfUse
   */
  startTime: string;
  /**
   * End of the period in HHMM format using 24 hour clock format
   * @type {string}
   * @memberof EnergyPlanContractTimeOfUse
   */
  endTime: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractTimeOfUseDaysEnum {
  SUNDAY = 'SUNDAY',
  MONDAY = 'MONDAY',
  TUESDAY = 'TUESDAY',
  WEDNESDAY = 'WEDNESDAY',
  THURSDAY = 'THURSDAY',
  FRIDAY = 'FRIDAY',
  SATURDAY = 'SATURDAY',
  BUSINESSDAYS = 'BUSINESS_DAYS',
}

/**
 *
 * @export
 * @interface EnergyPlanContractTimeOfUseRates
 */
export interface EnergyPlanContractTimeOfUseRates {
  /**
   * Display name of the rate
   * @type {string}
   * @memberof EnergyPlanContractTimeOfUseRates
   */
  displayName: string;
  /**
   * Description of the rate
   * @type {string}
   * @memberof EnergyPlanContractTimeOfUseRates
   */
  description?: string;
  /**
   * Array of controlled load rates in order of usage volume
   * @type {Array<EnergyPlanContractRates>}
   * @memberof EnergyPlanContractTimeOfUseRates
   */
  rates: Array<EnergyPlanContractRates>;
  /**
   * Array of times of use
   * @type {Array<EnergyPlanContractTimeOfUse>}
   * @memberof EnergyPlanContractTimeOfUseRates
   */
  timeOfUse: Array<EnergyPlanContractTimeOfUse>;
  /**
   * The type of usage that the rate applies to
   * @type {string}
   * @memberof EnergyPlanContractTimeOfUseRates
   */
  type: EnergyPlanContractTimeOfUseRatesTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractTimeOfUseRatesTypeEnum {
  PEAK = 'PEAK',
  OFFPEAK = 'OFF_PEAK',
  SHOULDER = 'SHOULDER',
  SHOULDER1 = 'SHOULDER1',
  SHOULDER2 = 'SHOULDER2',
}

/**
 * Represents a tariff based on time.  Mandatory if tariffUType is set to timeVaryingTariffs
 * @export
 * @interface EnergyPlanContractTimeVaryingTariffs
 */
export interface EnergyPlanContractTimeVaryingTariffs {
  /**
   * The type of the charging time period. If absent applies to all periods
   * @type {string}
   * @memberof EnergyPlanContractTimeVaryingTariffs
   */
  type?: EnergyPlanContractTimeVaryingTariffsTypeEnum;
  /**
   * The tariff amount
   * @type {string}
   * @memberof EnergyPlanContractTimeVaryingTariffs
   */
  amount: string;
  /**
   * Array of time periods for which this tariff is applicable
   * @type {Array<EnergyPlanContractTimeVaryingTariffsTimeVariations>}
   * @memberof EnergyPlanContractTimeVaryingTariffs
   */
  timeVariations: Array<EnergyPlanContractTimeVaryingTariffsTimeVariations>;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanContractTimeVaryingTariffsTypeEnum {
  PEAK = 'PEAK',
  OFFPEAK = 'OFF_PEAK',
  SHOULDER = 'SHOULDER',
}

/**
 *
 * @export
 * @interface EnergyPlanContractTimeVaryingTariffsDays
 */
export interface EnergyPlanContractTimeVaryingTariffsDays {
  /**
   * Indicates whether the tariff is applicable Monday to Friday
   * @type {boolean}
   * @memberof EnergyPlanContractTimeVaryingTariffsDays
   */
  weekdays: boolean;
  /**
   * Indicates whether the tariff is applicable Saturday and Sunday
   * @type {boolean}
   * @memberof EnergyPlanContractTimeVaryingTariffsDays
   */
  weekend: boolean;
}
/**
 *
 * @export
 * @interface EnergyPlanContractTimeVaryingTariffsTimeVariations
 */
export interface EnergyPlanContractTimeVaryingTariffsTimeVariations {
  /**
   *
   * @type {EnergyPlanContractTimeVaryingTariffsDays}
   * @memberof EnergyPlanContractTimeVaryingTariffsTimeVariations
   */
  days?: EnergyPlanContractTimeVaryingTariffsDays;
  /**
   * The beginning of the time period per day for which the tariff applies.  If absent assumes start of day (i.e. midnight)
   * @type {string}
   * @memberof EnergyPlanContractTimeVaryingTariffsTimeVariations
   */
  startTime?: string;
  /**
   * The end of the time period per day for which the tariff applies.  If absent assumes end of day (i.e. one second before midnight)
   * @type {string}
   * @memberof EnergyPlanContractTimeVaryingTariffsTimeVariations
   */
  endTime?: string;
}
/**
 * Required if pricing model is SINGLE_RATE_CONT_LOAD or TIME_OF_USE_CONT_LOAD or FLEXIBLE_CONT_LOAD
 * @export
 * @interface EnergyPlanControlledLoad
 */
export interface EnergyPlanControlledLoad {
  /**
   * A display name for the controlled load tier
   * @type {string}
   * @memberof EnergyPlanControlledLoad
   */
  displayName: string;
  /**
   * A description of the controlled load tier
   * @type {string}
   * @memberof EnergyPlanControlledLoad
   */
  description?: string;
  /**
   * The daily supply charge (exclusive of GST) for this controlled load tier
   * @type {string}
   * @memberof EnergyPlanControlledLoad
   */
  dailyCharge: string;
  /**
   * The period for which the controlled load rate applies. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPlanControlledLoad
   */
  period: string;
  /**
   * Array of controlled load rates in order of usage volume
   * @type {Array<EnergyPlanControlledLoadRates>}
   * @memberof EnergyPlanControlledLoad
   */
  rates: Array<EnergyPlanControlledLoadRates>;
}
/**
 *
 * @export
 * @interface EnergyPlanControlledLoadRates
 */
export interface EnergyPlanControlledLoadRates {
  /**
   * Unit price of usage per kWh (exclusive of GST)
   * @type {string}
   * @memberof EnergyPlanControlledLoadRates
   */
  unitPrice: string;
  /**
   * Volume in kWh that this rate applies to.  Only applicable for stepped rates where different rates apply for different volumes of usage in a period
   * @type {number}
   * @memberof EnergyPlanControlledLoadRates
   */
  volume?: number;
}
/**
 *
 * @export
 * @interface EnergyPlanDetail
 */
export interface EnergyPlanDetail {
  /**
   * The ID of the specific plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  planId: string;
  /**
   * The date and time from which this plan is effective (i.e. is available for origination). Used to enable the articulation of products to the regime before they are available for customers to originate
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  effectiveFrom?: string;
  /**
   * The date and time at which this plan will be retired and will no longer be offered. Used to enable the managed deprecation of plans
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  effectiveTo?: string;
  /**
   * The last date and time that the information for this plan was changed (or the creation date for the plan if it has never been altered)
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  lastUpdated: string;
  /**
   * The display name of the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  displayName?: string;
  /**
   * A description of the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  description?: string;
  /**
   * The type of the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  type: EnergyPlanDetailTypeEnum;
  /**
   * The fuel types covered by the plan
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  fuelType: EnergyPlanDetailFuelTypeEnum;
  /**
   * The ID of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  brand: string;
  /**
   * The display name of the brand under which this plan is offered
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  brandName: string;
  /**
   * A link to an application web page where this plan can be applied for
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  applicationUri?: string;
  /**
   *
   * @type {EnergyPlanAdditionalInformation}
   * @memberof EnergyPlanDetail
   */
  additionalInformation?: EnergyPlanAdditionalInformation;
  /**
   * The type of customer that the plan is offered to.  If absent then the plan is available to all customers
   * @type {string}
   * @memberof EnergyPlanDetail
   */
  customerType?: EnergyPlanDetailCustomerTypeEnum;
  /**
   *
   * @type {EnergyPlanGeography}
   * @memberof EnergyPlanDetail
   */
  geography?: EnergyPlanGeography;
  /**
   * Charges for metering included in the plan
   * @type {Array<EnergyPlanDetailAllOfMeteringCharges>}
   * @memberof EnergyPlanDetail
   */
  meteringCharges?: Array<EnergyPlanDetailAllOfMeteringCharges>;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetail
   */
  gasContract?: EnergyPlanContractFull;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetail
   */
  electricityContract?: EnergyPlanContractFull;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanDetailTypeEnum {
  STANDING = 'STANDING',
  MARKET = 'MARKET',
  REGULATED = 'REGULATED',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanDetailFuelTypeEnum {
  ELECTRICITY = 'ELECTRICITY',
  GAS = 'GAS',
  DUAL = 'DUAL',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyPlanDetailCustomerTypeEnum {
  RESIDENTIAL = 'RESIDENTIAL',
  BUSINESS = 'BUSINESS',
}

/**
 *
 * @export
 * @interface EnergyPlanDetailAllOf
 */
export interface EnergyPlanDetailAllOf {
  /**
   * Charges for metering included in the plan
   * @type {Array<EnergyPlanDetailAllOfMeteringCharges>}
   * @memberof EnergyPlanDetailAllOf
   */
  meteringCharges?: Array<EnergyPlanDetailAllOfMeteringCharges>;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetailAllOf
   */
  gasContract?: EnergyPlanContractFull;
  /**
   *
   * @type {EnergyPlanContractFull}
   * @memberof EnergyPlanDetailAllOf
   */
  electricityContract?: EnergyPlanContractFull;
}
/**
 *
 * @export
 * @interface EnergyPlanDetailAllOfMeteringCharges
 */
export interface EnergyPlanDetailAllOfMeteringCharges {
  /**
   * Display name of the charge
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  displayName: string;
  /**
   * Description of the charge
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  description?: string;
  /**
   * Minimum value of the charge if the charge is a range or the absolute value of the charge if no range is specified
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  minimumValue: string;
  /**
   * The upper limit of the charge if the charge could occur in a range
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  maximumValue?: string;
  /**
   * The charges that occur on a schedule indicates the frequency. Formatted according to [ISO 8601 Durations](https://en.wikipedia.org/wiki/ISO_8601#Durations) (excludes recurrence syntax)
   * @type {string}
   * @memberof EnergyPlanDetailAllOfMeteringCharges
   */
  period?: string;
}
/**
 * Describes the geographical area that the plan is available for.  If absent then it is assumed the plan is not geographically limited
 * @export
 * @interface EnergyPlanGeography
 */
export interface EnergyPlanGeography {
  /**
   * Array of valid Australian post codes that are specifically excluded from the plan.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
   * @type {Array<string>}
   * @memberof EnergyPlanGeography
   */
  excludedPostcodes?: Array<string>;
  /**
   * Array of valid Australian post codes that are included from the plan.  If absent defaults to all non-excluded post codes.  Each element is a single four digit postcode (e.g. 3000) or a range of postcodes defined by two four digit postcodes and a hyphen (e.g. 3000-3999)
   * @type {Array<string>}
   * @memberof EnergyPlanGeography
   */
  includedPostcodes?: Array<string>;
}
/**
 *
 * @export
 * @interface EnergyPlanList
 */
export interface EnergyPlanList {
  /**
   *
   * @type {EnergyPlanListData}
   * @memberof EnergyPlanList
   */
  data: EnergyPlanListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyPlanList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyPlanList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyPlanListData
 */
export interface EnergyPlanListData {
  /**
   * Array of plans
   * @type {Array<EnergyPlanDetail>}
   * @memberof EnergyPlanListData
   */
  plans: Array<EnergyPlanDetail>;
}
/**
 *
 * @export
 * @interface EnergyServicePointConsumerProfile
 */
export interface EnergyServicePointConsumerProfile {
  /**
   * A code that defines the consumer class as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments
   * @type {string}
   * @memberof EnergyServicePointConsumerProfile
   */
  classification?: EnergyServicePointConsumerProfileClassificationEnum;
  /**
   * A code that defines the consumption threshold as defined in the National Energy Retail Regulations, or in overriding Jurisdictional instruments. Note the details of enumeration values below: <ul><li>**LOW** - Consumption is less than the lower consumption threshold as defined in the National Energy Retail Regulations</li><li>**MEDIUM** - Consumption is equal to or greater than the lower consumption threshold, but less than the upper consumption threshold, as defined in the National Energy Retail Regulations</li><li>**HIGH** - Consumption is equal to or greater than the upper consumption threshold as defined in the National Energy Retail Regulations</li></ul>
   * @type {string}
   * @memberof EnergyServicePointConsumerProfile
   */
  threshold?: EnergyServicePointConsumerProfileThresholdEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointConsumerProfileClassificationEnum {
  BUSINESS = 'BUSINESS',
  RESIDENTIAL = 'RESIDENTIAL',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointConsumerProfileThresholdEnum {
  LOW = 'LOW',
  MEDIUM = 'MEDIUM',
  HIGH = 'HIGH',
}

/**
 *
 * @export
 * @interface EnergyServicePointDetail
 */
export interface EnergyServicePointDetail {
  /**
   * The tokenised ID of the service point for use in the CDR APIs.  Created according to the CDR rules for ID permanence
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  servicePointId: string;
  /**
   * The independent ID of the service point, known in the industry as the NMI
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  nationalMeteringId: string;
  /**
   * The classification of the service point as defined in MSATS procedures
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  servicePointClassification: EnergyServicePointDetailServicePointClassificationEnum;
  /**
   * Code used to indicate the status of the service point. Note the details for the enumeration values below:<ul><li>**ACTIVE** - An active, energised, service point</li><li>**DE_ENERGISED** - The service point exists but is deenergised</li><li>**EXTINCT** - The service point has been permanently decommissioned</li><li>**GREENFIELD** - Applies to a service point that has never been energised</li><li>**OFF_MARKET** - Applies when the service point is no longer settled in the NEM</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  servicePointStatus: EnergyServicePointDetailServicePointStatusEnum;
  /**
   * Jurisdiction code to which the service point belongs.This code defines the jurisdictional rules which apply to the service point. Note the details of enumeration values below:<ul><li>**ALL** - All Jurisdictions</li><li>**ACT** - Australian Capital Territory</li><li>**NEM** - National Electricity Market</li><li>**NSW** - New South Wales</li><li>**QLD** - Queensland</li><li>**SA** - South Australia</li><li>**TAS** - Tasmania</li><li>**VIC** - Victoria</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  jurisdictionCode: EnergyServicePointDetailJurisdictionCodeEnum;
  /**
   * This flag determines whether the energy at this connection point is to be treated as consumer load or as a generating unit(this may include generator auxiliary loads). If absent defaults to false. <br>**Note:** Only applicable for scheduled or semischeduled generators, does not indicate on site generation by consumer
   * @type {boolean}
   * @memberof EnergyServicePointDetail
   */
  isGenerator?: boolean;
  /**
   * The start date from which this service point first became valid
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  validFromDate: string;
  /**
   * The date and time that the information for this service point was modified
   * @type {string}
   * @memberof EnergyServicePointDetail
   */
  lastUpdateDateTime: string;
  /**
   *
   * @type {EnergyServicePointConsumerProfile}
   * @memberof EnergyServicePointDetail
   */
  consumerProfile?: EnergyServicePointConsumerProfile;
  /**
   *
   * @type {EnergyServicePointDetailDistributionLossFactor}
   * @memberof EnergyServicePointDetail
   */
  distributionLossFactor: EnergyServicePointDetailDistributionLossFactor;
  /**
   *
   * @type {Array<EnergyServicePointDetailRelatedParticipants>}
   * @memberof EnergyServicePointDetail
   */
  relatedParticipants: Array<EnergyServicePointDetailRelatedParticipants>;
  /**
   *
   * @type {EnergyServicePointDetailLocation}
   * @memberof EnergyServicePointDetail
   */
  location: EnergyServicePointDetailLocation;
  /**
   *
   * @type {EnergyServicePointDetailMeters}
   * @memberof EnergyServicePointDetail
   */
  meters: EnergyServicePointDetailMeters;
  /**
   *
   * @type {EnergyDerRecord}
   * @memberof EnergyServicePointDetail
   */
  der?: EnergyDerRecord;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyServicePointDetail
   */
  adatree?: Adatree;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailServicePointClassificationEnum {
  EXTERNALPROFILE = 'EXTERNAL_PROFILE',
  GENERATOR = 'GENERATOR',
  LARGE = 'LARGE',
  SMALL = 'SMALL',
  WHOLESALE = 'WHOLESALE',
  NONCONTESTUNMETEREDLOAD = 'NON_CONTEST_UNMETERED_LOAD',
  NONREGISTEREDEMBEDDEDGENERATOR = 'NON_REGISTERED_EMBEDDED_GENERATOR',
  DISTRIBUTIONWHOLESALE = 'DISTRIBUTION_WHOLESALE',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailServicePointStatusEnum {
  ACTIVE = 'ACTIVE',
  DEENERGISED = 'DE_ENERGISED',
  EXTINCT = 'EXTINCT',
  GREENFIELD = 'GREENFIELD',
  OFFMARKET = 'OFF_MARKET',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailJurisdictionCodeEnum {
  ALL = 'ALL',
  ACT = 'ACT',
  NEM = 'NEM',
  NSW = 'NSW',
  QLD = 'QLD',
  SA = 'SA',
  TAS = 'TAS',
  VIC = 'VIC',
}

/**
 *
 * @export
 * @interface EnergyServicePointDetailDistributionLossFactor
 */
export interface EnergyServicePointDetailDistributionLossFactor {
  /**
   * A code used to identify data loss factor for the service point values.  Refer to AEMO distribution loss factor documents for each financial year to interpret
   * @type {string}
   * @memberof EnergyServicePointDetailDistributionLossFactor
   */
  code: string;
  /**
   * Description of the data loss factor code and value
   * @type {string}
   * @memberof EnergyServicePointDetailDistributionLossFactor
   */
  description: string;
  /**
   * The value associated with the loss factor code
   * @type {string}
   * @memberof EnergyServicePointDetailDistributionLossFactor
   */
  lossValue: string;
}
/**
 *
 * @export
 * @interface EnergyServicePointDetailLocation
 */
export interface EnergyServicePointDetailLocation {
  /**
   * The type of address object present
   * @type {string}
   * @memberof EnergyServicePointDetailLocation
   */
  addressUType: EnergyServicePointDetailLocationAddressUTypeEnum;
  /**
   *
   * @type {EnergyServicePointDetailLocationSimple}
   * @memberof EnergyServicePointDetailLocation
   */
  simple?: EnergyServicePointDetailLocationSimple;
  /**
   *
   * @type {EnergyServicePointDetailLocationPaf}
   * @memberof EnergyServicePointDetailLocation
   */
  paf?: EnergyServicePointDetailLocationPaf;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailLocationAddressUTypeEnum {
  Simple = 'simple',
  Paf = 'paf',
}

/**
 * The address of the service point.  Mandatory if addressUType is set to paf. Formatted according to the file format defined by the [PAF file format](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf)
 * @export
 * @interface EnergyServicePointDetailLocationPaf
 */
export interface EnergyServicePointDetailLocationPaf {
  /**
   * Unique identifier for an address as defined by Australia Post.  Also known as Delivery Point Identifier
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  dpid?: string;
  /**
   * Thoroughfare number for a property (first number in a property ranged address)
   * @type {number}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  thoroughfareNumber1?: number;
  /**
   * Suffix for the thoroughfare number. Only relevant is thoroughfareNumber1 is populated
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  thoroughfareNumber1Suffix?: string;
  /**
   * Second thoroughfare number (only used if the property has a ranged address eg 23-25)
   * @type {number}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  thoroughfareNumber2?: number;
  /**
   * Suffix for the second thoroughfare number. Only relevant is thoroughfareNumber2 is populated
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  thoroughfareNumber2Suffix?: string;
  /**
   * Type of flat or unit for the address
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  flatUnitType?: string;
  /**
   * Unit number (including suffix, if applicable)
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  flatUnitNumber?: string;
  /**
   * Type of floor or level for the address
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  floorLevelType?: string;
  /**
   * Floor or level number (including alpha characters)
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  floorLevelNumber?: string;
  /**
   * Allotment number for the address
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  lotNumber?: string;
  /**
   * Building/Property name 1
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  buildingName1?: string;
  /**
   * Building/Property name 2
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  buildingName2?: string;
  /**
   * The name of the street
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  streetName?: string;
  /**
   * The street type. Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  streetType?: string;
  /**
   * The street type suffix. Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  streetSuffix?: string;
  /**
   * Postal delivery type. (eg. PO BOX). Valid enumeration defined by Australia Post PAF code file
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  postalDeliveryType?: string;
  /**
   * Postal delivery number if the address is a postal delivery type
   * @type {number}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  postalDeliveryNumber?: number;
  /**
   * Postal delivery number prefix related to the postal delivery number
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  postalDeliveryNumberPrefix?: string;
  /**
   * Postal delivery number suffix related to the postal delivery number
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  postalDeliveryNumberSuffix?: string;
  /**
   * Full name of locality
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  localityName: string;
  /**
   * Postcode for the locality
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  postcode: string;
  /**
   * State in which the address belongs. Valid enumeration defined by Australia Post PAF code file [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf). NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
   * @type {string}
   * @memberof EnergyServicePointDetailLocationPaf
   */
  state: string;
}
/**
 * The address of the service point.  Mandatory if addressUType is set to simple
 * @export
 * @interface EnergyServicePointDetailLocationSimple
 */
export interface EnergyServicePointDetailLocationSimple {
  /**
   * Name of the individual or business formatted for inclusion in an address used for physical mail
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  mailingName?: string;
  /**
   * First line of the standard address object
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  addressLine1: string;
  /**
   * Second line of the standard address object
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  addressLine2?: string;
  /**
   * Third line of the standard address object
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  addressLine3?: string;
  /**
   * Mandatory for Australian addresses
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  postcode?: string;
  /**
   * Name of the city or locality
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  city: string;
  /**
   * Free text if the country is not Australia. If country is Australia then must be one of the values defined by the [State Type Abbreviation](https://auspost.com.au/content/dam/auspost_corp/media/documents/australia-post-data-guide.pdf) in the PAF file format. NSW, QLD, VIC, NT, WA, SA, TAS, ACT, AAT
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  state: string;
  /**
   * A valid [ISO 3166 Alpha-3](https://www.iso.org/iso-3166-country-codes.html) country code. Australia (AUS) is assumed if country is not present.
   * @type {string}
   * @memberof EnergyServicePointDetailLocationSimple
   */
  country?: string;
}
/**
 *
 * @export
 * @interface EnergyServicePointDetailMeters
 */
export interface EnergyServicePointDetailMeters {
  /**
   * The meter ID uniquely identifies a meter for a given service point.  It is unique in the context of the service point.  It is not globally unique
   * @type {string}
   * @memberof EnergyServicePointDetailMeters
   */
  meterId: string;
  /**
   *
   * @type {EnergyServicePointDetailMetersSpecifications}
   * @memberof EnergyServicePointDetailMeters
   */
  specifications: EnergyServicePointDetailMetersSpecifications;
  /**
   *
   * @type {EnergyServicePointDetailMetersRegisters}
   * @memberof EnergyServicePointDetailMeters
   */
  registers: EnergyServicePointDetailMetersRegisters;
}
/**
 * Usage data registers available from the meter
 * @export
 * @interface EnergyServicePointDetailMetersRegisters
 */
export interface EnergyServicePointDetailMetersRegisters {
  /**
   * Unique identifier of the register within this service point.  Is not globally unique
   * @type {string}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  registerId: string;
  /**
   * Register suffix of the meter register where the meter reads are obtained
   * @type {string}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  registerSuffix: string;
  /**
   * The energy delivered through a connection point or metering point over an extended period normalised to a \'per day\' basis (kWh). This value is calculated annually.
   * @type {number}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  averagedDailyLoad?: number;
  /**
   * Indicates the consumption type of register
   * @type {string}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  registerConsumptionType: EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeEnum;
  /**
   * The Network Tariff Code is a free text field containing a code supplied and published by the local network service provider
   * @type {string}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  networkTariffCode?: string;
  /**
   * The unit of measure for data held in this register
   * @type {string}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  unitOfMeasure?: string;
  /**
   * Code to identify the time validity of register contents
   * @type {string}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  timeOfDay?: EnergyServicePointDetailMetersRegistersTimeOfDayEnum;
  /**
   * Multiplier required to take a register value and turn it into a value representing billable energy
   * @type {number}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  multiplier?: number;
  /**
   * Indicates whether the energy recorded by this register is created under a Controlled Load regime
   * @type {boolean}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  controlledLoad?: boolean;
  /**
   * Actual/Subtractive Indicator. Note the details of enumeration values below: <ul><li>**ACTUAL** implies volume of energy actually metered between two dates</li><li>**CUMULATIVE** indicates a meter reading for a specific date. A second Meter Reading is required to determine the consumption between those two Meter Reading dates</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailMetersRegisters
   */
  consumptionType?: EnergyServicePointDetailMetersRegistersConsumptionTypeEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailMetersRegistersRegisterConsumptionTypeEnum {
  INTERVAL = 'INTERVAL',
  BASIC = 'BASIC',
  PROFILEDATA = 'PROFILE_DATA',
  ACTIVEIMPORT = 'ACTIVE_IMPORT',
  ACTIVE = 'ACTIVE',
  REACTIVEIMPORT = 'REACTIVE_IMPORT',
  REACTIVE = 'REACTIVE',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailMetersRegistersTimeOfDayEnum {
  ALLDAY = 'ALLDAY',
  INTERVAL = 'INTERVAL',
  PEAK = 'PEAK',
  BUSINESS = 'BUSINESS',
  SHOULDER = 'SHOULDER',
  EVENING = 'EVENING',
  OFFPEAK = 'OFFPEAK',
  CONTROLLED = 'CONTROLLED',
  DEMAND = 'DEMAND',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailMetersRegistersConsumptionTypeEnum {
  ACTUAL = 'ACTUAL',
  CUMULATIVE = 'CUMULATIVE',
}

/**
 * Technical characteristics of the meter
 * @export
 * @interface EnergyServicePointDetailMetersSpecifications
 */
export interface EnergyServicePointDetailMetersSpecifications {
  /**
   * A code to denote the status of the meter. Note the details of enumeration values below: <ul><li>**CURRENT** -Applies when a meter is current and not disconnected</li><li>**DISCONNECTED** - Applies when a meter is present but has been remotely disconnected</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailMetersSpecifications
   */
  status: EnergyServicePointDetailMetersSpecificationsStatusEnum;
  /**
   * The metering Installation type code indicates whether the metering installation has to be manually read. Note the details of enumeration values below: <ul><li>**BASIC** - Accumulation Meter  Type 6</li><li>**COMMS1** - Interval Meter with communications  Type 1</li><li>**COMMS2** - Interval Meter with communications  Type 2</li><li>**COMMS3** - Interval Meter with communications  Type 3</li><li>**COMMS4** - Interval Meter with communications  Type 4</li><li>**COMMS4C** - CT connected metering installation that meets the minimum services specifications</li><li>**COMMS4D** - Whole current metering installation that meets the minimum services specifications</li><li>**MRAM** - Small customer metering installation  Type 4A</li><li>**MRIM** - Manually Read Interval Meter  Type 5</li><li>**UMCP** - Unmetered Supply  Type 7</li><li>**VICAMI** - A relevant metering installation as defined in clause 9.9C of the NER</li><li>**NCONUML** - Non-contestable unmeter load - Introduced as part of Global Settlement</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailMetersSpecifications
   */
  installationType: EnergyServicePointDetailMetersSpecificationsInstallationTypeEnum;
  /**
   * Free text field to identify the manufacturer of the installed meter
   * @type {string}
   * @memberof EnergyServicePointDetailMetersSpecifications
   */
  manufacturer?: string;
  /**
   * Free text field to identify the meter manufacturers designation for the meter model
   * @type {string}
   * @memberof EnergyServicePointDetailMetersSpecifications
   */
  model?: string;
  /**
   * Code to denote the method and frequency of Meter Reading. The value is formatted as follows: <ul><li>First Character = Remote (R) or Manual (M)</li><li>Second Character = Mode: T = telephone W = wireless P = powerline I = infra-red G = galvanic V = visual </li><li>Third Character = Frequency of Scheduled Meter Readings: 1 = Twelve times per year 2 = Six times per year 3 = Four times per year D = Daily or weekly</li><li>Optional Fourth Character = to identify what interval length the meter is capable of reading. This includes five, 15 and 30 minute granularity as the following: A  5 minute B  15 minute C  30 minute D  Cannot convert to 5 minute (i.e. due to metering installation de-energised) M - Manually Read Accumulation Meter</li></ul> For example, <ul><li>MV3 = Manual, Visual, Quarterly</li> <li>MV3M = Manual, Visual, Quarterly, Manually Read Accumulation Meter</li> <li>RWDC = Remote, Wireless, Daily, 30 minutes interval</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailMetersSpecifications
   */
  readType?: string;
  /**
   * This date is the next scheduled meter read date (NSRD) if a manual Meter Reading is required
   * @type {string}
   * @memberof EnergyServicePointDetailMetersSpecifications
   */
  nextScheduledReadDate?: string;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailMetersSpecificationsStatusEnum {
  CURRENT = 'CURRENT',
  DISCONNECTED = 'DISCONNECTED',
}
/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailMetersSpecificationsInstallationTypeEnum {
  BASIC = 'BASIC',
  COMMS1 = 'COMMS1',
  COMMS2 = 'COMMS2',
  COMMS3 = 'COMMS3',
  COMMS4 = 'COMMS4',
  COMMS4C = 'COMMS4C',
  COMMS4D = 'COMMS4D',
  MRAM = 'MRAM',
  MRIM = 'MRIM',
  PROF = 'PROF',
  SAMPLE = 'SAMPLE',
  UMCP = 'UMCP',
  VICAMI = 'VICAMI',
  NCOLNUML = 'NCOLNUML',
}

/**
 *
 * @export
 * @interface EnergyServicePointDetailRelatedParticipants
 */
export interface EnergyServicePointDetailRelatedParticipants {
  /**
   * The name of the party/orginsation related to this service point
   * @type {string}
   * @memberof EnergyServicePointDetailRelatedParticipants
   */
  party: string;
  /**
   * The role performed by this participant in relation to the service point. Note the details of enumeration values below: <ul><li>**FRMP** - Financially Responsible Market Participant</li><li>**LNSP** - Local Network Service Provider or Embedded Network Manager for child connection points</li><li>**DRSP** - wholesale Demand Response and/or market ancillary Service Provider and note that where it is not relevant for a NMI it will not be included</li></ul>
   * @type {string}
   * @memberof EnergyServicePointDetailRelatedParticipants
   */
  role: EnergyServicePointDetailRelatedParticipantsRoleEnum;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyServicePointDetailRelatedParticipantsRoleEnum {
  FRMP = 'FRMP',
  LNSP = 'LNSP',
  DRSP = 'DRSP',
}

/**
 *
 * @export
 * @interface EnergyServicePointList
 */
export interface EnergyServicePointList {
  /**
   *
   * @type {EnergyServicePointListData}
   * @memberof EnergyServicePointList
   */
  data: EnergyServicePointListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyServicePointList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyServicePointList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyServicePointListData
 */
export interface EnergyServicePointListData {
  /**
   *
   * @type {Array<EnergyServicePointDetail>}
   * @memberof EnergyServicePointListData
   */
  servicePoints: Array<EnergyServicePointDetail>;
}
/**
 *
 * @export
 * @interface EnergyUsageList
 */
export interface EnergyUsageList {
  /**
   *
   * @type {EnergyUsageListData}
   * @memberof EnergyUsageList
   */
  data: EnergyUsageListData;
  /**
   *
   * @type {LinksPaginated}
   * @memberof EnergyUsageList
   */
  links: LinksPaginated;
  /**
   *
   * @type {MetaPaginated}
   * @memberof EnergyUsageList
   */
  meta: MetaPaginated;
}
/**
 *
 * @export
 * @interface EnergyUsageListData
 */
export interface EnergyUsageListData {
  /**
   * Array of meter reads
   * @type {Array<EnergyUsageRead>}
   * @memberof EnergyUsageListData
   */
  reads: Array<EnergyUsageRead>;
}
/**
 *
 * @export
 * @interface EnergyUsageRead
 */
export interface EnergyUsageRead {
  /**
   * Tokenised ID of the service point to be used for referring to the service point in the CDR API suite.  To be created in accordance with CDR ID permanence requirements
   * @type {string}
   * @memberof EnergyUsageRead
   */
  servicePointId: string;
  /**
   * Register ID of the meter register where the meter reads are obtained
   * @type {string}
   * @memberof EnergyUsageRead
   */
  registerId?: string;
  /**
   * Register suffix of the meter register where the meter reads are obtained
   * @type {string}
   * @memberof EnergyUsageRead
   */
  registerSuffix: string;
  /**
   * Meter id/serial number as it appears in customers bill. ID permanence rules do not apply.
   * @type {string}
   * @memberof EnergyUsageRead
   */
  meterID?: string;
  /**
   * Indicates whether the energy recorded by this register is created under a Controlled Load regime
   * @type {boolean}
   * @memberof EnergyUsageRead
   */
  controlledLoad?: boolean;
  /**
   * Date time when the meter reads start
   * @type {string}
   * @memberof EnergyUsageRead
   */
  readStartDate: string;
  /**
   * Date time when the meter reads end.  If absent then assumed to be equal to readStartDate.  In this case the entry represents data for a single date specified by readStartDate
   * @type {string}
   * @memberof EnergyUsageRead
   */
  readEndDate?: string;
  /**
   * Unit of measure of the meter reads. Refer to Appendix B of <a href=\'https://www.aemo.com.au/-/media/files/stakeholder_consultation/consultations/nem-consultations/2019/5ms-metering-package-2/final-determination/mdff-specification-nem12-nem13-v21-final-determination-clean.pdf?la=en&hash=03FCBA0D60E091DE00F2361AE76206EA\'>MDFF Specification NEM12 NEM13 v2.1</a> for a list of possible values
   * @type {string}
   * @memberof EnergyUsageRead
   */
  unitOfMeasure?: string;
  /**
   * Specify the type of the meter read data
   * @type {string}
   * @memberof EnergyUsageRead
   */
  readUType: EnergyUsageReadReadUTypeEnum;
  /**
   *
   * @type {EnergyUsageReadBasicRead}
   * @memberof EnergyUsageRead
   */
  basicRead?: EnergyUsageReadBasicRead;
  /**
   *
   * @type {EnergyUsageReadIntervalRead}
   * @memberof EnergyUsageRead
   */
  intervalRead?: EnergyUsageReadIntervalRead;
  /**
   *
   * @type {Adatree}
   * @memberof EnergyUsageRead
   */
  adatree: Adatree;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyUsageReadReadUTypeEnum {
  BasicRead = 'basicRead',
  IntervalRead = 'intervalRead',
}

/**
 * Mandatory if readUType is set to basicRead
 * @export
 * @interface EnergyUsageReadBasicRead
 */
export interface EnergyUsageReadBasicRead {
  /**
   * The quality of the read taken.  If absent then assumed to be ACTUAL
   * @type {string}
   * @memberof EnergyUsageReadBasicRead
   */
  quality?: EnergyUsageReadBasicReadQualityEnum;
  /**
   * Meter read value.  If positive then it means consumption, if negative it means export
   * @type {number}
   * @memberof EnergyUsageReadBasicRead
   */
  value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyUsageReadBasicReadQualityEnum {
  ACTUAL = 'ACTUAL',
  SUBSTITUTE = 'SUBSTITUTE',
  FINALSUBSTITUTE = 'FINAL_SUBSTITUTE',
}

/**
 * Mandatory if readUType is set to intervalRead
 * @export
 * @interface EnergyUsageReadIntervalRead
 */
export interface EnergyUsageReadIntervalRead {
  /**
   * Read interval length in minutes
   * @type {number}
   * @memberof EnergyUsageReadIntervalRead
   */
  readIntervalLength: number;
  /**
   * The aggregate sum of the interval read values. If positive then it means net consumption, if negative it means net export
   * @type {number}
   * @memberof EnergyUsageReadIntervalRead
   */
  aggregateValue: number;
  /**
   * Array of reads with each element indicating the read for the interval specified by readIntervalLength beginning at midnight of readStartDate (for example 00:00 to 00:30 would be the first reading in a 30 minute Interval)
   * @type {Array<EnergyUsageReadIntervalReadIntervalReads>}
   * @memberof EnergyUsageReadIntervalRead
   */
  intervalReads: Array<EnergyUsageReadIntervalReadIntervalReads>;
}
/**
 *
 * @export
 * @interface EnergyUsageReadIntervalReadIntervalReads
 */
export interface EnergyUsageReadIntervalReadIntervalReads {
  /**
   * The quality of the read taken.  If absent then assumed to be ACTUAL
   * @type {string}
   * @memberof EnergyUsageReadIntervalReadIntervalReads
   */
  quality?: EnergyUsageReadIntervalReadIntervalReadsQualityEnum;
  /**
   * Interval value.  If positive then it means consumption, if negative it means export
   * @type {number}
   * @memberof EnergyUsageReadIntervalReadIntervalReads
   */
  value: number;
}

/**
 * @export
 * @enum {string}
 */
export enum EnergyUsageReadIntervalReadIntervalReadsQualityEnum {
  ACTUAL = 'ACTUAL',
  SUBSTITUTE = 'SUBSTITUTE',
  FINALSUBSTITUTE = 'FINAL_SUBSTITUTE',
}

/**
 *
 * @export
 * @interface ErrorList
 */
export interface ErrorList {
  /**
   *
   * @type {Array<ErrorListErrors>}
   * @memberof ErrorList
   */
  errors: Array<ErrorListErrors>;
}
/**
 *
 * @export
 * @interface ErrorListErrors
 */
export interface ErrorListErrors {
  /**
   * The code of the error encountered. Where the error is specific to the respondent, an application-specific error code, expressed as a string value. If the error is application-specific, the URN code that the specific error extends must be provided in the meta object. Otherwise, the value is the error code URN.
   * @type {string}
   * @memberof ErrorListErrors
   */
  code: string;
  /**
   * A short, human-readable summary of the problem that MUST NOT change from occurrence to occurrence of the problem represented by the error code.
   * @type {string}
   * @memberof ErrorListErrors
   */
  title: string;
  /**
   * A human-readable explanation specific to this occurrence of the problem.
   * @type {string}
   * @memberof ErrorListErrors
   */
  detail: string;
  /**
   *
   * @type {ErrorListMeta}
   * @memberof ErrorListErrors
   */
  meta?: ErrorListMeta;
}
/**
 * Additional data for customised error codes
 * @export
 * @interface ErrorListMeta
 */
export interface ErrorListMeta {
  /**
   * The CDR error code URN which the application-specific error code extends. Mandatory if the error `code` is an application-specific error rather than a standardised error code.
   * @type {string}
   * @memberof ErrorListMeta
   */
  urn?: string;
}
/**
 *
 * @export
 * @interface LinksPaginated
 */
export interface LinksPaginated {
  /**
   * Fully qualified link that generated the current response document. https://self.example.com.au will be converted to https://self.example.com.au?page=1&page-size=25
   * @type {string}
   * @memberof LinksPaginated
   */
  self: string;
  /**
   * URI to the first page of this set. Mandatory if this response is not the first page
   * @type {string}
   * @memberof LinksPaginated
   */
  first?: string;
  /**
   * URI to the previous page of this set. Mandatory if this response is not the first page
   * @type {string}
   * @memberof LinksPaginated
   */
  prev?: string;
  /**
   * URI to the next page of this set. Mandatory if this response is not the last page
   * @type {string}
   * @memberof LinksPaginated
   */
  next?: string;
  /**
   * URI to the last page of this set. Mandatory if this response is not the last page
   * @type {string}
   * @memberof LinksPaginated
   */
  last?: string;
}
/**
 *
 * @export
 * @interface MetaPaginated
 */
export interface MetaPaginated {
  /**
   * The total number of records in the full set. See [pagination](#pagination).
   * @type {number}
   * @memberof MetaPaginated
   */
  totalRecords: number;
  /**
   * The total number of pages in the full set. See [pagination](#pagination).
   * @type {number}
   * @memberof MetaPaginated
   */
  totalPages: number;
}

/**
 * BankingApi - axios parameter creator
 * @export
 */
export const BankingApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Obtain the list of banking accounts that consumers have consented to share across all data holders
     * @summary Get Banking Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingAccounts: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/accounts`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (isOwned !== undefined) {
        localVarQueryParameter['isOwned'] = isOwned;
      }

      if (openStatus !== undefined) {
        localVarQueryParameter['openStatus'] = openStatus;
      }

      if (productCategories) {
        localVarQueryParameter['productCategories'] = productCategories;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking direct debits that consumers have consented to share across all data holders
     * @summary Get Banking Direct Debits
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingDirectDebits: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/direct-debits`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (isOwned !== undefined) {
        localVarQueryParameter['isOwned'] = isOwned;
      }

      if (openStatus !== undefined) {
        localVarQueryParameter['openStatus'] = openStatus;
      }

      if (productCategories) {
        localVarQueryParameter['productCategories'] = productCategories;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking payees that consumers have consented to share across all data holders
     * @summary Get Banking Payees
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the payee type field.
     * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingPayees: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      payeeIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/payees`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (types) {
        localVarQueryParameter['types'] = types;
      }

      if (payeeIds) {
        localVarQueryParameter['payeeIds'] = payeeIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of banking transactions that consumers have consented to share across all data holders
     * @summary Get Banking Transactions
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the type field.
     * @param {number} [minimumAmount] Used to filter results on the amount field
     * @param {number} [maximumAmount] Used to filter results on the amount field
     * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. If absent defaults newest time minus 90 days. Format is aligned to DateTimeString common type.
     * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. If absent defaults to now. Format is aligned to DateTimeString common type.
     * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
     * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time.  If absent defaults to today.  Format is aligned to DateTimeString common type
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingTransactions: async (
      useCaseIds?: Array<string>,
      accountIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      minimumAmount?: number,
      maximumAmount?: number,
      oldestRetrievalTime?: string,
      newestRetrievalTime?: string,
      oldestTime?: string,
      newestTime?: string,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/banking/transactions`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (types) {
        localVarQueryParameter['types'] = types;
      }

      if (minimumAmount !== undefined) {
        localVarQueryParameter['minimumAmount'] = minimumAmount;
      }

      if (maximumAmount !== undefined) {
        localVarQueryParameter['maximumAmount'] = maximumAmount;
      }

      if (oldestRetrievalTime !== undefined) {
        localVarQueryParameter['oldestRetrievalTime'] = oldestRetrievalTime;
      }

      if (newestRetrievalTime !== undefined) {
        localVarQueryParameter['newestRetrievalTime'] = newestRetrievalTime;
      }

      if (oldestTime !== undefined) {
        localVarQueryParameter['oldestTime'] = oldestTime;
      }

      if (newestTime !== undefined) {
        localVarQueryParameter['newestTime'] = newestTime;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * BankingApi - functional programming interface
 * @export
 */
export const BankingApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Obtain the list of banking accounts that consumers have consented to share across all data holders
     * @summary Get Banking Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingAccountList>> {
      const localVarAxiosArgs = await BankingApiAxiosParamCreator(configuration).getBankingAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of banking direct debits that consumers have consented to share across all data holders
     * @summary Get Banking Direct Debits
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingDirectDebits(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingDirectDebitAuthorisationList>> {
      const localVarAxiosArgs = await BankingApiAxiosParamCreator(configuration).getBankingDirectDebits(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        accountIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of banking payees that consumers have consented to share across all data holders
     * @summary Get Banking Payees
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the payee type field.
     * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingPayees(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      payeeIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingPayeeList>> {
      const localVarAxiosArgs = await BankingApiAxiosParamCreator(configuration).getBankingPayees(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        payeeIds,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of banking transactions that consumers have consented to share across all data holders
     * @summary Get Banking Transactions
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the type field.
     * @param {number} [minimumAmount] Used to filter results on the amount field
     * @param {number} [maximumAmount] Used to filter results on the amount field
     * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. If absent defaults newest time minus 90 days. Format is aligned to DateTimeString common type.
     * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. If absent defaults to now. Format is aligned to DateTimeString common type.
     * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
     * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time.  If absent defaults to today.  Format is aligned to DateTimeString common type
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getBankingTransactions(
      useCaseIds?: Array<string>,
      accountIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      minimumAmount?: number,
      maximumAmount?: number,
      oldestRetrievalTime?: string,
      newestRetrievalTime?: string,
      oldestTime?: string,
      newestTime?: string,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<BankingTransactionList>> {
      const localVarAxiosArgs = await BankingApiAxiosParamCreator(configuration).getBankingTransactions(
        useCaseIds,
        accountIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        minimumAmount,
        maximumAmount,
        oldestRetrievalTime,
        newestRetrievalTime,
        oldestTime,
        newestTime,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * BankingApi - factory interface
 * @export
 */
export const BankingApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Obtain the list of banking accounts that consumers have consented to share across all data holders
     * @summary Get Banking Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingAccountList> {
      return BankingApiFp(configuration)
        .getBankingAccounts(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          dataHolderBrandIds,
          isOwned,
          openStatus,
          productCategories,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking direct debits that consumers have consented to share across all data holders
     * @summary Get Banking Direct Debits
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
     * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
     * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingDirectDebits(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      accountIds?: Array<string>,
      isOwned?: boolean,
      openStatus?: 'OPEN' | 'CLOSED',
      productCategories?: Array<
        | 'BUSINESS_LOANS'
        | 'CRED_AND_CHRG_CARDS'
        | 'LEASES'
        | 'MARGIN_LOANS'
        | 'OVERDRAFTS'
        | 'PERS_LOANS'
        | 'REGULATED_TRUST_ACCOUNTS'
        | 'RESIDENTIAL_MORTGAGES'
        | 'TERM_DEPOSITS'
        | 'TRADE_FINANCE'
        | 'TRAVEL_CARDS'
        | 'TRANS_AND_SAVINGS_ACCOUNTS'
      >,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingDirectDebitAuthorisationList> {
      return BankingApiFp(configuration)
        .getBankingDirectDebits(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          accountIds,
          isOwned,
          openStatus,
          productCategories,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking payees that consumers have consented to share across all data holders
     * @summary Get Banking Payees
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the payee type field.
     * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingPayees(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      payeeIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingPayeeList> {
      return BankingApiFp(configuration)
        .getBankingPayees(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          types,
          payeeIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of banking transactions that consumers have consented to share across all data holders
     * @summary Get Banking Transactions
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {Array<string>} [types] Used to filter results on the type field.
     * @param {number} [minimumAmount] Used to filter results on the amount field
     * @param {number} [maximumAmount] Used to filter results on the amount field
     * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. If absent defaults newest time minus 90 days. Format is aligned to DateTimeString common type.
     * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. If absent defaults to now. Format is aligned to DateTimeString common type.
     * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
     * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time.  If absent defaults to today.  Format is aligned to DateTimeString common type
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getBankingTransactions(
      useCaseIds?: Array<string>,
      accountIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      types?: Array<string>,
      minimumAmount?: number,
      maximumAmount?: number,
      oldestRetrievalTime?: string,
      newestRetrievalTime?: string,
      oldestTime?: string,
      newestTime?: string,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<BankingTransactionList> {
      return BankingApiFp(configuration)
        .getBankingTransactions(
          useCaseIds,
          accountIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          dataHolderBrandIds,
          types,
          minimumAmount,
          maximumAmount,
          oldestRetrievalTime,
          newestRetrievalTime,
          oldestTime,
          newestTime,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * BankingApi - object-oriented interface
 * @export
 * @class BankingApi
 * @extends {BaseAPI}
 */
export class BankingApi extends BaseAPI {
  /**
   * Obtain the list of banking accounts that consumers have consented to share across all data holders
   * @summary Get Banking Accounts
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
   * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
   * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingAccounts(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    isOwned?: boolean,
    openStatus?: 'OPEN' | 'CLOSED',
    productCategories?: Array<
      | 'BUSINESS_LOANS'
      | 'CRED_AND_CHRG_CARDS'
      | 'LEASES'
      | 'MARGIN_LOANS'
      | 'OVERDRAFTS'
      | 'PERS_LOANS'
      | 'REGULATED_TRUST_ACCOUNTS'
      | 'RESIDENTIAL_MORTGAGES'
      | 'TERM_DEPOSITS'
      | 'TRADE_FINANCE'
      | 'TRAVEL_CARDS'
      | 'TRANS_AND_SAVINGS_ACCOUNTS'
    >,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking direct debits that consumers have consented to share across all data holders
   * @summary Get Banking Direct Debits
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {boolean} [isOwned] Filters accounts based on whether they are owned by the authorised customer. True for owned accounts, false for unowned accounts and absent for all accounts
   * @param {'OPEN' | 'CLOSED'} [openStatus] Used to filter results according to open/closed status. Values can be OPEN, CLOSED
   * @param {Array<'BUSINESS_LOANS' | 'CRED_AND_CHRG_CARDS' | 'LEASES' | 'MARGIN_LOANS' | 'OVERDRAFTS' | 'PERS_LOANS' | 'REGULATED_TRUST_ACCOUNTS' | 'RESIDENTIAL_MORTGAGES' | 'TERM_DEPOSITS' | 'TRADE_FINANCE' | 'TRAVEL_CARDS' | 'TRANS_AND_SAVINGS_ACCOUNTS'>} [productCategories] Used to filter results on the productCategory field applicable to accounts. Any one of the valid values for this field can be supplied. If absent then all accounts returned.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingDirectDebits(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    accountIds?: Array<string>,
    isOwned?: boolean,
    openStatus?: 'OPEN' | 'CLOSED',
    productCategories?: Array<
      | 'BUSINESS_LOANS'
      | 'CRED_AND_CHRG_CARDS'
      | 'LEASES'
      | 'MARGIN_LOANS'
      | 'OVERDRAFTS'
      | 'PERS_LOANS'
      | 'REGULATED_TRUST_ACCOUNTS'
      | 'RESIDENTIAL_MORTGAGES'
      | 'TERM_DEPOSITS'
      | 'TRADE_FINANCE'
      | 'TRAVEL_CARDS'
      | 'TRANS_AND_SAVINGS_ACCOUNTS'
    >,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingDirectDebits(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        accountIds,
        isOwned,
        openStatus,
        productCategories,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking payees that consumers have consented to share across all data holders
   * @summary Get Banking Payees
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<string>} [types] Used to filter results on the payee type field.
   * @param {Array<string>} [payeeIds] Used to filter results on the payeeId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingPayees(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    types?: Array<string>,
    payeeIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingPayees(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        payeeIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of banking transactions that consumers have consented to share across all data holders
   * @summary Get Banking Transactions
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {Array<string>} [types] Used to filter results on the type field.
   * @param {number} [minimumAmount] Used to filter results on the amount field
   * @param {number} [maximumAmount] Used to filter results on the amount field
   * @param {string} [oldestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or after this date/time. If absent defaults newest time minus 90 days. Format is aligned to DateTimeString common type.
   * @param {string} [newestRetrievalTime] Constrain the transaction history request to transactions with retrieval time at or before this date/time. If absent defaults to now. Format is aligned to DateTimeString common type.
   * @param {string} [oldestTime] Constrain the transaction history request to transactions with effective time at or after this date/time. If absent defaults to newest-time minus 90 days.  Format is aligned to DateTimeString common type
   * @param {string} [newestTime] Constrain the transaction history request to transactions with effective time at or before this date/time.  If absent defaults to today.  Format is aligned to DateTimeString common type
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof BankingApi
   */
  public getBankingTransactions(
    useCaseIds?: Array<string>,
    accountIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    types?: Array<string>,
    minimumAmount?: number,
    maximumAmount?: number,
    oldestRetrievalTime?: string,
    newestRetrievalTime?: string,
    oldestTime?: string,
    newestTime?: string,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return BankingApiFp(this.configuration)
      .getBankingTransactions(
        useCaseIds,
        accountIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        dataHolderBrandIds,
        types,
        minimumAmount,
        maximumAmount,
        oldestRetrievalTime,
        newestRetrievalTime,
        oldestTime,
        newestTime,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }
}

/**
 * EnergyApi - axios parameter creator
 * @export
 */
export const EnergyApiAxiosParamCreator = function (configuration?: Configuration) {
  return {
    /**
     * Obtain the list of energy accounts that consumers have consented to share across all data holders
     * @summary Get Energy Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyAccounts: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/accounts`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy bills that consumers have consented to share across all data holders
     * @summary Get Energy Bills
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyBills: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      billingIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/bills`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (billingIds) {
        localVarQueryParameter['billingIds'] = billingIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy service points that consumers have consented to share across all data holders
     * @summary Get Electricity Service Points
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityServicePoints: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/electricity/servicepoints`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (servicePointIds) {
        localVarQueryParameter['servicePointIds'] = servicePointIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of electricity usage records that consumers have consented to share across all data holders
     * @summary Get Electricity Usage
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityUsage: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/electricity/usage`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (servicePointIds) {
        localVarQueryParameter['servicePointIds'] = servicePointIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy invoices that consumers have consented to share across all data holders
     * @summary Get Energy Invoices
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyInvoices: async (
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      invoiceIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/invoices`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (useCaseIds) {
        localVarQueryParameter['useCaseIds'] = useCaseIds;
      }

      if (cdrArrangementIds) {
        localVarQueryParameter['cdrArrangementIds'] = cdrArrangementIds;
      }

      if (consentIds) {
        localVarQueryParameter['consentIds'] = consentIds;
      }

      if (consumerIds) {
        localVarQueryParameter['consumerIds'] = consumerIds;
      }

      if (accountIds) {
        localVarQueryParameter['accountIds'] = accountIds;
      }

      if (invoiceIds) {
        localVarQueryParameter['invoiceIds'] = invoiceIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
    /**
     * Obtain the list of energy plans across all data holders
     * @summary Get Energy Plans
     * @param {Array<string>} [planIds] Used to filter results on the planId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyPlans: async (
      planIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options: any = {},
    ): Promise<RequestArgs> => {
      const localVarPath = `/data/energy/plans`;
      const localVarUrlObj = globalImportUrl.parse(localVarPath, true);
      let baseOptions;
      if (configuration) {
        baseOptions = configuration.baseOptions;
      }
      const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options };
      const localVarHeaderParameter = {} as any;
      const localVarQueryParameter = {} as any;

      // authentication bearerAuth required
      // http bearer authentication required
      if (configuration && configuration.accessToken) {
        const accessToken =
          typeof configuration.accessToken === 'function' ? configuration.accessToken() : configuration.accessToken;
        localVarHeaderParameter['Authorization'] = 'Bearer ' + accessToken;
      }

      if (planIds) {
        localVarQueryParameter['planIds'] = planIds;
      }

      if (dataHolderBrandIds) {
        localVarQueryParameter['dataHolderBrandIds'] = dataHolderBrandIds;
      }

      if (page !== undefined) {
        localVarQueryParameter['page'] = page;
      }

      if (pageSize !== undefined) {
        localVarQueryParameter['pageSize'] = pageSize;
      }

      localVarUrlObj.query = { ...localVarUrlObj.query, ...localVarQueryParameter, ...options.query };
      // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
      delete localVarUrlObj.search;
      let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
      localVarRequestOptions.headers = { ...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers };

      return {
        url: globalImportUrl.format(localVarUrlObj),
        options: localVarRequestOptions,
      };
    },
  };
};

/**
 * EnergyApi - functional programming interface
 * @export
 */
export const EnergyApiFp = function (configuration?: Configuration) {
  return {
    /**
     * Obtain the list of energy accounts that consumers have consented to share across all data holders
     * @summary Get Energy Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyAccountList>> {
      const localVarAxiosArgs = await EnergyApiAxiosParamCreator(configuration).getEnergyAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of energy bills that consumers have consented to share across all data holders
     * @summary Get Energy Bills
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyBills(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      billingIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyBillingList>> {
      const localVarAxiosArgs = await EnergyApiAxiosParamCreator(configuration).getEnergyBills(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        billingIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of energy service points that consumers have consented to share across all data holders
     * @summary Get Electricity Service Points
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyElectricityServicePoints(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyServicePointList>> {
      const localVarAxiosArgs = await EnergyApiAxiosParamCreator(configuration).getEnergyElectricityServicePoints(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of electricity usage records that consumers have consented to share across all data holders
     * @summary Get Electricity Usage
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyElectricityUsage(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyUsageList>> {
      const localVarAxiosArgs = await EnergyApiAxiosParamCreator(configuration).getEnergyElectricityUsage(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of energy invoices that consumers have consented to share across all data holders
     * @summary Get Energy Invoices
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyInvoices(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      invoiceIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyInvoiceList>> {
      const localVarAxiosArgs = await EnergyApiAxiosParamCreator(configuration).getEnergyInvoices(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        invoiceIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
    /**
     * Obtain the list of energy plans across all data holders
     * @summary Get Energy Plans
     * @param {Array<string>} [planIds] Used to filter results on the planId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    async getEnergyPlans(
      planIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<EnergyPlanList>> {
      const localVarAxiosArgs = await EnergyApiAxiosParamCreator(configuration).getEnergyPlans(
        planIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      );
      return (axios: AxiosInstance = globalAxios, basePath: string = BASE_PATH) => {
        const axiosRequestArgs = { ...localVarAxiosArgs.options, url: basePath + localVarAxiosArgs.url };
        return axios.request(axiosRequestArgs);
      };
    },
  };
};

/**
 * EnergyApi - factory interface
 * @export
 */
export const EnergyApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
  return {
    /**
     * Obtain the list of energy accounts that consumers have consented to share across all data holders
     * @summary Get Energy Accounts
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyAccounts(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyAccountList> {
      return EnergyApiFp(configuration)
        .getEnergyAccounts(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy bills that consumers have consented to share across all data holders
     * @summary Get Energy Bills
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyBills(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      billingIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyBillingList> {
      return EnergyApiFp(configuration)
        .getEnergyBills(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          billingIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy service points that consumers have consented to share across all data holders
     * @summary Get Electricity Service Points
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityServicePoints(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyServicePointList> {
      return EnergyApiFp(configuration)
        .getEnergyElectricityServicePoints(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          servicePointIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of electricity usage records that consumers have consented to share across all data holders
     * @summary Get Electricity Usage
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyElectricityUsage(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      servicePointIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyUsageList> {
      return EnergyApiFp(configuration)
        .getEnergyElectricityUsage(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          servicePointIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy invoices that consumers have consented to share across all data holders
     * @summary Get Energy Invoices
     * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
     * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
     * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
     * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
     * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
     * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyInvoices(
      useCaseIds?: Array<string>,
      cdrArrangementIds?: Array<string>,
      consentIds?: Array<string>,
      consumerIds?: Array<string>,
      accountIds?: Array<string>,
      invoiceIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyInvoiceList> {
      return EnergyApiFp(configuration)
        .getEnergyInvoices(
          useCaseIds,
          cdrArrangementIds,
          consentIds,
          consumerIds,
          accountIds,
          invoiceIds,
          dataHolderBrandIds,
          page,
          pageSize,
          options,
        )
        .then((request) => request(axios, basePath));
    },
    /**
     * Obtain the list of energy plans across all data holders
     * @summary Get Energy Plans
     * @param {Array<string>} [planIds] Used to filter results on the planId field.
     * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
     * @param {number} [page] Page of results to request (standard pagination)
     * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     */
    getEnergyPlans(
      planIds?: Array<string>,
      dataHolderBrandIds?: Array<string>,
      page?: number,
      pageSize?: number,
      options?: any,
    ): AxiosPromise<EnergyPlanList> {
      return EnergyApiFp(configuration)
        .getEnergyPlans(planIds, dataHolderBrandIds, page, pageSize, options)
        .then((request) => request(axios, basePath));
    },
  };
};

/**
 * EnergyApi - object-oriented interface
 * @export
 * @class EnergyApi
 * @extends {BaseAPI}
 */
export class EnergyApi extends BaseAPI {
  /**
   * Obtain the list of energy accounts that consumers have consented to share across all data holders
   * @summary Get Energy Accounts
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyAccounts(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyAccounts(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy bills that consumers have consented to share across all data holders
   * @summary Get Energy Bills
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [billingIds] Used to filter results on the billingId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyBills(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    billingIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyBills(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        billingIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy service points that consumers have consented to share across all data holders
   * @summary Get Electricity Service Points
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyElectricityServicePoints(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    servicePointIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyElectricityServicePoints(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of electricity usage records that consumers have consented to share across all data holders
   * @summary Get Electricity Usage
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [servicePointIds] Used to filter results on the servicePointId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyElectricityUsage(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    servicePointIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyElectricityUsage(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        servicePointIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy invoices that consumers have consented to share across all data holders
   * @summary Get Energy Invoices
   * @param {Array<string>} [useCaseIds] Used to filter results on the useCaseId field.
   * @param {Array<string>} [cdrArrangementIds] Used to filter results on the cdrArrangementId field.
   * @param {Array<string>} [consentIds] Used to filter results on the consentId field.
   * @param {Array<string>} [consumerIds] Used to filter results on the consumerId field.
   * @param {Array<string>} [accountIds] Used to filter results on the accountId field.
   * @param {Array<string>} [invoiceIds] Used to filter results on the invoiceId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyInvoices(
    useCaseIds?: Array<string>,
    cdrArrangementIds?: Array<string>,
    consentIds?: Array<string>,
    consumerIds?: Array<string>,
    accountIds?: Array<string>,
    invoiceIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyInvoices(
        useCaseIds,
        cdrArrangementIds,
        consentIds,
        consumerIds,
        accountIds,
        invoiceIds,
        dataHolderBrandIds,
        page,
        pageSize,
        options,
      )
      .then((request) => request(this.axios, this.basePath));
  }

  /**
   * Obtain the list of energy plans across all data holders
   * @summary Get Energy Plans
   * @param {Array<string>} [planIds] Used to filter results on the planId field.
   * @param {Array<string>} [dataHolderBrandIds] Used to filter results on the dataHolderBrandId field.
   * @param {number} [page] Page of results to request (standard pagination)
   * @param {number} [pageSize] Page size to request. Default is 25 (standard pagination)
   * @param {*} [options] Override http request option.
   * @throws {RequiredError}
   * @memberof EnergyApi
   */
  public getEnergyPlans(
    planIds?: Array<string>,
    dataHolderBrandIds?: Array<string>,
    page?: number,
    pageSize?: number,
    options?: any,
  ) {
    return EnergyApiFp(this.configuration)
      .getEnergyPlans(planIds, dataHolderBrandIds, page, pageSize, options)
      .then((request) => request(this.axios, this.basePath));
  }
}
